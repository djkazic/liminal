// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: loop.proto

package looprpc;

public final class Loop {
  private Loop() {}
  public static void registerAllExtensions(
      com.google.protobuf.ExtensionRegistryLite registry) {
  }

  public static void registerAllExtensions(
      com.google.protobuf.ExtensionRegistry registry) {
    registerAllExtensions(
        (com.google.protobuf.ExtensionRegistryLite) registry);
  }
  /**
   * <pre>
   *
   *`AddressType` has to be one of:
   *
   *- `unknown`: Unknown address type
   *- `p2tr`: Pay to taproot pubkey (`TAPROOT_PUBKEY` = 1)
   * </pre>
   *
   * Protobuf enum {@code looprpc.AddressType}
   */
  public enum AddressType
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>ADDRESS_TYPE_UNKNOWN = 0;</code>
     */
    ADDRESS_TYPE_UNKNOWN(0),
    /**
     * <code>TAPROOT_PUBKEY = 1;</code>
     */
    TAPROOT_PUBKEY(1),
    UNRECOGNIZED(-1),
    ;

    /**
     * <code>ADDRESS_TYPE_UNKNOWN = 0;</code>
     */
    public static final int ADDRESS_TYPE_UNKNOWN_VALUE = 0;
    /**
     * <code>TAPROOT_PUBKEY = 1;</code>
     */
    public static final int TAPROOT_PUBKEY_VALUE = 1;


    public final int getNumber() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalArgumentException(
            "Can't get the number of an unknown enum value.");
      }
      return value;
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     * @deprecated Use {@link #forNumber(int)} instead.
     */
    @java.lang.Deprecated
    public static AddressType valueOf(int value) {
      return forNumber(value);
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     */
    public static AddressType forNumber(int value) {
      switch (value) {
        case 0: return ADDRESS_TYPE_UNKNOWN;
        case 1: return TAPROOT_PUBKEY;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<AddressType>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static final com.google.protobuf.Internal.EnumLiteMap<
        AddressType> internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<AddressType>() {
            public AddressType findValueByNumber(int number) {
              return AddressType.forNumber(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalStateException(
            "Can't get the descriptor of an unrecognized enum value.");
      }
      return getDescriptor().getValues().get(ordinal());
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return looprpc.Loop.getDescriptor().getEnumTypes().get(0);
    }

    private static final AddressType[] VALUES = values();

    public static AddressType valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      if (desc.getIndex() == -1) {
        return UNRECOGNIZED;
      }
      return VALUES[desc.getIndex()];
    }

    private final int value;

    private AddressType(int value) {
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:looprpc.AddressType)
  }

  /**
   * Protobuf enum {@code looprpc.SwapType}
   */
  public enum SwapType
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <pre>
     * LOOP_OUT indicates an loop out swap (off-chain to on-chain)
     * </pre>
     *
     * <code>LOOP_OUT = 0;</code>
     */
    LOOP_OUT(0),
    /**
     * <pre>
     * LOOP_IN indicates a loop in swap (on-chain to off-chain)
     * </pre>
     *
     * <code>LOOP_IN = 1;</code>
     */
    LOOP_IN(1),
    UNRECOGNIZED(-1),
    ;

    /**
     * <pre>
     * LOOP_OUT indicates an loop out swap (off-chain to on-chain)
     * </pre>
     *
     * <code>LOOP_OUT = 0;</code>
     */
    public static final int LOOP_OUT_VALUE = 0;
    /**
     * <pre>
     * LOOP_IN indicates a loop in swap (on-chain to off-chain)
     * </pre>
     *
     * <code>LOOP_IN = 1;</code>
     */
    public static final int LOOP_IN_VALUE = 1;


    public final int getNumber() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalArgumentException(
            "Can't get the number of an unknown enum value.");
      }
      return value;
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     * @deprecated Use {@link #forNumber(int)} instead.
     */
    @java.lang.Deprecated
    public static SwapType valueOf(int value) {
      return forNumber(value);
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     */
    public static SwapType forNumber(int value) {
      switch (value) {
        case 0: return LOOP_OUT;
        case 1: return LOOP_IN;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<SwapType>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static final com.google.protobuf.Internal.EnumLiteMap<
        SwapType> internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<SwapType>() {
            public SwapType findValueByNumber(int number) {
              return SwapType.forNumber(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalStateException(
            "Can't get the descriptor of an unrecognized enum value.");
      }
      return getDescriptor().getValues().get(ordinal());
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return looprpc.Loop.getDescriptor().getEnumTypes().get(1);
    }

    private static final SwapType[] VALUES = values();

    public static SwapType valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      if (desc.getIndex() == -1) {
        return UNRECOGNIZED;
      }
      return VALUES[desc.getIndex()];
    }

    private final int value;

    private SwapType(int value) {
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:looprpc.SwapType)
  }

  /**
   * Protobuf enum {@code looprpc.SwapState}
   */
  public enum SwapState
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <pre>
     *
     *INITIATED is the initial state of a swap. At that point, the initiation
     *call to the server has been made and the payment process has been started
     *for the swap and prepayment invoices.
     * </pre>
     *
     * <code>INITIATED = 0;</code>
     */
    INITIATED(0),
    /**
     * <pre>
     *
     *PREIMAGE_REVEALED is reached when the sweep tx publication is first
     *attempted. From that point on, we should consider the preimage to no
     *longer be secret and we need to do all we can to get the sweep confirmed.
     *This state will mostly coalesce with StateHtlcConfirmed, except in the
     *case where we wait for fees to come down before we sweep.
     * </pre>
     *
     * <code>PREIMAGE_REVEALED = 1;</code>
     */
    PREIMAGE_REVEALED(1),
    /**
     * <pre>
     *
     *HTLC_PUBLISHED is reached when the htlc tx has been published in a loop in
     *swap.
     * </pre>
     *
     * <code>HTLC_PUBLISHED = 2;</code>
     */
    HTLC_PUBLISHED(2),
    /**
     * <pre>
     *
     *SUCCESS is the final swap state that is reached when the sweep tx has
     *the required confirmation depth.
     * </pre>
     *
     * <code>SUCCESS = 3;</code>
     */
    SUCCESS(3),
    /**
     * <pre>
     *
     *FAILED is the final swap state for a failed swap with or without loss of
     *the swap amount.
     * </pre>
     *
     * <code>FAILED = 4;</code>
     */
    FAILED(4),
    /**
     * <pre>
     *
     *INVOICE_SETTLED is reached when the swap invoice in a loop in swap has been
     *paid, but we are still waiting for the htlc spend to confirm.
     * </pre>
     *
     * <code>INVOICE_SETTLED = 5;</code>
     */
    INVOICE_SETTLED(5),
    UNRECOGNIZED(-1),
    ;

    /**
     * <pre>
     *
     *INITIATED is the initial state of a swap. At that point, the initiation
     *call to the server has been made and the payment process has been started
     *for the swap and prepayment invoices.
     * </pre>
     *
     * <code>INITIATED = 0;</code>
     */
    public static final int INITIATED_VALUE = 0;
    /**
     * <pre>
     *
     *PREIMAGE_REVEALED is reached when the sweep tx publication is first
     *attempted. From that point on, we should consider the preimage to no
     *longer be secret and we need to do all we can to get the sweep confirmed.
     *This state will mostly coalesce with StateHtlcConfirmed, except in the
     *case where we wait for fees to come down before we sweep.
     * </pre>
     *
     * <code>PREIMAGE_REVEALED = 1;</code>
     */
    public static final int PREIMAGE_REVEALED_VALUE = 1;
    /**
     * <pre>
     *
     *HTLC_PUBLISHED is reached when the htlc tx has been published in a loop in
     *swap.
     * </pre>
     *
     * <code>HTLC_PUBLISHED = 2;</code>
     */
    public static final int HTLC_PUBLISHED_VALUE = 2;
    /**
     * <pre>
     *
     *SUCCESS is the final swap state that is reached when the sweep tx has
     *the required confirmation depth.
     * </pre>
     *
     * <code>SUCCESS = 3;</code>
     */
    public static final int SUCCESS_VALUE = 3;
    /**
     * <pre>
     *
     *FAILED is the final swap state for a failed swap with or without loss of
     *the swap amount.
     * </pre>
     *
     * <code>FAILED = 4;</code>
     */
    public static final int FAILED_VALUE = 4;
    /**
     * <pre>
     *
     *INVOICE_SETTLED is reached when the swap invoice in a loop in swap has been
     *paid, but we are still waiting for the htlc spend to confirm.
     * </pre>
     *
     * <code>INVOICE_SETTLED = 5;</code>
     */
    public static final int INVOICE_SETTLED_VALUE = 5;


    public final int getNumber() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalArgumentException(
            "Can't get the number of an unknown enum value.");
      }
      return value;
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     * @deprecated Use {@link #forNumber(int)} instead.
     */
    @java.lang.Deprecated
    public static SwapState valueOf(int value) {
      return forNumber(value);
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     */
    public static SwapState forNumber(int value) {
      switch (value) {
        case 0: return INITIATED;
        case 1: return PREIMAGE_REVEALED;
        case 2: return HTLC_PUBLISHED;
        case 3: return SUCCESS;
        case 4: return FAILED;
        case 5: return INVOICE_SETTLED;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<SwapState>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static final com.google.protobuf.Internal.EnumLiteMap<
        SwapState> internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<SwapState>() {
            public SwapState findValueByNumber(int number) {
              return SwapState.forNumber(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalStateException(
            "Can't get the descriptor of an unrecognized enum value.");
      }
      return getDescriptor().getValues().get(ordinal());
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return looprpc.Loop.getDescriptor().getEnumTypes().get(2);
    }

    private static final SwapState[] VALUES = values();

    public static SwapState valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      if (desc.getIndex() == -1) {
        return UNRECOGNIZED;
      }
      return VALUES[desc.getIndex()];
    }

    private final int value;

    private SwapState(int value) {
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:looprpc.SwapState)
  }

  /**
   * Protobuf enum {@code looprpc.FailureReason}
   */
  public enum FailureReason
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <pre>
     *
     *FAILURE_REASON_NONE is set when the swap did not fail, it is either in
     *progress or succeeded.
     * </pre>
     *
     * <code>FAILURE_REASON_NONE = 0;</code>
     */
    FAILURE_REASON_NONE(0),
    /**
     * <pre>
     *
     *FAILURE_REASON_OFFCHAIN indicates that a loop out failed because it wasn't
     *possible to find a route for one or both off chain payments that met the fee
     *and timelock limits required.
     * </pre>
     *
     * <code>FAILURE_REASON_OFFCHAIN = 1;</code>
     */
    FAILURE_REASON_OFFCHAIN(1),
    /**
     * <pre>
     *
     *FAILURE_REASON_TIMEOUT indicates that the swap failed because on chain htlc
     *did not confirm before its expiry, or it confirmed too late for us to reveal
     *our preimage and claim.
     * </pre>
     *
     * <code>FAILURE_REASON_TIMEOUT = 2;</code>
     */
    FAILURE_REASON_TIMEOUT(2),
    /**
     * <pre>
     *
     *FAILURE_REASON_SWEEP_TIMEOUT indicates that a loop out permanently failed
     *because the on chain htlc wasn't swept before the server revoked the
     *htlc.
     * </pre>
     *
     * <code>FAILURE_REASON_SWEEP_TIMEOUT = 3;</code>
     */
    FAILURE_REASON_SWEEP_TIMEOUT(3),
    /**
     * <pre>
     *
     *FAILURE_REASON_INSUFFICIENT_VALUE indicates that a loop out has failed
     *because the on chain htlc had a lower value than requested.
     * </pre>
     *
     * <code>FAILURE_REASON_INSUFFICIENT_VALUE = 4;</code>
     */
    FAILURE_REASON_INSUFFICIENT_VALUE(4),
    /**
     * <pre>
     *
     *FAILURE_REASON_TEMPORARY indicates that a swap cannot continue due to an
     *internal error. Manual intervention such as a restart is required.
     * </pre>
     *
     * <code>FAILURE_REASON_TEMPORARY = 5;</code>
     */
    FAILURE_REASON_TEMPORARY(5),
    /**
     * <pre>
     *
     *FAILURE_REASON_INCORRECT_AMOUNT indicates that a loop in permanently failed
     *because the amount extended by an external loop in htlc is insufficient.
     * </pre>
     *
     * <code>FAILURE_REASON_INCORRECT_AMOUNT = 6;</code>
     */
    FAILURE_REASON_INCORRECT_AMOUNT(6),
    /**
     * <pre>
     *
     *FAILURE_REASON_ABANDONED indicates that a swap permanently failed because
     *the client manually abandoned the swap.
     * </pre>
     *
     * <code>FAILURE_REASON_ABANDONED = 7;</code>
     */
    FAILURE_REASON_ABANDONED(7),
    /**
     * <pre>
     *
     *FAILURE_REASON_INSUFFICIENT_CONFIRMED_BALANCE indicates that a swap
     *wasn't published due to insufficient confirmed balance.
     * </pre>
     *
     * <code>FAILURE_REASON_INSUFFICIENT_CONFIRMED_BALANCE = 8;</code>
     */
    FAILURE_REASON_INSUFFICIENT_CONFIRMED_BALANCE(8),
    UNRECOGNIZED(-1),
    ;

    /**
     * <pre>
     *
     *FAILURE_REASON_NONE is set when the swap did not fail, it is either in
     *progress or succeeded.
     * </pre>
     *
     * <code>FAILURE_REASON_NONE = 0;</code>
     */
    public static final int FAILURE_REASON_NONE_VALUE = 0;
    /**
     * <pre>
     *
     *FAILURE_REASON_OFFCHAIN indicates that a loop out failed because it wasn't
     *possible to find a route for one or both off chain payments that met the fee
     *and timelock limits required.
     * </pre>
     *
     * <code>FAILURE_REASON_OFFCHAIN = 1;</code>
     */
    public static final int FAILURE_REASON_OFFCHAIN_VALUE = 1;
    /**
     * <pre>
     *
     *FAILURE_REASON_TIMEOUT indicates that the swap failed because on chain htlc
     *did not confirm before its expiry, or it confirmed too late for us to reveal
     *our preimage and claim.
     * </pre>
     *
     * <code>FAILURE_REASON_TIMEOUT = 2;</code>
     */
    public static final int FAILURE_REASON_TIMEOUT_VALUE = 2;
    /**
     * <pre>
     *
     *FAILURE_REASON_SWEEP_TIMEOUT indicates that a loop out permanently failed
     *because the on chain htlc wasn't swept before the server revoked the
     *htlc.
     * </pre>
     *
     * <code>FAILURE_REASON_SWEEP_TIMEOUT = 3;</code>
     */
    public static final int FAILURE_REASON_SWEEP_TIMEOUT_VALUE = 3;
    /**
     * <pre>
     *
     *FAILURE_REASON_INSUFFICIENT_VALUE indicates that a loop out has failed
     *because the on chain htlc had a lower value than requested.
     * </pre>
     *
     * <code>FAILURE_REASON_INSUFFICIENT_VALUE = 4;</code>
     */
    public static final int FAILURE_REASON_INSUFFICIENT_VALUE_VALUE = 4;
    /**
     * <pre>
     *
     *FAILURE_REASON_TEMPORARY indicates that a swap cannot continue due to an
     *internal error. Manual intervention such as a restart is required.
     * </pre>
     *
     * <code>FAILURE_REASON_TEMPORARY = 5;</code>
     */
    public static final int FAILURE_REASON_TEMPORARY_VALUE = 5;
    /**
     * <pre>
     *
     *FAILURE_REASON_INCORRECT_AMOUNT indicates that a loop in permanently failed
     *because the amount extended by an external loop in htlc is insufficient.
     * </pre>
     *
     * <code>FAILURE_REASON_INCORRECT_AMOUNT = 6;</code>
     */
    public static final int FAILURE_REASON_INCORRECT_AMOUNT_VALUE = 6;
    /**
     * <pre>
     *
     *FAILURE_REASON_ABANDONED indicates that a swap permanently failed because
     *the client manually abandoned the swap.
     * </pre>
     *
     * <code>FAILURE_REASON_ABANDONED = 7;</code>
     */
    public static final int FAILURE_REASON_ABANDONED_VALUE = 7;
    /**
     * <pre>
     *
     *FAILURE_REASON_INSUFFICIENT_CONFIRMED_BALANCE indicates that a swap
     *wasn't published due to insufficient confirmed balance.
     * </pre>
     *
     * <code>FAILURE_REASON_INSUFFICIENT_CONFIRMED_BALANCE = 8;</code>
     */
    public static final int FAILURE_REASON_INSUFFICIENT_CONFIRMED_BALANCE_VALUE = 8;


    public final int getNumber() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalArgumentException(
            "Can't get the number of an unknown enum value.");
      }
      return value;
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     * @deprecated Use {@link #forNumber(int)} instead.
     */
    @java.lang.Deprecated
    public static FailureReason valueOf(int value) {
      return forNumber(value);
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     */
    public static FailureReason forNumber(int value) {
      switch (value) {
        case 0: return FAILURE_REASON_NONE;
        case 1: return FAILURE_REASON_OFFCHAIN;
        case 2: return FAILURE_REASON_TIMEOUT;
        case 3: return FAILURE_REASON_SWEEP_TIMEOUT;
        case 4: return FAILURE_REASON_INSUFFICIENT_VALUE;
        case 5: return FAILURE_REASON_TEMPORARY;
        case 6: return FAILURE_REASON_INCORRECT_AMOUNT;
        case 7: return FAILURE_REASON_ABANDONED;
        case 8: return FAILURE_REASON_INSUFFICIENT_CONFIRMED_BALANCE;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<FailureReason>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static final com.google.protobuf.Internal.EnumLiteMap<
        FailureReason> internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<FailureReason>() {
            public FailureReason findValueByNumber(int number) {
              return FailureReason.forNumber(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalStateException(
            "Can't get the descriptor of an unrecognized enum value.");
      }
      return getDescriptor().getValues().get(ordinal());
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return looprpc.Loop.getDescriptor().getEnumTypes().get(3);
    }

    private static final FailureReason[] VALUES = values();

    public static FailureReason valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      if (desc.getIndex() == -1) {
        return UNRECOGNIZED;
      }
      return VALUES[desc.getIndex()];
    }

    private final int value;

    private FailureReason(int value) {
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:looprpc.FailureReason)
  }

  /**
   * Protobuf enum {@code looprpc.LiquidityRuleType}
   */
  public enum LiquidityRuleType
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>UNKNOWN = 0;</code>
     */
    UNKNOWN(0),
    /**
     * <code>THRESHOLD = 1;</code>
     */
    THRESHOLD(1),
    UNRECOGNIZED(-1),
    ;

    /**
     * <code>UNKNOWN = 0;</code>
     */
    public static final int UNKNOWN_VALUE = 0;
    /**
     * <code>THRESHOLD = 1;</code>
     */
    public static final int THRESHOLD_VALUE = 1;


    public final int getNumber() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalArgumentException(
            "Can't get the number of an unknown enum value.");
      }
      return value;
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     * @deprecated Use {@link #forNumber(int)} instead.
     */
    @java.lang.Deprecated
    public static LiquidityRuleType valueOf(int value) {
      return forNumber(value);
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     */
    public static LiquidityRuleType forNumber(int value) {
      switch (value) {
        case 0: return UNKNOWN;
        case 1: return THRESHOLD;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<LiquidityRuleType>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static final com.google.protobuf.Internal.EnumLiteMap<
        LiquidityRuleType> internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<LiquidityRuleType>() {
            public LiquidityRuleType findValueByNumber(int number) {
              return LiquidityRuleType.forNumber(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalStateException(
            "Can't get the descriptor of an unrecognized enum value.");
      }
      return getDescriptor().getValues().get(ordinal());
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return looprpc.Loop.getDescriptor().getEnumTypes().get(4);
    }

    private static final LiquidityRuleType[] VALUES = values();

    public static LiquidityRuleType valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      if (desc.getIndex() == -1) {
        return UNRECOGNIZED;
      }
      return VALUES[desc.getIndex()];
    }

    private final int value;

    private LiquidityRuleType(int value) {
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:looprpc.LiquidityRuleType)
  }

  /**
   * Protobuf enum {@code looprpc.AutoReason}
   */
  public enum AutoReason
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>AUTO_REASON_UNKNOWN = 0;</code>
     */
    AUTO_REASON_UNKNOWN(0),
    /**
     * <pre>
     *
     *Budget not started indicates that we do not recommend any swaps because
     *the start time for our budget has not arrived yet.
     * </pre>
     *
     * <code>AUTO_REASON_BUDGET_NOT_STARTED = 1;</code>
     */
    AUTO_REASON_BUDGET_NOT_STARTED(1),
    /**
     * <pre>
     *
     *Sweep fees indicates that the estimated fees to sweep swaps are too high
     *right now.
     * </pre>
     *
     * <code>AUTO_REASON_SWEEP_FEES = 2;</code>
     */
    AUTO_REASON_SWEEP_FEES(2),
    /**
     * <pre>
     *
     *Budget elapsed indicates that the autoloop budget for the period has been
     *elapsed.
     * </pre>
     *
     * <code>AUTO_REASON_BUDGET_ELAPSED = 3;</code>
     */
    AUTO_REASON_BUDGET_ELAPSED(3),
    /**
     * <pre>
     *
     *In flight indicates that the limit on in-flight automatically dispatched
     *swaps has already been reached.
     * </pre>
     *
     * <code>AUTO_REASON_IN_FLIGHT = 4;</code>
     */
    AUTO_REASON_IN_FLIGHT(4),
    /**
     * <pre>
     *
     *Swap fee indicates that the server fee for a specific swap is too high.
     * </pre>
     *
     * <code>AUTO_REASON_SWAP_FEE = 5;</code>
     */
    AUTO_REASON_SWAP_FEE(5),
    /**
     * <pre>
     *
     *Miner fee indicates that the miner fee for a specific swap is to high.
     * </pre>
     *
     * <code>AUTO_REASON_MINER_FEE = 6;</code>
     */
    AUTO_REASON_MINER_FEE(6),
    /**
     * <pre>
     *
     *Prepay indicates that the prepay fee for a specific swap is too high.
     * </pre>
     *
     * <code>AUTO_REASON_PREPAY = 7;</code>
     */
    AUTO_REASON_PREPAY(7),
    /**
     * <pre>
     *
     *Failure backoff indicates that a swap has recently failed for this target,
     *and the backoff period has not yet passed.
     * </pre>
     *
     * <code>AUTO_REASON_FAILURE_BACKOFF = 8;</code>
     */
    AUTO_REASON_FAILURE_BACKOFF(8),
    /**
     * <pre>
     *
     *Loop out indicates that a loop out swap is currently utilizing the channel,
     *so it is not eligible.
     * </pre>
     *
     * <code>AUTO_REASON_LOOP_OUT = 9;</code>
     */
    AUTO_REASON_LOOP_OUT(9),
    /**
     * <pre>
     *
     *Loop In indicates that a loop in swap is currently in flight for the peer,
     *so it is not eligible.
     * </pre>
     *
     * <code>AUTO_REASON_LOOP_IN = 10;</code>
     */
    AUTO_REASON_LOOP_IN(10),
    /**
     * <pre>
     *
     *Liquidity ok indicates that a target meets the liquidity balance expressed
     *in its rule, so no swap is needed.
     * </pre>
     *
     * <code>AUTO_REASON_LIQUIDITY_OK = 11;</code>
     */
    AUTO_REASON_LIQUIDITY_OK(11),
    /**
     * <pre>
     *
     *Budget insufficient indicates that we cannot perform a swap because we do
     *not have enough pending budget available. This differs from budget elapsed,
     *because we still have some budget available, but we have allocated it to
     *other swaps.
     * </pre>
     *
     * <code>AUTO_REASON_BUDGET_INSUFFICIENT = 12;</code>
     */
    AUTO_REASON_BUDGET_INSUFFICIENT(12),
    /**
     * <pre>
     *
     *Fee insufficient indicates that the fee estimate for a swap is higher than
     *the portion of total swap amount that we allow fees to consume.
     * </pre>
     *
     * <code>AUTO_REASON_FEE_INSUFFICIENT = 13;</code>
     */
    AUTO_REASON_FEE_INSUFFICIENT(13),
    UNRECOGNIZED(-1),
    ;

    /**
     * <code>AUTO_REASON_UNKNOWN = 0;</code>
     */
    public static final int AUTO_REASON_UNKNOWN_VALUE = 0;
    /**
     * <pre>
     *
     *Budget not started indicates that we do not recommend any swaps because
     *the start time for our budget has not arrived yet.
     * </pre>
     *
     * <code>AUTO_REASON_BUDGET_NOT_STARTED = 1;</code>
     */
    public static final int AUTO_REASON_BUDGET_NOT_STARTED_VALUE = 1;
    /**
     * <pre>
     *
     *Sweep fees indicates that the estimated fees to sweep swaps are too high
     *right now.
     * </pre>
     *
     * <code>AUTO_REASON_SWEEP_FEES = 2;</code>
     */
    public static final int AUTO_REASON_SWEEP_FEES_VALUE = 2;
    /**
     * <pre>
     *
     *Budget elapsed indicates that the autoloop budget for the period has been
     *elapsed.
     * </pre>
     *
     * <code>AUTO_REASON_BUDGET_ELAPSED = 3;</code>
     */
    public static final int AUTO_REASON_BUDGET_ELAPSED_VALUE = 3;
    /**
     * <pre>
     *
     *In flight indicates that the limit on in-flight automatically dispatched
     *swaps has already been reached.
     * </pre>
     *
     * <code>AUTO_REASON_IN_FLIGHT = 4;</code>
     */
    public static final int AUTO_REASON_IN_FLIGHT_VALUE = 4;
    /**
     * <pre>
     *
     *Swap fee indicates that the server fee for a specific swap is too high.
     * </pre>
     *
     * <code>AUTO_REASON_SWAP_FEE = 5;</code>
     */
    public static final int AUTO_REASON_SWAP_FEE_VALUE = 5;
    /**
     * <pre>
     *
     *Miner fee indicates that the miner fee for a specific swap is to high.
     * </pre>
     *
     * <code>AUTO_REASON_MINER_FEE = 6;</code>
     */
    public static final int AUTO_REASON_MINER_FEE_VALUE = 6;
    /**
     * <pre>
     *
     *Prepay indicates that the prepay fee for a specific swap is too high.
     * </pre>
     *
     * <code>AUTO_REASON_PREPAY = 7;</code>
     */
    public static final int AUTO_REASON_PREPAY_VALUE = 7;
    /**
     * <pre>
     *
     *Failure backoff indicates that a swap has recently failed for this target,
     *and the backoff period has not yet passed.
     * </pre>
     *
     * <code>AUTO_REASON_FAILURE_BACKOFF = 8;</code>
     */
    public static final int AUTO_REASON_FAILURE_BACKOFF_VALUE = 8;
    /**
     * <pre>
     *
     *Loop out indicates that a loop out swap is currently utilizing the channel,
     *so it is not eligible.
     * </pre>
     *
     * <code>AUTO_REASON_LOOP_OUT = 9;</code>
     */
    public static final int AUTO_REASON_LOOP_OUT_VALUE = 9;
    /**
     * <pre>
     *
     *Loop In indicates that a loop in swap is currently in flight for the peer,
     *so it is not eligible.
     * </pre>
     *
     * <code>AUTO_REASON_LOOP_IN = 10;</code>
     */
    public static final int AUTO_REASON_LOOP_IN_VALUE = 10;
    /**
     * <pre>
     *
     *Liquidity ok indicates that a target meets the liquidity balance expressed
     *in its rule, so no swap is needed.
     * </pre>
     *
     * <code>AUTO_REASON_LIQUIDITY_OK = 11;</code>
     */
    public static final int AUTO_REASON_LIQUIDITY_OK_VALUE = 11;
    /**
     * <pre>
     *
     *Budget insufficient indicates that we cannot perform a swap because we do
     *not have enough pending budget available. This differs from budget elapsed,
     *because we still have some budget available, but we have allocated it to
     *other swaps.
     * </pre>
     *
     * <code>AUTO_REASON_BUDGET_INSUFFICIENT = 12;</code>
     */
    public static final int AUTO_REASON_BUDGET_INSUFFICIENT_VALUE = 12;
    /**
     * <pre>
     *
     *Fee insufficient indicates that the fee estimate for a swap is higher than
     *the portion of total swap amount that we allow fees to consume.
     * </pre>
     *
     * <code>AUTO_REASON_FEE_INSUFFICIENT = 13;</code>
     */
    public static final int AUTO_REASON_FEE_INSUFFICIENT_VALUE = 13;


    public final int getNumber() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalArgumentException(
            "Can't get the number of an unknown enum value.");
      }
      return value;
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     * @deprecated Use {@link #forNumber(int)} instead.
     */
    @java.lang.Deprecated
    public static AutoReason valueOf(int value) {
      return forNumber(value);
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     */
    public static AutoReason forNumber(int value) {
      switch (value) {
        case 0: return AUTO_REASON_UNKNOWN;
        case 1: return AUTO_REASON_BUDGET_NOT_STARTED;
        case 2: return AUTO_REASON_SWEEP_FEES;
        case 3: return AUTO_REASON_BUDGET_ELAPSED;
        case 4: return AUTO_REASON_IN_FLIGHT;
        case 5: return AUTO_REASON_SWAP_FEE;
        case 6: return AUTO_REASON_MINER_FEE;
        case 7: return AUTO_REASON_PREPAY;
        case 8: return AUTO_REASON_FAILURE_BACKOFF;
        case 9: return AUTO_REASON_LOOP_OUT;
        case 10: return AUTO_REASON_LOOP_IN;
        case 11: return AUTO_REASON_LIQUIDITY_OK;
        case 12: return AUTO_REASON_BUDGET_INSUFFICIENT;
        case 13: return AUTO_REASON_FEE_INSUFFICIENT;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<AutoReason>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static final com.google.protobuf.Internal.EnumLiteMap<
        AutoReason> internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<AutoReason>() {
            public AutoReason findValueByNumber(int number) {
              return AutoReason.forNumber(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalStateException(
            "Can't get the descriptor of an unrecognized enum value.");
      }
      return getDescriptor().getValues().get(ordinal());
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return looprpc.Loop.getDescriptor().getEnumTypes().get(5);
    }

    private static final AutoReason[] VALUES = values();

    public static AutoReason valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      if (desc.getIndex() == -1) {
        return UNRECOGNIZED;
      }
      return VALUES[desc.getIndex()];
    }

    private final int value;

    private AutoReason(int value) {
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:looprpc.AutoReason)
  }

  public interface LoopOutRequestOrBuilder extends
      // @@protoc_insertion_point(interface_extends:looprpc.LoopOutRequest)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     *
     *Requested swap amount in sat. This does not include the swap and miner fee.
     * </pre>
     *
     * <code>int64 amt = 1 [jstype = JS_STRING];</code>
     * @return The amt.
     */
    long getAmt();

    /**
     * <pre>
     *
     *Base58 encoded destination address for the swap.
     * </pre>
     *
     * <code>string dest = 2;</code>
     * @return The dest.
     */
    java.lang.String getDest();
    /**
     * <pre>
     *
     *Base58 encoded destination address for the swap.
     * </pre>
     *
     * <code>string dest = 2;</code>
     * @return The bytes for dest.
     */
    com.google.protobuf.ByteString
        getDestBytes();

    /**
     * <pre>
     *
     *Maximum off-chain fee in sat that may be paid for swap payment to the
     *server. This limit is applied during path finding. Typically this value is
     *taken from the response of the GetQuote call.
     * </pre>
     *
     * <code>int64 max_swap_routing_fee = 3 [jstype = JS_STRING];</code>
     * @return The maxSwapRoutingFee.
     */
    long getMaxSwapRoutingFee();

    /**
     * <pre>
     *
     *Maximum off-chain fee in sat that may be paid for the prepay to the server.
     *This limit is applied during path finding. Typically this value is taken
     *from the response of the GetQuote call.
     * </pre>
     *
     * <code>int64 max_prepay_routing_fee = 4 [jstype = JS_STRING];</code>
     * @return The maxPrepayRoutingFee.
     */
    long getMaxPrepayRoutingFee();

    /**
     * <pre>
     *
     *Maximum we are willing to pay the server for the swap. This value is not
     *disclosed in the swap initiation call, but if the server asks for a
     *higher fee, we abort the swap. Typically this value is taken from the
     *response of the GetQuote call. It includes the prepay amount.
     * </pre>
     *
     * <code>int64 max_swap_fee = 5 [jstype = JS_STRING];</code>
     * @return The maxSwapFee.
     */
    long getMaxSwapFee();

    /**
     * <pre>
     *
     *Maximum amount of the swap fee that may be charged as a prepayment.
     * </pre>
     *
     * <code>int64 max_prepay_amt = 6 [jstype = JS_STRING];</code>
     * @return The maxPrepayAmt.
     */
    long getMaxPrepayAmt();

    /**
     * <pre>
     *
     *Maximum in on-chain fees that we are willing to spend. If we want to
     *sweep the on-chain htlc and the fee estimate turns out higher than this
     *value, we cancel the swap. If the fee estimate is lower, we publish the
     *sweep tx.
     *
     *If the sweep tx is not confirmed, we are forced to ratchet up fees until it
     *is swept. Possibly even exceeding max_miner_fee if we get close to the htlc
     *timeout. Because the initial publication revealed the preimage, we have no
     *other choice. The server may already have pulled the off-chain htlc. Only
     *when the fee becomes higher than the swap amount, we can only wait for fees
     *to come down and hope - if we are past the timeout - that the server is not
     *publishing the revocation.
     *
     *max_miner_fee is typically taken from the response of the GetQuote call.
     * </pre>
     *
     * <code>int64 max_miner_fee = 7 [jstype = JS_STRING];</code>
     * @return The maxMinerFee.
     */
    long getMaxMinerFee();

    /**
     * <pre>
     *
     *Deprecated, use outgoing_chan_set. The channel to loop out, the channel
     *to loop out is selected based on the lowest routing fee for the swap
     *payment to the server.
     * </pre>
     *
     * <code>uint64 loop_out_channel = 8 [deprecated = true, jstype = JS_STRING];</code>
     * @deprecated looprpc.LoopOutRequest.loop_out_channel is deprecated.
     *     See loop.proto;l=174
     * @return The loopOutChannel.
     */
    @java.lang.Deprecated long getLoopOutChannel();

    /**
     * <pre>
     *
     *A restriction on the channel set that may be used to loop out. The actual
     *channel(s) that will be used are selected based on the lowest routing fee
     *for the swap payment to the server.
     * </pre>
     *
     * <code>repeated uint64 outgoing_chan_set = 11 [jstype = JS_STRING];</code>
     * @return A list containing the outgoingChanSet.
     */
    java.util.List<java.lang.Long> getOutgoingChanSetList();
    /**
     * <pre>
     *
     *A restriction on the channel set that may be used to loop out. The actual
     *channel(s) that will be used are selected based on the lowest routing fee
     *for the swap payment to the server.
     * </pre>
     *
     * <code>repeated uint64 outgoing_chan_set = 11 [jstype = JS_STRING];</code>
     * @return The count of outgoingChanSet.
     */
    int getOutgoingChanSetCount();
    /**
     * <pre>
     *
     *A restriction on the channel set that may be used to loop out. The actual
     *channel(s) that will be used are selected based on the lowest routing fee
     *for the swap payment to the server.
     * </pre>
     *
     * <code>repeated uint64 outgoing_chan_set = 11 [jstype = JS_STRING];</code>
     * @param index The index of the element to return.
     * @return The outgoingChanSet at the given index.
     */
    long getOutgoingChanSet(int index);

    /**
     * <pre>
     *
     *The number of blocks from the on-chain HTLC's confirmation height that it
     *should be swept within.
     * </pre>
     *
     * <code>int32 sweep_conf_target = 9;</code>
     * @return The sweepConfTarget.
     */
    int getSweepConfTarget();

    /**
     * <pre>
     *
     *The number of confirmations that we require for the on chain htlc that will
     *be published by the server before we reveal the preimage.
     * </pre>
     *
     * <code>int32 htlc_confirmations = 13;</code>
     * @return The htlcConfirmations.
     */
    int getHtlcConfirmations();

    /**
     * <pre>
     *
     *The latest time (in unix seconds) we allow the server to wait before
     *publishing the HTLC on chain. Setting this to a larger value will give the
     *server the opportunity to batch multiple swaps together, and wait for
     *low-fee periods before publishing the HTLC, potentially resulting in a
     *lower total swap fee.
     * </pre>
     *
     * <code>uint64 swap_publication_deadline = 10 [jstype = JS_STRING];</code>
     * @return The swapPublicationDeadline.
     */
    long getSwapPublicationDeadline();

    /**
     * <pre>
     *
     *An optional label for this swap. This field is limited to 500 characters
     *and may not start with the prefix [reserved], which is used to tag labels
     *produced by the daemon.
     * </pre>
     *
     * <code>string label = 12;</code>
     * @return The label.
     */
    java.lang.String getLabel();
    /**
     * <pre>
     *
     *An optional label for this swap. This field is limited to 500 characters
     *and may not start with the prefix [reserved], which is used to tag labels
     *produced by the daemon.
     * </pre>
     *
     * <code>string label = 12;</code>
     * @return The bytes for label.
     */
    com.google.protobuf.ByteString
        getLabelBytes();

    /**
     * <pre>
     *
     *An optional identification string that will be appended to the user agent
     *string sent to the server to give information about the usage of loop. This
     *initiator part is meant for user interfaces to add their name to give the
     *full picture of the binary used (loopd, LiT) and the method used for
     *triggering the swap (loop CLI, autolooper, LiT UI, other 3rd party UI).
     * </pre>
     *
     * <code>string initiator = 14;</code>
     * @return The initiator.
     */
    java.lang.String getInitiator();
    /**
     * <pre>
     *
     *An optional identification string that will be appended to the user agent
     *string sent to the server to give information about the usage of loop. This
     *initiator part is meant for user interfaces to add their name to give the
     *full picture of the binary used (loopd, LiT) and the method used for
     *triggering the swap (loop CLI, autolooper, LiT UI, other 3rd party UI).
     * </pre>
     *
     * <code>string initiator = 14;</code>
     * @return The bytes for initiator.
     */
    com.google.protobuf.ByteString
        getInitiatorBytes();

    /**
     * <pre>
     *
     *An alternative destination address source for the swap. This field
     *represents the name of the account in the backing lnd instance.
     *Refer to lnd's wallet import functions for reference.
     * </pre>
     *
     * <code>string account = 15;</code>
     * @return The account.
     */
    java.lang.String getAccount();
    /**
     * <pre>
     *
     *An alternative destination address source for the swap. This field
     *represents the name of the account in the backing lnd instance.
     *Refer to lnd's wallet import functions for reference.
     * </pre>
     *
     * <code>string account = 15;</code>
     * @return The bytes for account.
     */
    com.google.protobuf.ByteString
        getAccountBytes();

    /**
     * <pre>
     *
     *The address type of the account specified in the account field.
     * </pre>
     *
     * <code>.looprpc.AddressType account_addr_type = 16;</code>
     * @return The enum numeric value on the wire for accountAddrType.
     */
    int getAccountAddrTypeValue();
    /**
     * <pre>
     *
     *The address type of the account specified in the account field.
     * </pre>
     *
     * <code>.looprpc.AddressType account_addr_type = 16;</code>
     * @return The accountAddrType.
     */
    looprpc.Loop.AddressType getAccountAddrType();
  }
  /**
   * Protobuf type {@code looprpc.LoopOutRequest}
   */
  public static final class LoopOutRequest extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:looprpc.LoopOutRequest)
      LoopOutRequestOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use LoopOutRequest.newBuilder() to construct.
    private LoopOutRequest(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private LoopOutRequest() {
      dest_ = "";
      outgoingChanSet_ = emptyLongList();
      label_ = "";
      initiator_ = "";
      account_ = "";
      accountAddrType_ = 0;
    }

    @java.lang.Override
    @SuppressWarnings({"unused"})
    protected java.lang.Object newInstance(
        UnusedPrivateParameter unused) {
      return new LoopOutRequest();
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return looprpc.Loop.internal_static_looprpc_LoopOutRequest_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return looprpc.Loop.internal_static_looprpc_LoopOutRequest_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              looprpc.Loop.LoopOutRequest.class, looprpc.Loop.LoopOutRequest.Builder.class);
    }

    public static final int AMT_FIELD_NUMBER = 1;
    private long amt_ = 0L;
    /**
     * <pre>
     *
     *Requested swap amount in sat. This does not include the swap and miner fee.
     * </pre>
     *
     * <code>int64 amt = 1 [jstype = JS_STRING];</code>
     * @return The amt.
     */
    @java.lang.Override
    public long getAmt() {
      return amt_;
    }

    public static final int DEST_FIELD_NUMBER = 2;
    @SuppressWarnings("serial")
    private volatile java.lang.Object dest_ = "";
    /**
     * <pre>
     *
     *Base58 encoded destination address for the swap.
     * </pre>
     *
     * <code>string dest = 2;</code>
     * @return The dest.
     */
    @java.lang.Override
    public java.lang.String getDest() {
      java.lang.Object ref = dest_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        dest_ = s;
        return s;
      }
    }
    /**
     * <pre>
     *
     *Base58 encoded destination address for the swap.
     * </pre>
     *
     * <code>string dest = 2;</code>
     * @return The bytes for dest.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getDestBytes() {
      java.lang.Object ref = dest_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        dest_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int MAX_SWAP_ROUTING_FEE_FIELD_NUMBER = 3;
    private long maxSwapRoutingFee_ = 0L;
    /**
     * <pre>
     *
     *Maximum off-chain fee in sat that may be paid for swap payment to the
     *server. This limit is applied during path finding. Typically this value is
     *taken from the response of the GetQuote call.
     * </pre>
     *
     * <code>int64 max_swap_routing_fee = 3 [jstype = JS_STRING];</code>
     * @return The maxSwapRoutingFee.
     */
    @java.lang.Override
    public long getMaxSwapRoutingFee() {
      return maxSwapRoutingFee_;
    }

    public static final int MAX_PREPAY_ROUTING_FEE_FIELD_NUMBER = 4;
    private long maxPrepayRoutingFee_ = 0L;
    /**
     * <pre>
     *
     *Maximum off-chain fee in sat that may be paid for the prepay to the server.
     *This limit is applied during path finding. Typically this value is taken
     *from the response of the GetQuote call.
     * </pre>
     *
     * <code>int64 max_prepay_routing_fee = 4 [jstype = JS_STRING];</code>
     * @return The maxPrepayRoutingFee.
     */
    @java.lang.Override
    public long getMaxPrepayRoutingFee() {
      return maxPrepayRoutingFee_;
    }

    public static final int MAX_SWAP_FEE_FIELD_NUMBER = 5;
    private long maxSwapFee_ = 0L;
    /**
     * <pre>
     *
     *Maximum we are willing to pay the server for the swap. This value is not
     *disclosed in the swap initiation call, but if the server asks for a
     *higher fee, we abort the swap. Typically this value is taken from the
     *response of the GetQuote call. It includes the prepay amount.
     * </pre>
     *
     * <code>int64 max_swap_fee = 5 [jstype = JS_STRING];</code>
     * @return The maxSwapFee.
     */
    @java.lang.Override
    public long getMaxSwapFee() {
      return maxSwapFee_;
    }

    public static final int MAX_PREPAY_AMT_FIELD_NUMBER = 6;
    private long maxPrepayAmt_ = 0L;
    /**
     * <pre>
     *
     *Maximum amount of the swap fee that may be charged as a prepayment.
     * </pre>
     *
     * <code>int64 max_prepay_amt = 6 [jstype = JS_STRING];</code>
     * @return The maxPrepayAmt.
     */
    @java.lang.Override
    public long getMaxPrepayAmt() {
      return maxPrepayAmt_;
    }

    public static final int MAX_MINER_FEE_FIELD_NUMBER = 7;
    private long maxMinerFee_ = 0L;
    /**
     * <pre>
     *
     *Maximum in on-chain fees that we are willing to spend. If we want to
     *sweep the on-chain htlc and the fee estimate turns out higher than this
     *value, we cancel the swap. If the fee estimate is lower, we publish the
     *sweep tx.
     *
     *If the sweep tx is not confirmed, we are forced to ratchet up fees until it
     *is swept. Possibly even exceeding max_miner_fee if we get close to the htlc
     *timeout. Because the initial publication revealed the preimage, we have no
     *other choice. The server may already have pulled the off-chain htlc. Only
     *when the fee becomes higher than the swap amount, we can only wait for fees
     *to come down and hope - if we are past the timeout - that the server is not
     *publishing the revocation.
     *
     *max_miner_fee is typically taken from the response of the GetQuote call.
     * </pre>
     *
     * <code>int64 max_miner_fee = 7 [jstype = JS_STRING];</code>
     * @return The maxMinerFee.
     */
    @java.lang.Override
    public long getMaxMinerFee() {
      return maxMinerFee_;
    }

    public static final int LOOP_OUT_CHANNEL_FIELD_NUMBER = 8;
    private long loopOutChannel_ = 0L;
    /**
     * <pre>
     *
     *Deprecated, use outgoing_chan_set. The channel to loop out, the channel
     *to loop out is selected based on the lowest routing fee for the swap
     *payment to the server.
     * </pre>
     *
     * <code>uint64 loop_out_channel = 8 [deprecated = true, jstype = JS_STRING];</code>
     * @deprecated looprpc.LoopOutRequest.loop_out_channel is deprecated.
     *     See loop.proto;l=174
     * @return The loopOutChannel.
     */
    @java.lang.Override
    @java.lang.Deprecated public long getLoopOutChannel() {
      return loopOutChannel_;
    }

    public static final int OUTGOING_CHAN_SET_FIELD_NUMBER = 11;
    @SuppressWarnings("serial")
    private com.google.protobuf.Internal.LongList outgoingChanSet_ =
        emptyLongList();
    /**
     * <pre>
     *
     *A restriction on the channel set that may be used to loop out. The actual
     *channel(s) that will be used are selected based on the lowest routing fee
     *for the swap payment to the server.
     * </pre>
     *
     * <code>repeated uint64 outgoing_chan_set = 11 [jstype = JS_STRING];</code>
     * @return A list containing the outgoingChanSet.
     */
    @java.lang.Override
    public java.util.List<java.lang.Long>
        getOutgoingChanSetList() {
      return outgoingChanSet_;
    }
    /**
     * <pre>
     *
     *A restriction on the channel set that may be used to loop out. The actual
     *channel(s) that will be used are selected based on the lowest routing fee
     *for the swap payment to the server.
     * </pre>
     *
     * <code>repeated uint64 outgoing_chan_set = 11 [jstype = JS_STRING];</code>
     * @return The count of outgoingChanSet.
     */
    public int getOutgoingChanSetCount() {
      return outgoingChanSet_.size();
    }
    /**
     * <pre>
     *
     *A restriction on the channel set that may be used to loop out. The actual
     *channel(s) that will be used are selected based on the lowest routing fee
     *for the swap payment to the server.
     * </pre>
     *
     * <code>repeated uint64 outgoing_chan_set = 11 [jstype = JS_STRING];</code>
     * @param index The index of the element to return.
     * @return The outgoingChanSet at the given index.
     */
    public long getOutgoingChanSet(int index) {
      return outgoingChanSet_.getLong(index);
    }
    private int outgoingChanSetMemoizedSerializedSize = -1;

    public static final int SWEEP_CONF_TARGET_FIELD_NUMBER = 9;
    private int sweepConfTarget_ = 0;
    /**
     * <pre>
     *
     *The number of blocks from the on-chain HTLC's confirmation height that it
     *should be swept within.
     * </pre>
     *
     * <code>int32 sweep_conf_target = 9;</code>
     * @return The sweepConfTarget.
     */
    @java.lang.Override
    public int getSweepConfTarget() {
      return sweepConfTarget_;
    }

    public static final int HTLC_CONFIRMATIONS_FIELD_NUMBER = 13;
    private int htlcConfirmations_ = 0;
    /**
     * <pre>
     *
     *The number of confirmations that we require for the on chain htlc that will
     *be published by the server before we reveal the preimage.
     * </pre>
     *
     * <code>int32 htlc_confirmations = 13;</code>
     * @return The htlcConfirmations.
     */
    @java.lang.Override
    public int getHtlcConfirmations() {
      return htlcConfirmations_;
    }

    public static final int SWAP_PUBLICATION_DEADLINE_FIELD_NUMBER = 10;
    private long swapPublicationDeadline_ = 0L;
    /**
     * <pre>
     *
     *The latest time (in unix seconds) we allow the server to wait before
     *publishing the HTLC on chain. Setting this to a larger value will give the
     *server the opportunity to batch multiple swaps together, and wait for
     *low-fee periods before publishing the HTLC, potentially resulting in a
     *lower total swap fee.
     * </pre>
     *
     * <code>uint64 swap_publication_deadline = 10 [jstype = JS_STRING];</code>
     * @return The swapPublicationDeadline.
     */
    @java.lang.Override
    public long getSwapPublicationDeadline() {
      return swapPublicationDeadline_;
    }

    public static final int LABEL_FIELD_NUMBER = 12;
    @SuppressWarnings("serial")
    private volatile java.lang.Object label_ = "";
    /**
     * <pre>
     *
     *An optional label for this swap. This field is limited to 500 characters
     *and may not start with the prefix [reserved], which is used to tag labels
     *produced by the daemon.
     * </pre>
     *
     * <code>string label = 12;</code>
     * @return The label.
     */
    @java.lang.Override
    public java.lang.String getLabel() {
      java.lang.Object ref = label_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        label_ = s;
        return s;
      }
    }
    /**
     * <pre>
     *
     *An optional label for this swap. This field is limited to 500 characters
     *and may not start with the prefix [reserved], which is used to tag labels
     *produced by the daemon.
     * </pre>
     *
     * <code>string label = 12;</code>
     * @return The bytes for label.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getLabelBytes() {
      java.lang.Object ref = label_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        label_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int INITIATOR_FIELD_NUMBER = 14;
    @SuppressWarnings("serial")
    private volatile java.lang.Object initiator_ = "";
    /**
     * <pre>
     *
     *An optional identification string that will be appended to the user agent
     *string sent to the server to give information about the usage of loop. This
     *initiator part is meant for user interfaces to add their name to give the
     *full picture of the binary used (loopd, LiT) and the method used for
     *triggering the swap (loop CLI, autolooper, LiT UI, other 3rd party UI).
     * </pre>
     *
     * <code>string initiator = 14;</code>
     * @return The initiator.
     */
    @java.lang.Override
    public java.lang.String getInitiator() {
      java.lang.Object ref = initiator_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        initiator_ = s;
        return s;
      }
    }
    /**
     * <pre>
     *
     *An optional identification string that will be appended to the user agent
     *string sent to the server to give information about the usage of loop. This
     *initiator part is meant for user interfaces to add their name to give the
     *full picture of the binary used (loopd, LiT) and the method used for
     *triggering the swap (loop CLI, autolooper, LiT UI, other 3rd party UI).
     * </pre>
     *
     * <code>string initiator = 14;</code>
     * @return The bytes for initiator.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getInitiatorBytes() {
      java.lang.Object ref = initiator_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        initiator_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int ACCOUNT_FIELD_NUMBER = 15;
    @SuppressWarnings("serial")
    private volatile java.lang.Object account_ = "";
    /**
     * <pre>
     *
     *An alternative destination address source for the swap. This field
     *represents the name of the account in the backing lnd instance.
     *Refer to lnd's wallet import functions for reference.
     * </pre>
     *
     * <code>string account = 15;</code>
     * @return The account.
     */
    @java.lang.Override
    public java.lang.String getAccount() {
      java.lang.Object ref = account_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        account_ = s;
        return s;
      }
    }
    /**
     * <pre>
     *
     *An alternative destination address source for the swap. This field
     *represents the name of the account in the backing lnd instance.
     *Refer to lnd's wallet import functions for reference.
     * </pre>
     *
     * <code>string account = 15;</code>
     * @return The bytes for account.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getAccountBytes() {
      java.lang.Object ref = account_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        account_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int ACCOUNT_ADDR_TYPE_FIELD_NUMBER = 16;
    private int accountAddrType_ = 0;
    /**
     * <pre>
     *
     *The address type of the account specified in the account field.
     * </pre>
     *
     * <code>.looprpc.AddressType account_addr_type = 16;</code>
     * @return The enum numeric value on the wire for accountAddrType.
     */
    @java.lang.Override public int getAccountAddrTypeValue() {
      return accountAddrType_;
    }
    /**
     * <pre>
     *
     *The address type of the account specified in the account field.
     * </pre>
     *
     * <code>.looprpc.AddressType account_addr_type = 16;</code>
     * @return The accountAddrType.
     */
    @java.lang.Override public looprpc.Loop.AddressType getAccountAddrType() {
      looprpc.Loop.AddressType result = looprpc.Loop.AddressType.forNumber(accountAddrType_);
      return result == null ? looprpc.Loop.AddressType.UNRECOGNIZED : result;
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      getSerializedSize();
      if (amt_ != 0L) {
        output.writeInt64(1, amt_);
      }
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(dest_)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 2, dest_);
      }
      if (maxSwapRoutingFee_ != 0L) {
        output.writeInt64(3, maxSwapRoutingFee_);
      }
      if (maxPrepayRoutingFee_ != 0L) {
        output.writeInt64(4, maxPrepayRoutingFee_);
      }
      if (maxSwapFee_ != 0L) {
        output.writeInt64(5, maxSwapFee_);
      }
      if (maxPrepayAmt_ != 0L) {
        output.writeInt64(6, maxPrepayAmt_);
      }
      if (maxMinerFee_ != 0L) {
        output.writeInt64(7, maxMinerFee_);
      }
      if (loopOutChannel_ != 0L) {
        output.writeUInt64(8, loopOutChannel_);
      }
      if (sweepConfTarget_ != 0) {
        output.writeInt32(9, sweepConfTarget_);
      }
      if (swapPublicationDeadline_ != 0L) {
        output.writeUInt64(10, swapPublicationDeadline_);
      }
      if (getOutgoingChanSetList().size() > 0) {
        output.writeUInt32NoTag(90);
        output.writeUInt32NoTag(outgoingChanSetMemoizedSerializedSize);
      }
      for (int i = 0; i < outgoingChanSet_.size(); i++) {
        output.writeUInt64NoTag(outgoingChanSet_.getLong(i));
      }
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(label_)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 12, label_);
      }
      if (htlcConfirmations_ != 0) {
        output.writeInt32(13, htlcConfirmations_);
      }
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(initiator_)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 14, initiator_);
      }
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(account_)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 15, account_);
      }
      if (accountAddrType_ != looprpc.Loop.AddressType.ADDRESS_TYPE_UNKNOWN.getNumber()) {
        output.writeEnum(16, accountAddrType_);
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (amt_ != 0L) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt64Size(1, amt_);
      }
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(dest_)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(2, dest_);
      }
      if (maxSwapRoutingFee_ != 0L) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt64Size(3, maxSwapRoutingFee_);
      }
      if (maxPrepayRoutingFee_ != 0L) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt64Size(4, maxPrepayRoutingFee_);
      }
      if (maxSwapFee_ != 0L) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt64Size(5, maxSwapFee_);
      }
      if (maxPrepayAmt_ != 0L) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt64Size(6, maxPrepayAmt_);
      }
      if (maxMinerFee_ != 0L) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt64Size(7, maxMinerFee_);
      }
      if (loopOutChannel_ != 0L) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt64Size(8, loopOutChannel_);
      }
      if (sweepConfTarget_ != 0) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt32Size(9, sweepConfTarget_);
      }
      if (swapPublicationDeadline_ != 0L) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt64Size(10, swapPublicationDeadline_);
      }
      {
        int dataSize = 0;
        for (int i = 0; i < outgoingChanSet_.size(); i++) {
          dataSize += com.google.protobuf.CodedOutputStream
            .computeUInt64SizeNoTag(outgoingChanSet_.getLong(i));
        }
        size += dataSize;
        if (!getOutgoingChanSetList().isEmpty()) {
          size += 1;
          size += com.google.protobuf.CodedOutputStream
              .computeInt32SizeNoTag(dataSize);
        }
        outgoingChanSetMemoizedSerializedSize = dataSize;
      }
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(label_)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(12, label_);
      }
      if (htlcConfirmations_ != 0) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt32Size(13, htlcConfirmations_);
      }
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(initiator_)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(14, initiator_);
      }
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(account_)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(15, account_);
      }
      if (accountAddrType_ != looprpc.Loop.AddressType.ADDRESS_TYPE_UNKNOWN.getNumber()) {
        size += com.google.protobuf.CodedOutputStream
          .computeEnumSize(16, accountAddrType_);
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof looprpc.Loop.LoopOutRequest)) {
        return super.equals(obj);
      }
      looprpc.Loop.LoopOutRequest other = (looprpc.Loop.LoopOutRequest) obj;

      if (getAmt()
          != other.getAmt()) return false;
      if (!getDest()
          .equals(other.getDest())) return false;
      if (getMaxSwapRoutingFee()
          != other.getMaxSwapRoutingFee()) return false;
      if (getMaxPrepayRoutingFee()
          != other.getMaxPrepayRoutingFee()) return false;
      if (getMaxSwapFee()
          != other.getMaxSwapFee()) return false;
      if (getMaxPrepayAmt()
          != other.getMaxPrepayAmt()) return false;
      if (getMaxMinerFee()
          != other.getMaxMinerFee()) return false;
      if (getLoopOutChannel()
          != other.getLoopOutChannel()) return false;
      if (!getOutgoingChanSetList()
          .equals(other.getOutgoingChanSetList())) return false;
      if (getSweepConfTarget()
          != other.getSweepConfTarget()) return false;
      if (getHtlcConfirmations()
          != other.getHtlcConfirmations()) return false;
      if (getSwapPublicationDeadline()
          != other.getSwapPublicationDeadline()) return false;
      if (!getLabel()
          .equals(other.getLabel())) return false;
      if (!getInitiator()
          .equals(other.getInitiator())) return false;
      if (!getAccount()
          .equals(other.getAccount())) return false;
      if (accountAddrType_ != other.accountAddrType_) return false;
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      hash = (37 * hash) + AMT_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
          getAmt());
      hash = (37 * hash) + DEST_FIELD_NUMBER;
      hash = (53 * hash) + getDest().hashCode();
      hash = (37 * hash) + MAX_SWAP_ROUTING_FEE_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
          getMaxSwapRoutingFee());
      hash = (37 * hash) + MAX_PREPAY_ROUTING_FEE_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
          getMaxPrepayRoutingFee());
      hash = (37 * hash) + MAX_SWAP_FEE_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
          getMaxSwapFee());
      hash = (37 * hash) + MAX_PREPAY_AMT_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
          getMaxPrepayAmt());
      hash = (37 * hash) + MAX_MINER_FEE_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
          getMaxMinerFee());
      hash = (37 * hash) + LOOP_OUT_CHANNEL_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
          getLoopOutChannel());
      if (getOutgoingChanSetCount() > 0) {
        hash = (37 * hash) + OUTGOING_CHAN_SET_FIELD_NUMBER;
        hash = (53 * hash) + getOutgoingChanSetList().hashCode();
      }
      hash = (37 * hash) + SWEEP_CONF_TARGET_FIELD_NUMBER;
      hash = (53 * hash) + getSweepConfTarget();
      hash = (37 * hash) + HTLC_CONFIRMATIONS_FIELD_NUMBER;
      hash = (53 * hash) + getHtlcConfirmations();
      hash = (37 * hash) + SWAP_PUBLICATION_DEADLINE_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
          getSwapPublicationDeadline());
      hash = (37 * hash) + LABEL_FIELD_NUMBER;
      hash = (53 * hash) + getLabel().hashCode();
      hash = (37 * hash) + INITIATOR_FIELD_NUMBER;
      hash = (53 * hash) + getInitiator().hashCode();
      hash = (37 * hash) + ACCOUNT_FIELD_NUMBER;
      hash = (53 * hash) + getAccount().hashCode();
      hash = (37 * hash) + ACCOUNT_ADDR_TYPE_FIELD_NUMBER;
      hash = (53 * hash) + accountAddrType_;
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static looprpc.Loop.LoopOutRequest parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static looprpc.Loop.LoopOutRequest parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static looprpc.Loop.LoopOutRequest parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static looprpc.Loop.LoopOutRequest parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static looprpc.Loop.LoopOutRequest parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static looprpc.Loop.LoopOutRequest parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static looprpc.Loop.LoopOutRequest parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static looprpc.Loop.LoopOutRequest parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static looprpc.Loop.LoopOutRequest parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static looprpc.Loop.LoopOutRequest parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static looprpc.Loop.LoopOutRequest parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static looprpc.Loop.LoopOutRequest parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(looprpc.Loop.LoopOutRequest prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * Protobuf type {@code looprpc.LoopOutRequest}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:looprpc.LoopOutRequest)
        looprpc.Loop.LoopOutRequestOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return looprpc.Loop.internal_static_looprpc_LoopOutRequest_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return looprpc.Loop.internal_static_looprpc_LoopOutRequest_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                looprpc.Loop.LoopOutRequest.class, looprpc.Loop.LoopOutRequest.Builder.class);
      }

      // Construct using looprpc.Loop.LoopOutRequest.newBuilder()
      private Builder() {

      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);

      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        amt_ = 0L;
        dest_ = "";
        maxSwapRoutingFee_ = 0L;
        maxPrepayRoutingFee_ = 0L;
        maxSwapFee_ = 0L;
        maxPrepayAmt_ = 0L;
        maxMinerFee_ = 0L;
        loopOutChannel_ = 0L;
        outgoingChanSet_ = emptyLongList();
        sweepConfTarget_ = 0;
        htlcConfirmations_ = 0;
        swapPublicationDeadline_ = 0L;
        label_ = "";
        initiator_ = "";
        account_ = "";
        accountAddrType_ = 0;
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return looprpc.Loop.internal_static_looprpc_LoopOutRequest_descriptor;
      }

      @java.lang.Override
      public looprpc.Loop.LoopOutRequest getDefaultInstanceForType() {
        return looprpc.Loop.LoopOutRequest.getDefaultInstance();
      }

      @java.lang.Override
      public looprpc.Loop.LoopOutRequest build() {
        looprpc.Loop.LoopOutRequest result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public looprpc.Loop.LoopOutRequest buildPartial() {
        looprpc.Loop.LoopOutRequest result = new looprpc.Loop.LoopOutRequest(this);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartial0(looprpc.Loop.LoopOutRequest result) {
        int from_bitField0_ = bitField0_;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.amt_ = amt_;
        }
        if (((from_bitField0_ & 0x00000002) != 0)) {
          result.dest_ = dest_;
        }
        if (((from_bitField0_ & 0x00000004) != 0)) {
          result.maxSwapRoutingFee_ = maxSwapRoutingFee_;
        }
        if (((from_bitField0_ & 0x00000008) != 0)) {
          result.maxPrepayRoutingFee_ = maxPrepayRoutingFee_;
        }
        if (((from_bitField0_ & 0x00000010) != 0)) {
          result.maxSwapFee_ = maxSwapFee_;
        }
        if (((from_bitField0_ & 0x00000020) != 0)) {
          result.maxPrepayAmt_ = maxPrepayAmt_;
        }
        if (((from_bitField0_ & 0x00000040) != 0)) {
          result.maxMinerFee_ = maxMinerFee_;
        }
        if (((from_bitField0_ & 0x00000080) != 0)) {
          result.loopOutChannel_ = loopOutChannel_;
        }
        if (((from_bitField0_ & 0x00000100) != 0)) {
          outgoingChanSet_.makeImmutable();
          result.outgoingChanSet_ = outgoingChanSet_;
        }
        if (((from_bitField0_ & 0x00000200) != 0)) {
          result.sweepConfTarget_ = sweepConfTarget_;
        }
        if (((from_bitField0_ & 0x00000400) != 0)) {
          result.htlcConfirmations_ = htlcConfirmations_;
        }
        if (((from_bitField0_ & 0x00000800) != 0)) {
          result.swapPublicationDeadline_ = swapPublicationDeadline_;
        }
        if (((from_bitField0_ & 0x00001000) != 0)) {
          result.label_ = label_;
        }
        if (((from_bitField0_ & 0x00002000) != 0)) {
          result.initiator_ = initiator_;
        }
        if (((from_bitField0_ & 0x00004000) != 0)) {
          result.account_ = account_;
        }
        if (((from_bitField0_ & 0x00008000) != 0)) {
          result.accountAddrType_ = accountAddrType_;
        }
      }

      @java.lang.Override
      public Builder clone() {
        return super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof looprpc.Loop.LoopOutRequest) {
          return mergeFrom((looprpc.Loop.LoopOutRequest)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(looprpc.Loop.LoopOutRequest other) {
        if (other == looprpc.Loop.LoopOutRequest.getDefaultInstance()) return this;
        if (other.getAmt() != 0L) {
          setAmt(other.getAmt());
        }
        if (!other.getDest().isEmpty()) {
          dest_ = other.dest_;
          bitField0_ |= 0x00000002;
          onChanged();
        }
        if (other.getMaxSwapRoutingFee() != 0L) {
          setMaxSwapRoutingFee(other.getMaxSwapRoutingFee());
        }
        if (other.getMaxPrepayRoutingFee() != 0L) {
          setMaxPrepayRoutingFee(other.getMaxPrepayRoutingFee());
        }
        if (other.getMaxSwapFee() != 0L) {
          setMaxSwapFee(other.getMaxSwapFee());
        }
        if (other.getMaxPrepayAmt() != 0L) {
          setMaxPrepayAmt(other.getMaxPrepayAmt());
        }
        if (other.getMaxMinerFee() != 0L) {
          setMaxMinerFee(other.getMaxMinerFee());
        }
        if (other.getLoopOutChannel() != 0L) {
          setLoopOutChannel(other.getLoopOutChannel());
        }
        if (!other.outgoingChanSet_.isEmpty()) {
          if (outgoingChanSet_.isEmpty()) {
            outgoingChanSet_ = other.outgoingChanSet_;
            outgoingChanSet_.makeImmutable();
            bitField0_ |= 0x00000100;
          } else {
            ensureOutgoingChanSetIsMutable();
            outgoingChanSet_.addAll(other.outgoingChanSet_);
          }
          onChanged();
        }
        if (other.getSweepConfTarget() != 0) {
          setSweepConfTarget(other.getSweepConfTarget());
        }
        if (other.getHtlcConfirmations() != 0) {
          setHtlcConfirmations(other.getHtlcConfirmations());
        }
        if (other.getSwapPublicationDeadline() != 0L) {
          setSwapPublicationDeadline(other.getSwapPublicationDeadline());
        }
        if (!other.getLabel().isEmpty()) {
          label_ = other.label_;
          bitField0_ |= 0x00001000;
          onChanged();
        }
        if (!other.getInitiator().isEmpty()) {
          initiator_ = other.initiator_;
          bitField0_ |= 0x00002000;
          onChanged();
        }
        if (!other.getAccount().isEmpty()) {
          account_ = other.account_;
          bitField0_ |= 0x00004000;
          onChanged();
        }
        if (other.accountAddrType_ != 0) {
          setAccountAddrTypeValue(other.getAccountAddrTypeValue());
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 8: {
                amt_ = input.readInt64();
                bitField0_ |= 0x00000001;
                break;
              } // case 8
              case 18: {
                dest_ = input.readStringRequireUtf8();
                bitField0_ |= 0x00000002;
                break;
              } // case 18
              case 24: {
                maxSwapRoutingFee_ = input.readInt64();
                bitField0_ |= 0x00000004;
                break;
              } // case 24
              case 32: {
                maxPrepayRoutingFee_ = input.readInt64();
                bitField0_ |= 0x00000008;
                break;
              } // case 32
              case 40: {
                maxSwapFee_ = input.readInt64();
                bitField0_ |= 0x00000010;
                break;
              } // case 40
              case 48: {
                maxPrepayAmt_ = input.readInt64();
                bitField0_ |= 0x00000020;
                break;
              } // case 48
              case 56: {
                maxMinerFee_ = input.readInt64();
                bitField0_ |= 0x00000040;
                break;
              } // case 56
              case 64: {
                loopOutChannel_ = input.readUInt64();
                bitField0_ |= 0x00000080;
                break;
              } // case 64
              case 72: {
                sweepConfTarget_ = input.readInt32();
                bitField0_ |= 0x00000200;
                break;
              } // case 72
              case 80: {
                swapPublicationDeadline_ = input.readUInt64();
                bitField0_ |= 0x00000800;
                break;
              } // case 80
              case 88: {
                long v = input.readUInt64();
                ensureOutgoingChanSetIsMutable();
                outgoingChanSet_.addLong(v);
                break;
              } // case 88
              case 90: {
                int length = input.readRawVarint32();
                int limit = input.pushLimit(length);
                ensureOutgoingChanSetIsMutable();
                while (input.getBytesUntilLimit() > 0) {
                  outgoingChanSet_.addLong(input.readUInt64());
                }
                input.popLimit(limit);
                break;
              } // case 90
              case 98: {
                label_ = input.readStringRequireUtf8();
                bitField0_ |= 0x00001000;
                break;
              } // case 98
              case 104: {
                htlcConfirmations_ = input.readInt32();
                bitField0_ |= 0x00000400;
                break;
              } // case 104
              case 114: {
                initiator_ = input.readStringRequireUtf8();
                bitField0_ |= 0x00002000;
                break;
              } // case 114
              case 122: {
                account_ = input.readStringRequireUtf8();
                bitField0_ |= 0x00004000;
                break;
              } // case 122
              case 128: {
                accountAddrType_ = input.readEnum();
                bitField0_ |= 0x00008000;
                break;
              } // case 128
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private long amt_ ;
      /**
       * <pre>
       *
       *Requested swap amount in sat. This does not include the swap and miner fee.
       * </pre>
       *
       * <code>int64 amt = 1 [jstype = JS_STRING];</code>
       * @return The amt.
       */
      @java.lang.Override
      public long getAmt() {
        return amt_;
      }
      /**
       * <pre>
       *
       *Requested swap amount in sat. This does not include the swap and miner fee.
       * </pre>
       *
       * <code>int64 amt = 1 [jstype = JS_STRING];</code>
       * @param value The amt to set.
       * @return This builder for chaining.
       */
      public Builder setAmt(long value) {

        amt_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       *
       *Requested swap amount in sat. This does not include the swap and miner fee.
       * </pre>
       *
       * <code>int64 amt = 1 [jstype = JS_STRING];</code>
       * @return This builder for chaining.
       */
      public Builder clearAmt() {
        bitField0_ = (bitField0_ & ~0x00000001);
        amt_ = 0L;
        onChanged();
        return this;
      }

      private java.lang.Object dest_ = "";
      /**
       * <pre>
       *
       *Base58 encoded destination address for the swap.
       * </pre>
       *
       * <code>string dest = 2;</code>
       * @return The dest.
       */
      public java.lang.String getDest() {
        java.lang.Object ref = dest_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          dest_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       *
       *Base58 encoded destination address for the swap.
       * </pre>
       *
       * <code>string dest = 2;</code>
       * @return The bytes for dest.
       */
      public com.google.protobuf.ByteString
          getDestBytes() {
        java.lang.Object ref = dest_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          dest_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       *
       *Base58 encoded destination address for the swap.
       * </pre>
       *
       * <code>string dest = 2;</code>
       * @param value The dest to set.
       * @return This builder for chaining.
       */
      public Builder setDest(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        dest_ = value;
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       *
       *Base58 encoded destination address for the swap.
       * </pre>
       *
       * <code>string dest = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearDest() {
        dest_ = getDefaultInstance().getDest();
        bitField0_ = (bitField0_ & ~0x00000002);
        onChanged();
        return this;
      }
      /**
       * <pre>
       *
       *Base58 encoded destination address for the swap.
       * </pre>
       *
       * <code>string dest = 2;</code>
       * @param value The bytes for dest to set.
       * @return This builder for chaining.
       */
      public Builder setDestBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        checkByteStringIsUtf8(value);
        dest_ = value;
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }

      private long maxSwapRoutingFee_ ;
      /**
       * <pre>
       *
       *Maximum off-chain fee in sat that may be paid for swap payment to the
       *server. This limit is applied during path finding. Typically this value is
       *taken from the response of the GetQuote call.
       * </pre>
       *
       * <code>int64 max_swap_routing_fee = 3 [jstype = JS_STRING];</code>
       * @return The maxSwapRoutingFee.
       */
      @java.lang.Override
      public long getMaxSwapRoutingFee() {
        return maxSwapRoutingFee_;
      }
      /**
       * <pre>
       *
       *Maximum off-chain fee in sat that may be paid for swap payment to the
       *server. This limit is applied during path finding. Typically this value is
       *taken from the response of the GetQuote call.
       * </pre>
       *
       * <code>int64 max_swap_routing_fee = 3 [jstype = JS_STRING];</code>
       * @param value The maxSwapRoutingFee to set.
       * @return This builder for chaining.
       */
      public Builder setMaxSwapRoutingFee(long value) {

        maxSwapRoutingFee_ = value;
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }
      /**
       * <pre>
       *
       *Maximum off-chain fee in sat that may be paid for swap payment to the
       *server. This limit is applied during path finding. Typically this value is
       *taken from the response of the GetQuote call.
       * </pre>
       *
       * <code>int64 max_swap_routing_fee = 3 [jstype = JS_STRING];</code>
       * @return This builder for chaining.
       */
      public Builder clearMaxSwapRoutingFee() {
        bitField0_ = (bitField0_ & ~0x00000004);
        maxSwapRoutingFee_ = 0L;
        onChanged();
        return this;
      }

      private long maxPrepayRoutingFee_ ;
      /**
       * <pre>
       *
       *Maximum off-chain fee in sat that may be paid for the prepay to the server.
       *This limit is applied during path finding. Typically this value is taken
       *from the response of the GetQuote call.
       * </pre>
       *
       * <code>int64 max_prepay_routing_fee = 4 [jstype = JS_STRING];</code>
       * @return The maxPrepayRoutingFee.
       */
      @java.lang.Override
      public long getMaxPrepayRoutingFee() {
        return maxPrepayRoutingFee_;
      }
      /**
       * <pre>
       *
       *Maximum off-chain fee in sat that may be paid for the prepay to the server.
       *This limit is applied during path finding. Typically this value is taken
       *from the response of the GetQuote call.
       * </pre>
       *
       * <code>int64 max_prepay_routing_fee = 4 [jstype = JS_STRING];</code>
       * @param value The maxPrepayRoutingFee to set.
       * @return This builder for chaining.
       */
      public Builder setMaxPrepayRoutingFee(long value) {

        maxPrepayRoutingFee_ = value;
        bitField0_ |= 0x00000008;
        onChanged();
        return this;
      }
      /**
       * <pre>
       *
       *Maximum off-chain fee in sat that may be paid for the prepay to the server.
       *This limit is applied during path finding. Typically this value is taken
       *from the response of the GetQuote call.
       * </pre>
       *
       * <code>int64 max_prepay_routing_fee = 4 [jstype = JS_STRING];</code>
       * @return This builder for chaining.
       */
      public Builder clearMaxPrepayRoutingFee() {
        bitField0_ = (bitField0_ & ~0x00000008);
        maxPrepayRoutingFee_ = 0L;
        onChanged();
        return this;
      }

      private long maxSwapFee_ ;
      /**
       * <pre>
       *
       *Maximum we are willing to pay the server for the swap. This value is not
       *disclosed in the swap initiation call, but if the server asks for a
       *higher fee, we abort the swap. Typically this value is taken from the
       *response of the GetQuote call. It includes the prepay amount.
       * </pre>
       *
       * <code>int64 max_swap_fee = 5 [jstype = JS_STRING];</code>
       * @return The maxSwapFee.
       */
      @java.lang.Override
      public long getMaxSwapFee() {
        return maxSwapFee_;
      }
      /**
       * <pre>
       *
       *Maximum we are willing to pay the server for the swap. This value is not
       *disclosed in the swap initiation call, but if the server asks for a
       *higher fee, we abort the swap. Typically this value is taken from the
       *response of the GetQuote call. It includes the prepay amount.
       * </pre>
       *
       * <code>int64 max_swap_fee = 5 [jstype = JS_STRING];</code>
       * @param value The maxSwapFee to set.
       * @return This builder for chaining.
       */
      public Builder setMaxSwapFee(long value) {

        maxSwapFee_ = value;
        bitField0_ |= 0x00000010;
        onChanged();
        return this;
      }
      /**
       * <pre>
       *
       *Maximum we are willing to pay the server for the swap. This value is not
       *disclosed in the swap initiation call, but if the server asks for a
       *higher fee, we abort the swap. Typically this value is taken from the
       *response of the GetQuote call. It includes the prepay amount.
       * </pre>
       *
       * <code>int64 max_swap_fee = 5 [jstype = JS_STRING];</code>
       * @return This builder for chaining.
       */
      public Builder clearMaxSwapFee() {
        bitField0_ = (bitField0_ & ~0x00000010);
        maxSwapFee_ = 0L;
        onChanged();
        return this;
      }

      private long maxPrepayAmt_ ;
      /**
       * <pre>
       *
       *Maximum amount of the swap fee that may be charged as a prepayment.
       * </pre>
       *
       * <code>int64 max_prepay_amt = 6 [jstype = JS_STRING];</code>
       * @return The maxPrepayAmt.
       */
      @java.lang.Override
      public long getMaxPrepayAmt() {
        return maxPrepayAmt_;
      }
      /**
       * <pre>
       *
       *Maximum amount of the swap fee that may be charged as a prepayment.
       * </pre>
       *
       * <code>int64 max_prepay_amt = 6 [jstype = JS_STRING];</code>
       * @param value The maxPrepayAmt to set.
       * @return This builder for chaining.
       */
      public Builder setMaxPrepayAmt(long value) {

        maxPrepayAmt_ = value;
        bitField0_ |= 0x00000020;
        onChanged();
        return this;
      }
      /**
       * <pre>
       *
       *Maximum amount of the swap fee that may be charged as a prepayment.
       * </pre>
       *
       * <code>int64 max_prepay_amt = 6 [jstype = JS_STRING];</code>
       * @return This builder for chaining.
       */
      public Builder clearMaxPrepayAmt() {
        bitField0_ = (bitField0_ & ~0x00000020);
        maxPrepayAmt_ = 0L;
        onChanged();
        return this;
      }

      private long maxMinerFee_ ;
      /**
       * <pre>
       *
       *Maximum in on-chain fees that we are willing to spend. If we want to
       *sweep the on-chain htlc and the fee estimate turns out higher than this
       *value, we cancel the swap. If the fee estimate is lower, we publish the
       *sweep tx.
       *
       *If the sweep tx is not confirmed, we are forced to ratchet up fees until it
       *is swept. Possibly even exceeding max_miner_fee if we get close to the htlc
       *timeout. Because the initial publication revealed the preimage, we have no
       *other choice. The server may already have pulled the off-chain htlc. Only
       *when the fee becomes higher than the swap amount, we can only wait for fees
       *to come down and hope - if we are past the timeout - that the server is not
       *publishing the revocation.
       *
       *max_miner_fee is typically taken from the response of the GetQuote call.
       * </pre>
       *
       * <code>int64 max_miner_fee = 7 [jstype = JS_STRING];</code>
       * @return The maxMinerFee.
       */
      @java.lang.Override
      public long getMaxMinerFee() {
        return maxMinerFee_;
      }
      /**
       * <pre>
       *
       *Maximum in on-chain fees that we are willing to spend. If we want to
       *sweep the on-chain htlc and the fee estimate turns out higher than this
       *value, we cancel the swap. If the fee estimate is lower, we publish the
       *sweep tx.
       *
       *If the sweep tx is not confirmed, we are forced to ratchet up fees until it
       *is swept. Possibly even exceeding max_miner_fee if we get close to the htlc
       *timeout. Because the initial publication revealed the preimage, we have no
       *other choice. The server may already have pulled the off-chain htlc. Only
       *when the fee becomes higher than the swap amount, we can only wait for fees
       *to come down and hope - if we are past the timeout - that the server is not
       *publishing the revocation.
       *
       *max_miner_fee is typically taken from the response of the GetQuote call.
       * </pre>
       *
       * <code>int64 max_miner_fee = 7 [jstype = JS_STRING];</code>
       * @param value The maxMinerFee to set.
       * @return This builder for chaining.
       */
      public Builder setMaxMinerFee(long value) {

        maxMinerFee_ = value;
        bitField0_ |= 0x00000040;
        onChanged();
        return this;
      }
      /**
       * <pre>
       *
       *Maximum in on-chain fees that we are willing to spend. If we want to
       *sweep the on-chain htlc and the fee estimate turns out higher than this
       *value, we cancel the swap. If the fee estimate is lower, we publish the
       *sweep tx.
       *
       *If the sweep tx is not confirmed, we are forced to ratchet up fees until it
       *is swept. Possibly even exceeding max_miner_fee if we get close to the htlc
       *timeout. Because the initial publication revealed the preimage, we have no
       *other choice. The server may already have pulled the off-chain htlc. Only
       *when the fee becomes higher than the swap amount, we can only wait for fees
       *to come down and hope - if we are past the timeout - that the server is not
       *publishing the revocation.
       *
       *max_miner_fee is typically taken from the response of the GetQuote call.
       * </pre>
       *
       * <code>int64 max_miner_fee = 7 [jstype = JS_STRING];</code>
       * @return This builder for chaining.
       */
      public Builder clearMaxMinerFee() {
        bitField0_ = (bitField0_ & ~0x00000040);
        maxMinerFee_ = 0L;
        onChanged();
        return this;
      }

      private long loopOutChannel_ ;
      /**
       * <pre>
       *
       *Deprecated, use outgoing_chan_set. The channel to loop out, the channel
       *to loop out is selected based on the lowest routing fee for the swap
       *payment to the server.
       * </pre>
       *
       * <code>uint64 loop_out_channel = 8 [deprecated = true, jstype = JS_STRING];</code>
       * @deprecated looprpc.LoopOutRequest.loop_out_channel is deprecated.
       *     See loop.proto;l=174
       * @return The loopOutChannel.
       */
      @java.lang.Override
      @java.lang.Deprecated public long getLoopOutChannel() {
        return loopOutChannel_;
      }
      /**
       * <pre>
       *
       *Deprecated, use outgoing_chan_set. The channel to loop out, the channel
       *to loop out is selected based on the lowest routing fee for the swap
       *payment to the server.
       * </pre>
       *
       * <code>uint64 loop_out_channel = 8 [deprecated = true, jstype = JS_STRING];</code>
       * @deprecated looprpc.LoopOutRequest.loop_out_channel is deprecated.
       *     See loop.proto;l=174
       * @param value The loopOutChannel to set.
       * @return This builder for chaining.
       */
      @java.lang.Deprecated public Builder setLoopOutChannel(long value) {

        loopOutChannel_ = value;
        bitField0_ |= 0x00000080;
        onChanged();
        return this;
      }
      /**
       * <pre>
       *
       *Deprecated, use outgoing_chan_set. The channel to loop out, the channel
       *to loop out is selected based on the lowest routing fee for the swap
       *payment to the server.
       * </pre>
       *
       * <code>uint64 loop_out_channel = 8 [deprecated = true, jstype = JS_STRING];</code>
       * @deprecated looprpc.LoopOutRequest.loop_out_channel is deprecated.
       *     See loop.proto;l=174
       * @return This builder for chaining.
       */
      @java.lang.Deprecated public Builder clearLoopOutChannel() {
        bitField0_ = (bitField0_ & ~0x00000080);
        loopOutChannel_ = 0L;
        onChanged();
        return this;
      }

      private com.google.protobuf.Internal.LongList outgoingChanSet_ = emptyLongList();
      private void ensureOutgoingChanSetIsMutable() {
        if (!outgoingChanSet_.isModifiable()) {
          outgoingChanSet_ = makeMutableCopy(outgoingChanSet_);
        }
        bitField0_ |= 0x00000100;
      }
      /**
       * <pre>
       *
       *A restriction on the channel set that may be used to loop out. The actual
       *channel(s) that will be used are selected based on the lowest routing fee
       *for the swap payment to the server.
       * </pre>
       *
       * <code>repeated uint64 outgoing_chan_set = 11 [jstype = JS_STRING];</code>
       * @return A list containing the outgoingChanSet.
       */
      public java.util.List<java.lang.Long>
          getOutgoingChanSetList() {
        outgoingChanSet_.makeImmutable();
        return outgoingChanSet_;
      }
      /**
       * <pre>
       *
       *A restriction on the channel set that may be used to loop out. The actual
       *channel(s) that will be used are selected based on the lowest routing fee
       *for the swap payment to the server.
       * </pre>
       *
       * <code>repeated uint64 outgoing_chan_set = 11 [jstype = JS_STRING];</code>
       * @return The count of outgoingChanSet.
       */
      public int getOutgoingChanSetCount() {
        return outgoingChanSet_.size();
      }
      /**
       * <pre>
       *
       *A restriction on the channel set that may be used to loop out. The actual
       *channel(s) that will be used are selected based on the lowest routing fee
       *for the swap payment to the server.
       * </pre>
       *
       * <code>repeated uint64 outgoing_chan_set = 11 [jstype = JS_STRING];</code>
       * @param index The index of the element to return.
       * @return The outgoingChanSet at the given index.
       */
      public long getOutgoingChanSet(int index) {
        return outgoingChanSet_.getLong(index);
      }
      /**
       * <pre>
       *
       *A restriction on the channel set that may be used to loop out. The actual
       *channel(s) that will be used are selected based on the lowest routing fee
       *for the swap payment to the server.
       * </pre>
       *
       * <code>repeated uint64 outgoing_chan_set = 11 [jstype = JS_STRING];</code>
       * @param index The index to set the value at.
       * @param value The outgoingChanSet to set.
       * @return This builder for chaining.
       */
      public Builder setOutgoingChanSet(
          int index, long value) {

        ensureOutgoingChanSetIsMutable();
        outgoingChanSet_.setLong(index, value);
        bitField0_ |= 0x00000100;
        onChanged();
        return this;
      }
      /**
       * <pre>
       *
       *A restriction on the channel set that may be used to loop out. The actual
       *channel(s) that will be used are selected based on the lowest routing fee
       *for the swap payment to the server.
       * </pre>
       *
       * <code>repeated uint64 outgoing_chan_set = 11 [jstype = JS_STRING];</code>
       * @param value The outgoingChanSet to add.
       * @return This builder for chaining.
       */
      public Builder addOutgoingChanSet(long value) {

        ensureOutgoingChanSetIsMutable();
        outgoingChanSet_.addLong(value);
        bitField0_ |= 0x00000100;
        onChanged();
        return this;
      }
      /**
       * <pre>
       *
       *A restriction on the channel set that may be used to loop out. The actual
       *channel(s) that will be used are selected based on the lowest routing fee
       *for the swap payment to the server.
       * </pre>
       *
       * <code>repeated uint64 outgoing_chan_set = 11 [jstype = JS_STRING];</code>
       * @param values The outgoingChanSet to add.
       * @return This builder for chaining.
       */
      public Builder addAllOutgoingChanSet(
          java.lang.Iterable<? extends java.lang.Long> values) {
        ensureOutgoingChanSetIsMutable();
        com.google.protobuf.AbstractMessageLite.Builder.addAll(
            values, outgoingChanSet_);
        bitField0_ |= 0x00000100;
        onChanged();
        return this;
      }
      /**
       * <pre>
       *
       *A restriction on the channel set that may be used to loop out. The actual
       *channel(s) that will be used are selected based on the lowest routing fee
       *for the swap payment to the server.
       * </pre>
       *
       * <code>repeated uint64 outgoing_chan_set = 11 [jstype = JS_STRING];</code>
       * @return This builder for chaining.
       */
      public Builder clearOutgoingChanSet() {
        outgoingChanSet_ = emptyLongList();
        bitField0_ = (bitField0_ & ~0x00000100);
        onChanged();
        return this;
      }

      private int sweepConfTarget_ ;
      /**
       * <pre>
       *
       *The number of blocks from the on-chain HTLC's confirmation height that it
       *should be swept within.
       * </pre>
       *
       * <code>int32 sweep_conf_target = 9;</code>
       * @return The sweepConfTarget.
       */
      @java.lang.Override
      public int getSweepConfTarget() {
        return sweepConfTarget_;
      }
      /**
       * <pre>
       *
       *The number of blocks from the on-chain HTLC's confirmation height that it
       *should be swept within.
       * </pre>
       *
       * <code>int32 sweep_conf_target = 9;</code>
       * @param value The sweepConfTarget to set.
       * @return This builder for chaining.
       */
      public Builder setSweepConfTarget(int value) {

        sweepConfTarget_ = value;
        bitField0_ |= 0x00000200;
        onChanged();
        return this;
      }
      /**
       * <pre>
       *
       *The number of blocks from the on-chain HTLC's confirmation height that it
       *should be swept within.
       * </pre>
       *
       * <code>int32 sweep_conf_target = 9;</code>
       * @return This builder for chaining.
       */
      public Builder clearSweepConfTarget() {
        bitField0_ = (bitField0_ & ~0x00000200);
        sweepConfTarget_ = 0;
        onChanged();
        return this;
      }

      private int htlcConfirmations_ ;
      /**
       * <pre>
       *
       *The number of confirmations that we require for the on chain htlc that will
       *be published by the server before we reveal the preimage.
       * </pre>
       *
       * <code>int32 htlc_confirmations = 13;</code>
       * @return The htlcConfirmations.
       */
      @java.lang.Override
      public int getHtlcConfirmations() {
        return htlcConfirmations_;
      }
      /**
       * <pre>
       *
       *The number of confirmations that we require for the on chain htlc that will
       *be published by the server before we reveal the preimage.
       * </pre>
       *
       * <code>int32 htlc_confirmations = 13;</code>
       * @param value The htlcConfirmations to set.
       * @return This builder for chaining.
       */
      public Builder setHtlcConfirmations(int value) {

        htlcConfirmations_ = value;
        bitField0_ |= 0x00000400;
        onChanged();
        return this;
      }
      /**
       * <pre>
       *
       *The number of confirmations that we require for the on chain htlc that will
       *be published by the server before we reveal the preimage.
       * </pre>
       *
       * <code>int32 htlc_confirmations = 13;</code>
       * @return This builder for chaining.
       */
      public Builder clearHtlcConfirmations() {
        bitField0_ = (bitField0_ & ~0x00000400);
        htlcConfirmations_ = 0;
        onChanged();
        return this;
      }

      private long swapPublicationDeadline_ ;
      /**
       * <pre>
       *
       *The latest time (in unix seconds) we allow the server to wait before
       *publishing the HTLC on chain. Setting this to a larger value will give the
       *server the opportunity to batch multiple swaps together, and wait for
       *low-fee periods before publishing the HTLC, potentially resulting in a
       *lower total swap fee.
       * </pre>
       *
       * <code>uint64 swap_publication_deadline = 10 [jstype = JS_STRING];</code>
       * @return The swapPublicationDeadline.
       */
      @java.lang.Override
      public long getSwapPublicationDeadline() {
        return swapPublicationDeadline_;
      }
      /**
       * <pre>
       *
       *The latest time (in unix seconds) we allow the server to wait before
       *publishing the HTLC on chain. Setting this to a larger value will give the
       *server the opportunity to batch multiple swaps together, and wait for
       *low-fee periods before publishing the HTLC, potentially resulting in a
       *lower total swap fee.
       * </pre>
       *
       * <code>uint64 swap_publication_deadline = 10 [jstype = JS_STRING];</code>
       * @param value The swapPublicationDeadline to set.
       * @return This builder for chaining.
       */
      public Builder setSwapPublicationDeadline(long value) {

        swapPublicationDeadline_ = value;
        bitField0_ |= 0x00000800;
        onChanged();
        return this;
      }
      /**
       * <pre>
       *
       *The latest time (in unix seconds) we allow the server to wait before
       *publishing the HTLC on chain. Setting this to a larger value will give the
       *server the opportunity to batch multiple swaps together, and wait for
       *low-fee periods before publishing the HTLC, potentially resulting in a
       *lower total swap fee.
       * </pre>
       *
       * <code>uint64 swap_publication_deadline = 10 [jstype = JS_STRING];</code>
       * @return This builder for chaining.
       */
      public Builder clearSwapPublicationDeadline() {
        bitField0_ = (bitField0_ & ~0x00000800);
        swapPublicationDeadline_ = 0L;
        onChanged();
        return this;
      }

      private java.lang.Object label_ = "";
      /**
       * <pre>
       *
       *An optional label for this swap. This field is limited to 500 characters
       *and may not start with the prefix [reserved], which is used to tag labels
       *produced by the daemon.
       * </pre>
       *
       * <code>string label = 12;</code>
       * @return The label.
       */
      public java.lang.String getLabel() {
        java.lang.Object ref = label_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          label_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       *
       *An optional label for this swap. This field is limited to 500 characters
       *and may not start with the prefix [reserved], which is used to tag labels
       *produced by the daemon.
       * </pre>
       *
       * <code>string label = 12;</code>
       * @return The bytes for label.
       */
      public com.google.protobuf.ByteString
          getLabelBytes() {
        java.lang.Object ref = label_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          label_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       *
       *An optional label for this swap. This field is limited to 500 characters
       *and may not start with the prefix [reserved], which is used to tag labels
       *produced by the daemon.
       * </pre>
       *
       * <code>string label = 12;</code>
       * @param value The label to set.
       * @return This builder for chaining.
       */
      public Builder setLabel(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        label_ = value;
        bitField0_ |= 0x00001000;
        onChanged();
        return this;
      }
      /**
       * <pre>
       *
       *An optional label for this swap. This field is limited to 500 characters
       *and may not start with the prefix [reserved], which is used to tag labels
       *produced by the daemon.
       * </pre>
       *
       * <code>string label = 12;</code>
       * @return This builder for chaining.
       */
      public Builder clearLabel() {
        label_ = getDefaultInstance().getLabel();
        bitField0_ = (bitField0_ & ~0x00001000);
        onChanged();
        return this;
      }
      /**
       * <pre>
       *
       *An optional label for this swap. This field is limited to 500 characters
       *and may not start with the prefix [reserved], which is used to tag labels
       *produced by the daemon.
       * </pre>
       *
       * <code>string label = 12;</code>
       * @param value The bytes for label to set.
       * @return This builder for chaining.
       */
      public Builder setLabelBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        checkByteStringIsUtf8(value);
        label_ = value;
        bitField0_ |= 0x00001000;
        onChanged();
        return this;
      }

      private java.lang.Object initiator_ = "";
      /**
       * <pre>
       *
       *An optional identification string that will be appended to the user agent
       *string sent to the server to give information about the usage of loop. This
       *initiator part is meant for user interfaces to add their name to give the
       *full picture of the binary used (loopd, LiT) and the method used for
       *triggering the swap (loop CLI, autolooper, LiT UI, other 3rd party UI).
       * </pre>
       *
       * <code>string initiator = 14;</code>
       * @return The initiator.
       */
      public java.lang.String getInitiator() {
        java.lang.Object ref = initiator_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          initiator_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       *
       *An optional identification string that will be appended to the user agent
       *string sent to the server to give information about the usage of loop. This
       *initiator part is meant for user interfaces to add their name to give the
       *full picture of the binary used (loopd, LiT) and the method used for
       *triggering the swap (loop CLI, autolooper, LiT UI, other 3rd party UI).
       * </pre>
       *
       * <code>string initiator = 14;</code>
       * @return The bytes for initiator.
       */
      public com.google.protobuf.ByteString
          getInitiatorBytes() {
        java.lang.Object ref = initiator_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          initiator_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       *
       *An optional identification string that will be appended to the user agent
       *string sent to the server to give information about the usage of loop. This
       *initiator part is meant for user interfaces to add their name to give the
       *full picture of the binary used (loopd, LiT) and the method used for
       *triggering the swap (loop CLI, autolooper, LiT UI, other 3rd party UI).
       * </pre>
       *
       * <code>string initiator = 14;</code>
       * @param value The initiator to set.
       * @return This builder for chaining.
       */
      public Builder setInitiator(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        initiator_ = value;
        bitField0_ |= 0x00002000;
        onChanged();
        return this;
      }
      /**
       * <pre>
       *
       *An optional identification string that will be appended to the user agent
       *string sent to the server to give information about the usage of loop. This
       *initiator part is meant for user interfaces to add their name to give the
       *full picture of the binary used (loopd, LiT) and the method used for
       *triggering the swap (loop CLI, autolooper, LiT UI, other 3rd party UI).
       * </pre>
       *
       * <code>string initiator = 14;</code>
       * @return This builder for chaining.
       */
      public Builder clearInitiator() {
        initiator_ = getDefaultInstance().getInitiator();
        bitField0_ = (bitField0_ & ~0x00002000);
        onChanged();
        return this;
      }
      /**
       * <pre>
       *
       *An optional identification string that will be appended to the user agent
       *string sent to the server to give information about the usage of loop. This
       *initiator part is meant for user interfaces to add their name to give the
       *full picture of the binary used (loopd, LiT) and the method used for
       *triggering the swap (loop CLI, autolooper, LiT UI, other 3rd party UI).
       * </pre>
       *
       * <code>string initiator = 14;</code>
       * @param value The bytes for initiator to set.
       * @return This builder for chaining.
       */
      public Builder setInitiatorBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        checkByteStringIsUtf8(value);
        initiator_ = value;
        bitField0_ |= 0x00002000;
        onChanged();
        return this;
      }

      private java.lang.Object account_ = "";
      /**
       * <pre>
       *
       *An alternative destination address source for the swap. This field
       *represents the name of the account in the backing lnd instance.
       *Refer to lnd's wallet import functions for reference.
       * </pre>
       *
       * <code>string account = 15;</code>
       * @return The account.
       */
      public java.lang.String getAccount() {
        java.lang.Object ref = account_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          account_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       *
       *An alternative destination address source for the swap. This field
       *represents the name of the account in the backing lnd instance.
       *Refer to lnd's wallet import functions for reference.
       * </pre>
       *
       * <code>string account = 15;</code>
       * @return The bytes for account.
       */
      public com.google.protobuf.ByteString
          getAccountBytes() {
        java.lang.Object ref = account_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          account_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       *
       *An alternative destination address source for the swap. This field
       *represents the name of the account in the backing lnd instance.
       *Refer to lnd's wallet import functions for reference.
       * </pre>
       *
       * <code>string account = 15;</code>
       * @param value The account to set.
       * @return This builder for chaining.
       */
      public Builder setAccount(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        account_ = value;
        bitField0_ |= 0x00004000;
        onChanged();
        return this;
      }
      /**
       * <pre>
       *
       *An alternative destination address source for the swap. This field
       *represents the name of the account in the backing lnd instance.
       *Refer to lnd's wallet import functions for reference.
       * </pre>
       *
       * <code>string account = 15;</code>
       * @return This builder for chaining.
       */
      public Builder clearAccount() {
        account_ = getDefaultInstance().getAccount();
        bitField0_ = (bitField0_ & ~0x00004000);
        onChanged();
        return this;
      }
      /**
       * <pre>
       *
       *An alternative destination address source for the swap. This field
       *represents the name of the account in the backing lnd instance.
       *Refer to lnd's wallet import functions for reference.
       * </pre>
       *
       * <code>string account = 15;</code>
       * @param value The bytes for account to set.
       * @return This builder for chaining.
       */
      public Builder setAccountBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        checkByteStringIsUtf8(value);
        account_ = value;
        bitField0_ |= 0x00004000;
        onChanged();
        return this;
      }

      private int accountAddrType_ = 0;
      /**
       * <pre>
       *
       *The address type of the account specified in the account field.
       * </pre>
       *
       * <code>.looprpc.AddressType account_addr_type = 16;</code>
       * @return The enum numeric value on the wire for accountAddrType.
       */
      @java.lang.Override public int getAccountAddrTypeValue() {
        return accountAddrType_;
      }
      /**
       * <pre>
       *
       *The address type of the account specified in the account field.
       * </pre>
       *
       * <code>.looprpc.AddressType account_addr_type = 16;</code>
       * @param value The enum numeric value on the wire for accountAddrType to set.
       * @return This builder for chaining.
       */
      public Builder setAccountAddrTypeValue(int value) {
        accountAddrType_ = value;
        bitField0_ |= 0x00008000;
        onChanged();
        return this;
      }
      /**
       * <pre>
       *
       *The address type of the account specified in the account field.
       * </pre>
       *
       * <code>.looprpc.AddressType account_addr_type = 16;</code>
       * @return The accountAddrType.
       */
      @java.lang.Override
      public looprpc.Loop.AddressType getAccountAddrType() {
        looprpc.Loop.AddressType result = looprpc.Loop.AddressType.forNumber(accountAddrType_);
        return result == null ? looprpc.Loop.AddressType.UNRECOGNIZED : result;
      }
      /**
       * <pre>
       *
       *The address type of the account specified in the account field.
       * </pre>
       *
       * <code>.looprpc.AddressType account_addr_type = 16;</code>
       * @param value The accountAddrType to set.
       * @return This builder for chaining.
       */
      public Builder setAccountAddrType(looprpc.Loop.AddressType value) {
        if (value == null) {
          throw new NullPointerException();
        }
        bitField0_ |= 0x00008000;
        accountAddrType_ = value.getNumber();
        onChanged();
        return this;
      }
      /**
       * <pre>
       *
       *The address type of the account specified in the account field.
       * </pre>
       *
       * <code>.looprpc.AddressType account_addr_type = 16;</code>
       * @return This builder for chaining.
       */
      public Builder clearAccountAddrType() {
        bitField0_ = (bitField0_ & ~0x00008000);
        accountAddrType_ = 0;
        onChanged();
        return this;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:looprpc.LoopOutRequest)
    }

    // @@protoc_insertion_point(class_scope:looprpc.LoopOutRequest)
    private static final looprpc.Loop.LoopOutRequest DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new looprpc.Loop.LoopOutRequest();
    }

    public static looprpc.Loop.LoopOutRequest getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<LoopOutRequest>
        PARSER = new com.google.protobuf.AbstractParser<LoopOutRequest>() {
      @java.lang.Override
      public LoopOutRequest parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<LoopOutRequest> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<LoopOutRequest> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public looprpc.Loop.LoopOutRequest getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface LoopInRequestOrBuilder extends
      // @@protoc_insertion_point(interface_extends:looprpc.LoopInRequest)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     *
     *Requested swap amount in sat. This does not include the swap and miner
     *fee.
     * </pre>
     *
     * <code>int64 amt = 1 [jstype = JS_STRING];</code>
     * @return The amt.
     */
    long getAmt();

    /**
     * <pre>
     *
     *Maximum we are willing to pay the server for the swap. This value is not
     *disclosed in the swap initiation call, but if the server asks for a
     *higher fee, we abort the swap. Typically this value is taken from the
     *response of the GetQuote call.
     * </pre>
     *
     * <code>int64 max_swap_fee = 2 [jstype = JS_STRING];</code>
     * @return The maxSwapFee.
     */
    long getMaxSwapFee();

    /**
     * <pre>
     *
     *Maximum in on-chain fees that we are willing to spend. If we want to
     *publish the on-chain htlc and the fee estimate turns out higher than this
     *value, we cancel the swap.
     *
     *max_miner_fee is typically taken from the response of the GetQuote call.
     * </pre>
     *
     * <code>int64 max_miner_fee = 3 [jstype = JS_STRING];</code>
     * @return The maxMinerFee.
     */
    long getMaxMinerFee();

    /**
     * <pre>
     *
     *The last hop to use for the loop in swap. If empty, the last hop is selected
     *based on the lowest routing fee for the swap payment from the server.
     * </pre>
     *
     * <code>bytes last_hop = 4;</code>
     * @return The lastHop.
     */
    com.google.protobuf.ByteString getLastHop();

    /**
     * <pre>
     *
     *If external_htlc is true, we expect the htlc to be published by an external
     *actor.
     * </pre>
     *
     * <code>bool external_htlc = 5;</code>
     * @return The externalHtlc.
     */
    boolean getExternalHtlc();

    /**
     * <pre>
     *
     *The number of blocks that the on chain htlc should confirm within.
     * </pre>
     *
     * <code>int32 htlc_conf_target = 6;</code>
     * @return The htlcConfTarget.
     */
    int getHtlcConfTarget();

    /**
     * <pre>
     *
     *An optional label for this swap. This field is limited to 500 characters
     *and may not be one of the reserved values in loop/labels Reserved list.
     * </pre>
     *
     * <code>string label = 7;</code>
     * @return The label.
     */
    java.lang.String getLabel();
    /**
     * <pre>
     *
     *An optional label for this swap. This field is limited to 500 characters
     *and may not be one of the reserved values in loop/labels Reserved list.
     * </pre>
     *
     * <code>string label = 7;</code>
     * @return The bytes for label.
     */
    com.google.protobuf.ByteString
        getLabelBytes();

    /**
     * <pre>
     *
     *An optional identification string that will be appended to the user agent
     *string sent to the server to give information about the usage of loop. This
     *initiator part is meant for user interfaces to add their name to give the
     *full picture of the binary used (loopd, LiT) and the method used for
     *triggering the swap (loop CLI, autolooper, LiT UI, other 3rd party UI).
     * </pre>
     *
     * <code>string initiator = 8;</code>
     * @return The initiator.
     */
    java.lang.String getInitiator();
    /**
     * <pre>
     *
     *An optional identification string that will be appended to the user agent
     *string sent to the server to give information about the usage of loop. This
     *initiator part is meant for user interfaces to add their name to give the
     *full picture of the binary used (loopd, LiT) and the method used for
     *triggering the swap (loop CLI, autolooper, LiT UI, other 3rd party UI).
     * </pre>
     *
     * <code>string initiator = 8;</code>
     * @return The bytes for initiator.
     */
    com.google.protobuf.ByteString
        getInitiatorBytes();

    /**
     * <pre>
     *
     *Optional route hints to reach the destination through private channels.
     * </pre>
     *
     * <code>repeated .looprpc.RouteHint route_hints = 9;</code>
     */
    java.util.List<looprpc.Common.RouteHint> 
        getRouteHintsList();
    /**
     * <pre>
     *
     *Optional route hints to reach the destination through private channels.
     * </pre>
     *
     * <code>repeated .looprpc.RouteHint route_hints = 9;</code>
     */
    looprpc.Common.RouteHint getRouteHints(int index);
    /**
     * <pre>
     *
     *Optional route hints to reach the destination through private channels.
     * </pre>
     *
     * <code>repeated .looprpc.RouteHint route_hints = 9;</code>
     */
    int getRouteHintsCount();
    /**
     * <pre>
     *
     *Optional route hints to reach the destination through private channels.
     * </pre>
     *
     * <code>repeated .looprpc.RouteHint route_hints = 9;</code>
     */
    java.util.List<? extends looprpc.Common.RouteHintOrBuilder> 
        getRouteHintsOrBuilderList();
    /**
     * <pre>
     *
     *Optional route hints to reach the destination through private channels.
     * </pre>
     *
     * <code>repeated .looprpc.RouteHint route_hints = 9;</code>
     */
    looprpc.Common.RouteHintOrBuilder getRouteHintsOrBuilder(
        int index);

    /**
     * <pre>
     *
     *Private indicates whether the destination node should be considered
     *private. In which case, loop will generate hophints to assist with
     *probing and payment.
     * </pre>
     *
     * <code>bool private = 10;</code>
     * @return The private.
     */
    boolean getPrivate();
  }
  /**
   * Protobuf type {@code looprpc.LoopInRequest}
   */
  public static final class LoopInRequest extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:looprpc.LoopInRequest)
      LoopInRequestOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use LoopInRequest.newBuilder() to construct.
    private LoopInRequest(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private LoopInRequest() {
      lastHop_ = com.google.protobuf.ByteString.EMPTY;
      label_ = "";
      initiator_ = "";
      routeHints_ = java.util.Collections.emptyList();
    }

    @java.lang.Override
    @SuppressWarnings({"unused"})
    protected java.lang.Object newInstance(
        UnusedPrivateParameter unused) {
      return new LoopInRequest();
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return looprpc.Loop.internal_static_looprpc_LoopInRequest_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return looprpc.Loop.internal_static_looprpc_LoopInRequest_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              looprpc.Loop.LoopInRequest.class, looprpc.Loop.LoopInRequest.Builder.class);
    }

    public static final int AMT_FIELD_NUMBER = 1;
    private long amt_ = 0L;
    /**
     * <pre>
     *
     *Requested swap amount in sat. This does not include the swap and miner
     *fee.
     * </pre>
     *
     * <code>int64 amt = 1 [jstype = JS_STRING];</code>
     * @return The amt.
     */
    @java.lang.Override
    public long getAmt() {
      return amt_;
    }

    public static final int MAX_SWAP_FEE_FIELD_NUMBER = 2;
    private long maxSwapFee_ = 0L;
    /**
     * <pre>
     *
     *Maximum we are willing to pay the server for the swap. This value is not
     *disclosed in the swap initiation call, but if the server asks for a
     *higher fee, we abort the swap. Typically this value is taken from the
     *response of the GetQuote call.
     * </pre>
     *
     * <code>int64 max_swap_fee = 2 [jstype = JS_STRING];</code>
     * @return The maxSwapFee.
     */
    @java.lang.Override
    public long getMaxSwapFee() {
      return maxSwapFee_;
    }

    public static final int MAX_MINER_FEE_FIELD_NUMBER = 3;
    private long maxMinerFee_ = 0L;
    /**
     * <pre>
     *
     *Maximum in on-chain fees that we are willing to spend. If we want to
     *publish the on-chain htlc and the fee estimate turns out higher than this
     *value, we cancel the swap.
     *
     *max_miner_fee is typically taken from the response of the GetQuote call.
     * </pre>
     *
     * <code>int64 max_miner_fee = 3 [jstype = JS_STRING];</code>
     * @return The maxMinerFee.
     */
    @java.lang.Override
    public long getMaxMinerFee() {
      return maxMinerFee_;
    }

    public static final int LAST_HOP_FIELD_NUMBER = 4;
    private com.google.protobuf.ByteString lastHop_ = com.google.protobuf.ByteString.EMPTY;
    /**
     * <pre>
     *
     *The last hop to use for the loop in swap. If empty, the last hop is selected
     *based on the lowest routing fee for the swap payment from the server.
     * </pre>
     *
     * <code>bytes last_hop = 4;</code>
     * @return The lastHop.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString getLastHop() {
      return lastHop_;
    }

    public static final int EXTERNAL_HTLC_FIELD_NUMBER = 5;
    private boolean externalHtlc_ = false;
    /**
     * <pre>
     *
     *If external_htlc is true, we expect the htlc to be published by an external
     *actor.
     * </pre>
     *
     * <code>bool external_htlc = 5;</code>
     * @return The externalHtlc.
     */
    @java.lang.Override
    public boolean getExternalHtlc() {
      return externalHtlc_;
    }

    public static final int HTLC_CONF_TARGET_FIELD_NUMBER = 6;
    private int htlcConfTarget_ = 0;
    /**
     * <pre>
     *
     *The number of blocks that the on chain htlc should confirm within.
     * </pre>
     *
     * <code>int32 htlc_conf_target = 6;</code>
     * @return The htlcConfTarget.
     */
    @java.lang.Override
    public int getHtlcConfTarget() {
      return htlcConfTarget_;
    }

    public static final int LABEL_FIELD_NUMBER = 7;
    @SuppressWarnings("serial")
    private volatile java.lang.Object label_ = "";
    /**
     * <pre>
     *
     *An optional label for this swap. This field is limited to 500 characters
     *and may not be one of the reserved values in loop/labels Reserved list.
     * </pre>
     *
     * <code>string label = 7;</code>
     * @return The label.
     */
    @java.lang.Override
    public java.lang.String getLabel() {
      java.lang.Object ref = label_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        label_ = s;
        return s;
      }
    }
    /**
     * <pre>
     *
     *An optional label for this swap. This field is limited to 500 characters
     *and may not be one of the reserved values in loop/labels Reserved list.
     * </pre>
     *
     * <code>string label = 7;</code>
     * @return The bytes for label.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getLabelBytes() {
      java.lang.Object ref = label_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        label_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int INITIATOR_FIELD_NUMBER = 8;
    @SuppressWarnings("serial")
    private volatile java.lang.Object initiator_ = "";
    /**
     * <pre>
     *
     *An optional identification string that will be appended to the user agent
     *string sent to the server to give information about the usage of loop. This
     *initiator part is meant for user interfaces to add their name to give the
     *full picture of the binary used (loopd, LiT) and the method used for
     *triggering the swap (loop CLI, autolooper, LiT UI, other 3rd party UI).
     * </pre>
     *
     * <code>string initiator = 8;</code>
     * @return The initiator.
     */
    @java.lang.Override
    public java.lang.String getInitiator() {
      java.lang.Object ref = initiator_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        initiator_ = s;
        return s;
      }
    }
    /**
     * <pre>
     *
     *An optional identification string that will be appended to the user agent
     *string sent to the server to give information about the usage of loop. This
     *initiator part is meant for user interfaces to add their name to give the
     *full picture of the binary used (loopd, LiT) and the method used for
     *triggering the swap (loop CLI, autolooper, LiT UI, other 3rd party UI).
     * </pre>
     *
     * <code>string initiator = 8;</code>
     * @return The bytes for initiator.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getInitiatorBytes() {
      java.lang.Object ref = initiator_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        initiator_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int ROUTE_HINTS_FIELD_NUMBER = 9;
    @SuppressWarnings("serial")
    private java.util.List<looprpc.Common.RouteHint> routeHints_;
    /**
     * <pre>
     *
     *Optional route hints to reach the destination through private channels.
     * </pre>
     *
     * <code>repeated .looprpc.RouteHint route_hints = 9;</code>
     */
    @java.lang.Override
    public java.util.List<looprpc.Common.RouteHint> getRouteHintsList() {
      return routeHints_;
    }
    /**
     * <pre>
     *
     *Optional route hints to reach the destination through private channels.
     * </pre>
     *
     * <code>repeated .looprpc.RouteHint route_hints = 9;</code>
     */
    @java.lang.Override
    public java.util.List<? extends looprpc.Common.RouteHintOrBuilder> 
        getRouteHintsOrBuilderList() {
      return routeHints_;
    }
    /**
     * <pre>
     *
     *Optional route hints to reach the destination through private channels.
     * </pre>
     *
     * <code>repeated .looprpc.RouteHint route_hints = 9;</code>
     */
    @java.lang.Override
    public int getRouteHintsCount() {
      return routeHints_.size();
    }
    /**
     * <pre>
     *
     *Optional route hints to reach the destination through private channels.
     * </pre>
     *
     * <code>repeated .looprpc.RouteHint route_hints = 9;</code>
     */
    @java.lang.Override
    public looprpc.Common.RouteHint getRouteHints(int index) {
      return routeHints_.get(index);
    }
    /**
     * <pre>
     *
     *Optional route hints to reach the destination through private channels.
     * </pre>
     *
     * <code>repeated .looprpc.RouteHint route_hints = 9;</code>
     */
    @java.lang.Override
    public looprpc.Common.RouteHintOrBuilder getRouteHintsOrBuilder(
        int index) {
      return routeHints_.get(index);
    }

    public static final int PRIVATE_FIELD_NUMBER = 10;
    private boolean private_ = false;
    /**
     * <pre>
     *
     *Private indicates whether the destination node should be considered
     *private. In which case, loop will generate hophints to assist with
     *probing and payment.
     * </pre>
     *
     * <code>bool private = 10;</code>
     * @return The private.
     */
    @java.lang.Override
    public boolean getPrivate() {
      return private_;
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (amt_ != 0L) {
        output.writeInt64(1, amt_);
      }
      if (maxSwapFee_ != 0L) {
        output.writeInt64(2, maxSwapFee_);
      }
      if (maxMinerFee_ != 0L) {
        output.writeInt64(3, maxMinerFee_);
      }
      if (!lastHop_.isEmpty()) {
        output.writeBytes(4, lastHop_);
      }
      if (externalHtlc_ != false) {
        output.writeBool(5, externalHtlc_);
      }
      if (htlcConfTarget_ != 0) {
        output.writeInt32(6, htlcConfTarget_);
      }
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(label_)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 7, label_);
      }
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(initiator_)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 8, initiator_);
      }
      for (int i = 0; i < routeHints_.size(); i++) {
        output.writeMessage(9, routeHints_.get(i));
      }
      if (private_ != false) {
        output.writeBool(10, private_);
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (amt_ != 0L) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt64Size(1, amt_);
      }
      if (maxSwapFee_ != 0L) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt64Size(2, maxSwapFee_);
      }
      if (maxMinerFee_ != 0L) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt64Size(3, maxMinerFee_);
      }
      if (!lastHop_.isEmpty()) {
        size += com.google.protobuf.CodedOutputStream
          .computeBytesSize(4, lastHop_);
      }
      if (externalHtlc_ != false) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(5, externalHtlc_);
      }
      if (htlcConfTarget_ != 0) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt32Size(6, htlcConfTarget_);
      }
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(label_)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(7, label_);
      }
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(initiator_)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(8, initiator_);
      }
      for (int i = 0; i < routeHints_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(9, routeHints_.get(i));
      }
      if (private_ != false) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(10, private_);
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof looprpc.Loop.LoopInRequest)) {
        return super.equals(obj);
      }
      looprpc.Loop.LoopInRequest other = (looprpc.Loop.LoopInRequest) obj;

      if (getAmt()
          != other.getAmt()) return false;
      if (getMaxSwapFee()
          != other.getMaxSwapFee()) return false;
      if (getMaxMinerFee()
          != other.getMaxMinerFee()) return false;
      if (!getLastHop()
          .equals(other.getLastHop())) return false;
      if (getExternalHtlc()
          != other.getExternalHtlc()) return false;
      if (getHtlcConfTarget()
          != other.getHtlcConfTarget()) return false;
      if (!getLabel()
          .equals(other.getLabel())) return false;
      if (!getInitiator()
          .equals(other.getInitiator())) return false;
      if (!getRouteHintsList()
          .equals(other.getRouteHintsList())) return false;
      if (getPrivate()
          != other.getPrivate()) return false;
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      hash = (37 * hash) + AMT_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
          getAmt());
      hash = (37 * hash) + MAX_SWAP_FEE_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
          getMaxSwapFee());
      hash = (37 * hash) + MAX_MINER_FEE_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
          getMaxMinerFee());
      hash = (37 * hash) + LAST_HOP_FIELD_NUMBER;
      hash = (53 * hash) + getLastHop().hashCode();
      hash = (37 * hash) + EXTERNAL_HTLC_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
          getExternalHtlc());
      hash = (37 * hash) + HTLC_CONF_TARGET_FIELD_NUMBER;
      hash = (53 * hash) + getHtlcConfTarget();
      hash = (37 * hash) + LABEL_FIELD_NUMBER;
      hash = (53 * hash) + getLabel().hashCode();
      hash = (37 * hash) + INITIATOR_FIELD_NUMBER;
      hash = (53 * hash) + getInitiator().hashCode();
      if (getRouteHintsCount() > 0) {
        hash = (37 * hash) + ROUTE_HINTS_FIELD_NUMBER;
        hash = (53 * hash) + getRouteHintsList().hashCode();
      }
      hash = (37 * hash) + PRIVATE_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
          getPrivate());
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static looprpc.Loop.LoopInRequest parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static looprpc.Loop.LoopInRequest parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static looprpc.Loop.LoopInRequest parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static looprpc.Loop.LoopInRequest parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static looprpc.Loop.LoopInRequest parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static looprpc.Loop.LoopInRequest parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static looprpc.Loop.LoopInRequest parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static looprpc.Loop.LoopInRequest parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static looprpc.Loop.LoopInRequest parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static looprpc.Loop.LoopInRequest parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static looprpc.Loop.LoopInRequest parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static looprpc.Loop.LoopInRequest parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(looprpc.Loop.LoopInRequest prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * Protobuf type {@code looprpc.LoopInRequest}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:looprpc.LoopInRequest)
        looprpc.Loop.LoopInRequestOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return looprpc.Loop.internal_static_looprpc_LoopInRequest_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return looprpc.Loop.internal_static_looprpc_LoopInRequest_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                looprpc.Loop.LoopInRequest.class, looprpc.Loop.LoopInRequest.Builder.class);
      }

      // Construct using looprpc.Loop.LoopInRequest.newBuilder()
      private Builder() {

      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);

      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        amt_ = 0L;
        maxSwapFee_ = 0L;
        maxMinerFee_ = 0L;
        lastHop_ = com.google.protobuf.ByteString.EMPTY;
        externalHtlc_ = false;
        htlcConfTarget_ = 0;
        label_ = "";
        initiator_ = "";
        if (routeHintsBuilder_ == null) {
          routeHints_ = java.util.Collections.emptyList();
        } else {
          routeHints_ = null;
          routeHintsBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000100);
        private_ = false;
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return looprpc.Loop.internal_static_looprpc_LoopInRequest_descriptor;
      }

      @java.lang.Override
      public looprpc.Loop.LoopInRequest getDefaultInstanceForType() {
        return looprpc.Loop.LoopInRequest.getDefaultInstance();
      }

      @java.lang.Override
      public looprpc.Loop.LoopInRequest build() {
        looprpc.Loop.LoopInRequest result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public looprpc.Loop.LoopInRequest buildPartial() {
        looprpc.Loop.LoopInRequest result = new looprpc.Loop.LoopInRequest(this);
        buildPartialRepeatedFields(result);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartialRepeatedFields(looprpc.Loop.LoopInRequest result) {
        if (routeHintsBuilder_ == null) {
          if (((bitField0_ & 0x00000100) != 0)) {
            routeHints_ = java.util.Collections.unmodifiableList(routeHints_);
            bitField0_ = (bitField0_ & ~0x00000100);
          }
          result.routeHints_ = routeHints_;
        } else {
          result.routeHints_ = routeHintsBuilder_.build();
        }
      }

      private void buildPartial0(looprpc.Loop.LoopInRequest result) {
        int from_bitField0_ = bitField0_;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.amt_ = amt_;
        }
        if (((from_bitField0_ & 0x00000002) != 0)) {
          result.maxSwapFee_ = maxSwapFee_;
        }
        if (((from_bitField0_ & 0x00000004) != 0)) {
          result.maxMinerFee_ = maxMinerFee_;
        }
        if (((from_bitField0_ & 0x00000008) != 0)) {
          result.lastHop_ = lastHop_;
        }
        if (((from_bitField0_ & 0x00000010) != 0)) {
          result.externalHtlc_ = externalHtlc_;
        }
        if (((from_bitField0_ & 0x00000020) != 0)) {
          result.htlcConfTarget_ = htlcConfTarget_;
        }
        if (((from_bitField0_ & 0x00000040) != 0)) {
          result.label_ = label_;
        }
        if (((from_bitField0_ & 0x00000080) != 0)) {
          result.initiator_ = initiator_;
        }
        if (((from_bitField0_ & 0x00000200) != 0)) {
          result.private_ = private_;
        }
      }

      @java.lang.Override
      public Builder clone() {
        return super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof looprpc.Loop.LoopInRequest) {
          return mergeFrom((looprpc.Loop.LoopInRequest)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(looprpc.Loop.LoopInRequest other) {
        if (other == looprpc.Loop.LoopInRequest.getDefaultInstance()) return this;
        if (other.getAmt() != 0L) {
          setAmt(other.getAmt());
        }
        if (other.getMaxSwapFee() != 0L) {
          setMaxSwapFee(other.getMaxSwapFee());
        }
        if (other.getMaxMinerFee() != 0L) {
          setMaxMinerFee(other.getMaxMinerFee());
        }
        if (other.getLastHop() != com.google.protobuf.ByteString.EMPTY) {
          setLastHop(other.getLastHop());
        }
        if (other.getExternalHtlc() != false) {
          setExternalHtlc(other.getExternalHtlc());
        }
        if (other.getHtlcConfTarget() != 0) {
          setHtlcConfTarget(other.getHtlcConfTarget());
        }
        if (!other.getLabel().isEmpty()) {
          label_ = other.label_;
          bitField0_ |= 0x00000040;
          onChanged();
        }
        if (!other.getInitiator().isEmpty()) {
          initiator_ = other.initiator_;
          bitField0_ |= 0x00000080;
          onChanged();
        }
        if (routeHintsBuilder_ == null) {
          if (!other.routeHints_.isEmpty()) {
            if (routeHints_.isEmpty()) {
              routeHints_ = other.routeHints_;
              bitField0_ = (bitField0_ & ~0x00000100);
            } else {
              ensureRouteHintsIsMutable();
              routeHints_.addAll(other.routeHints_);
            }
            onChanged();
          }
        } else {
          if (!other.routeHints_.isEmpty()) {
            if (routeHintsBuilder_.isEmpty()) {
              routeHintsBuilder_.dispose();
              routeHintsBuilder_ = null;
              routeHints_ = other.routeHints_;
              bitField0_ = (bitField0_ & ~0x00000100);
              routeHintsBuilder_ = 
                com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
                   getRouteHintsFieldBuilder() : null;
            } else {
              routeHintsBuilder_.addAllMessages(other.routeHints_);
            }
          }
        }
        if (other.getPrivate() != false) {
          setPrivate(other.getPrivate());
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 8: {
                amt_ = input.readInt64();
                bitField0_ |= 0x00000001;
                break;
              } // case 8
              case 16: {
                maxSwapFee_ = input.readInt64();
                bitField0_ |= 0x00000002;
                break;
              } // case 16
              case 24: {
                maxMinerFee_ = input.readInt64();
                bitField0_ |= 0x00000004;
                break;
              } // case 24
              case 34: {
                lastHop_ = input.readBytes();
                bitField0_ |= 0x00000008;
                break;
              } // case 34
              case 40: {
                externalHtlc_ = input.readBool();
                bitField0_ |= 0x00000010;
                break;
              } // case 40
              case 48: {
                htlcConfTarget_ = input.readInt32();
                bitField0_ |= 0x00000020;
                break;
              } // case 48
              case 58: {
                label_ = input.readStringRequireUtf8();
                bitField0_ |= 0x00000040;
                break;
              } // case 58
              case 66: {
                initiator_ = input.readStringRequireUtf8();
                bitField0_ |= 0x00000080;
                break;
              } // case 66
              case 74: {
                looprpc.Common.RouteHint m =
                    input.readMessage(
                        looprpc.Common.RouteHint.parser(),
                        extensionRegistry);
                if (routeHintsBuilder_ == null) {
                  ensureRouteHintsIsMutable();
                  routeHints_.add(m);
                } else {
                  routeHintsBuilder_.addMessage(m);
                }
                break;
              } // case 74
              case 80: {
                private_ = input.readBool();
                bitField0_ |= 0x00000200;
                break;
              } // case 80
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private long amt_ ;
      /**
       * <pre>
       *
       *Requested swap amount in sat. This does not include the swap and miner
       *fee.
       * </pre>
       *
       * <code>int64 amt = 1 [jstype = JS_STRING];</code>
       * @return The amt.
       */
      @java.lang.Override
      public long getAmt() {
        return amt_;
      }
      /**
       * <pre>
       *
       *Requested swap amount in sat. This does not include the swap and miner
       *fee.
       * </pre>
       *
       * <code>int64 amt = 1 [jstype = JS_STRING];</code>
       * @param value The amt to set.
       * @return This builder for chaining.
       */
      public Builder setAmt(long value) {

        amt_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       *
       *Requested swap amount in sat. This does not include the swap and miner
       *fee.
       * </pre>
       *
       * <code>int64 amt = 1 [jstype = JS_STRING];</code>
       * @return This builder for chaining.
       */
      public Builder clearAmt() {
        bitField0_ = (bitField0_ & ~0x00000001);
        amt_ = 0L;
        onChanged();
        return this;
      }

      private long maxSwapFee_ ;
      /**
       * <pre>
       *
       *Maximum we are willing to pay the server for the swap. This value is not
       *disclosed in the swap initiation call, but if the server asks for a
       *higher fee, we abort the swap. Typically this value is taken from the
       *response of the GetQuote call.
       * </pre>
       *
       * <code>int64 max_swap_fee = 2 [jstype = JS_STRING];</code>
       * @return The maxSwapFee.
       */
      @java.lang.Override
      public long getMaxSwapFee() {
        return maxSwapFee_;
      }
      /**
       * <pre>
       *
       *Maximum we are willing to pay the server for the swap. This value is not
       *disclosed in the swap initiation call, but if the server asks for a
       *higher fee, we abort the swap. Typically this value is taken from the
       *response of the GetQuote call.
       * </pre>
       *
       * <code>int64 max_swap_fee = 2 [jstype = JS_STRING];</code>
       * @param value The maxSwapFee to set.
       * @return This builder for chaining.
       */
      public Builder setMaxSwapFee(long value) {

        maxSwapFee_ = value;
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       *
       *Maximum we are willing to pay the server for the swap. This value is not
       *disclosed in the swap initiation call, but if the server asks for a
       *higher fee, we abort the swap. Typically this value is taken from the
       *response of the GetQuote call.
       * </pre>
       *
       * <code>int64 max_swap_fee = 2 [jstype = JS_STRING];</code>
       * @return This builder for chaining.
       */
      public Builder clearMaxSwapFee() {
        bitField0_ = (bitField0_ & ~0x00000002);
        maxSwapFee_ = 0L;
        onChanged();
        return this;
      }

      private long maxMinerFee_ ;
      /**
       * <pre>
       *
       *Maximum in on-chain fees that we are willing to spend. If we want to
       *publish the on-chain htlc and the fee estimate turns out higher than this
       *value, we cancel the swap.
       *
       *max_miner_fee is typically taken from the response of the GetQuote call.
       * </pre>
       *
       * <code>int64 max_miner_fee = 3 [jstype = JS_STRING];</code>
       * @return The maxMinerFee.
       */
      @java.lang.Override
      public long getMaxMinerFee() {
        return maxMinerFee_;
      }
      /**
       * <pre>
       *
       *Maximum in on-chain fees that we are willing to spend. If we want to
       *publish the on-chain htlc and the fee estimate turns out higher than this
       *value, we cancel the swap.
       *
       *max_miner_fee is typically taken from the response of the GetQuote call.
       * </pre>
       *
       * <code>int64 max_miner_fee = 3 [jstype = JS_STRING];</code>
       * @param value The maxMinerFee to set.
       * @return This builder for chaining.
       */
      public Builder setMaxMinerFee(long value) {

        maxMinerFee_ = value;
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }
      /**
       * <pre>
       *
       *Maximum in on-chain fees that we are willing to spend. If we want to
       *publish the on-chain htlc and the fee estimate turns out higher than this
       *value, we cancel the swap.
       *
       *max_miner_fee is typically taken from the response of the GetQuote call.
       * </pre>
       *
       * <code>int64 max_miner_fee = 3 [jstype = JS_STRING];</code>
       * @return This builder for chaining.
       */
      public Builder clearMaxMinerFee() {
        bitField0_ = (bitField0_ & ~0x00000004);
        maxMinerFee_ = 0L;
        onChanged();
        return this;
      }

      private com.google.protobuf.ByteString lastHop_ = com.google.protobuf.ByteString.EMPTY;
      /**
       * <pre>
       *
       *The last hop to use for the loop in swap. If empty, the last hop is selected
       *based on the lowest routing fee for the swap payment from the server.
       * </pre>
       *
       * <code>bytes last_hop = 4;</code>
       * @return The lastHop.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString getLastHop() {
        return lastHop_;
      }
      /**
       * <pre>
       *
       *The last hop to use for the loop in swap. If empty, the last hop is selected
       *based on the lowest routing fee for the swap payment from the server.
       * </pre>
       *
       * <code>bytes last_hop = 4;</code>
       * @param value The lastHop to set.
       * @return This builder for chaining.
       */
      public Builder setLastHop(com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        lastHop_ = value;
        bitField0_ |= 0x00000008;
        onChanged();
        return this;
      }
      /**
       * <pre>
       *
       *The last hop to use for the loop in swap. If empty, the last hop is selected
       *based on the lowest routing fee for the swap payment from the server.
       * </pre>
       *
       * <code>bytes last_hop = 4;</code>
       * @return This builder for chaining.
       */
      public Builder clearLastHop() {
        bitField0_ = (bitField0_ & ~0x00000008);
        lastHop_ = getDefaultInstance().getLastHop();
        onChanged();
        return this;
      }

      private boolean externalHtlc_ ;
      /**
       * <pre>
       *
       *If external_htlc is true, we expect the htlc to be published by an external
       *actor.
       * </pre>
       *
       * <code>bool external_htlc = 5;</code>
       * @return The externalHtlc.
       */
      @java.lang.Override
      public boolean getExternalHtlc() {
        return externalHtlc_;
      }
      /**
       * <pre>
       *
       *If external_htlc is true, we expect the htlc to be published by an external
       *actor.
       * </pre>
       *
       * <code>bool external_htlc = 5;</code>
       * @param value The externalHtlc to set.
       * @return This builder for chaining.
       */
      public Builder setExternalHtlc(boolean value) {

        externalHtlc_ = value;
        bitField0_ |= 0x00000010;
        onChanged();
        return this;
      }
      /**
       * <pre>
       *
       *If external_htlc is true, we expect the htlc to be published by an external
       *actor.
       * </pre>
       *
       * <code>bool external_htlc = 5;</code>
       * @return This builder for chaining.
       */
      public Builder clearExternalHtlc() {
        bitField0_ = (bitField0_ & ~0x00000010);
        externalHtlc_ = false;
        onChanged();
        return this;
      }

      private int htlcConfTarget_ ;
      /**
       * <pre>
       *
       *The number of blocks that the on chain htlc should confirm within.
       * </pre>
       *
       * <code>int32 htlc_conf_target = 6;</code>
       * @return The htlcConfTarget.
       */
      @java.lang.Override
      public int getHtlcConfTarget() {
        return htlcConfTarget_;
      }
      /**
       * <pre>
       *
       *The number of blocks that the on chain htlc should confirm within.
       * </pre>
       *
       * <code>int32 htlc_conf_target = 6;</code>
       * @param value The htlcConfTarget to set.
       * @return This builder for chaining.
       */
      public Builder setHtlcConfTarget(int value) {

        htlcConfTarget_ = value;
        bitField0_ |= 0x00000020;
        onChanged();
        return this;
      }
      /**
       * <pre>
       *
       *The number of blocks that the on chain htlc should confirm within.
       * </pre>
       *
       * <code>int32 htlc_conf_target = 6;</code>
       * @return This builder for chaining.
       */
      public Builder clearHtlcConfTarget() {
        bitField0_ = (bitField0_ & ~0x00000020);
        htlcConfTarget_ = 0;
        onChanged();
        return this;
      }

      private java.lang.Object label_ = "";
      /**
       * <pre>
       *
       *An optional label for this swap. This field is limited to 500 characters
       *and may not be one of the reserved values in loop/labels Reserved list.
       * </pre>
       *
       * <code>string label = 7;</code>
       * @return The label.
       */
      public java.lang.String getLabel() {
        java.lang.Object ref = label_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          label_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       *
       *An optional label for this swap. This field is limited to 500 characters
       *and may not be one of the reserved values in loop/labels Reserved list.
       * </pre>
       *
       * <code>string label = 7;</code>
       * @return The bytes for label.
       */
      public com.google.protobuf.ByteString
          getLabelBytes() {
        java.lang.Object ref = label_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          label_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       *
       *An optional label for this swap. This field is limited to 500 characters
       *and may not be one of the reserved values in loop/labels Reserved list.
       * </pre>
       *
       * <code>string label = 7;</code>
       * @param value The label to set.
       * @return This builder for chaining.
       */
      public Builder setLabel(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        label_ = value;
        bitField0_ |= 0x00000040;
        onChanged();
        return this;
      }
      /**
       * <pre>
       *
       *An optional label for this swap. This field is limited to 500 characters
       *and may not be one of the reserved values in loop/labels Reserved list.
       * </pre>
       *
       * <code>string label = 7;</code>
       * @return This builder for chaining.
       */
      public Builder clearLabel() {
        label_ = getDefaultInstance().getLabel();
        bitField0_ = (bitField0_ & ~0x00000040);
        onChanged();
        return this;
      }
      /**
       * <pre>
       *
       *An optional label for this swap. This field is limited to 500 characters
       *and may not be one of the reserved values in loop/labels Reserved list.
       * </pre>
       *
       * <code>string label = 7;</code>
       * @param value The bytes for label to set.
       * @return This builder for chaining.
       */
      public Builder setLabelBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        checkByteStringIsUtf8(value);
        label_ = value;
        bitField0_ |= 0x00000040;
        onChanged();
        return this;
      }

      private java.lang.Object initiator_ = "";
      /**
       * <pre>
       *
       *An optional identification string that will be appended to the user agent
       *string sent to the server to give information about the usage of loop. This
       *initiator part is meant for user interfaces to add their name to give the
       *full picture of the binary used (loopd, LiT) and the method used for
       *triggering the swap (loop CLI, autolooper, LiT UI, other 3rd party UI).
       * </pre>
       *
       * <code>string initiator = 8;</code>
       * @return The initiator.
       */
      public java.lang.String getInitiator() {
        java.lang.Object ref = initiator_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          initiator_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       *
       *An optional identification string that will be appended to the user agent
       *string sent to the server to give information about the usage of loop. This
       *initiator part is meant for user interfaces to add their name to give the
       *full picture of the binary used (loopd, LiT) and the method used for
       *triggering the swap (loop CLI, autolooper, LiT UI, other 3rd party UI).
       * </pre>
       *
       * <code>string initiator = 8;</code>
       * @return The bytes for initiator.
       */
      public com.google.protobuf.ByteString
          getInitiatorBytes() {
        java.lang.Object ref = initiator_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          initiator_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       *
       *An optional identification string that will be appended to the user agent
       *string sent to the server to give information about the usage of loop. This
       *initiator part is meant for user interfaces to add their name to give the
       *full picture of the binary used (loopd, LiT) and the method used for
       *triggering the swap (loop CLI, autolooper, LiT UI, other 3rd party UI).
       * </pre>
       *
       * <code>string initiator = 8;</code>
       * @param value The initiator to set.
       * @return This builder for chaining.
       */
      public Builder setInitiator(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        initiator_ = value;
        bitField0_ |= 0x00000080;
        onChanged();
        return this;
      }
      /**
       * <pre>
       *
       *An optional identification string that will be appended to the user agent
       *string sent to the server to give information about the usage of loop. This
       *initiator part is meant for user interfaces to add their name to give the
       *full picture of the binary used (loopd, LiT) and the method used for
       *triggering the swap (loop CLI, autolooper, LiT UI, other 3rd party UI).
       * </pre>
       *
       * <code>string initiator = 8;</code>
       * @return This builder for chaining.
       */
      public Builder clearInitiator() {
        initiator_ = getDefaultInstance().getInitiator();
        bitField0_ = (bitField0_ & ~0x00000080);
        onChanged();
        return this;
      }
      /**
       * <pre>
       *
       *An optional identification string that will be appended to the user agent
       *string sent to the server to give information about the usage of loop. This
       *initiator part is meant for user interfaces to add their name to give the
       *full picture of the binary used (loopd, LiT) and the method used for
       *triggering the swap (loop CLI, autolooper, LiT UI, other 3rd party UI).
       * </pre>
       *
       * <code>string initiator = 8;</code>
       * @param value The bytes for initiator to set.
       * @return This builder for chaining.
       */
      public Builder setInitiatorBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        checkByteStringIsUtf8(value);
        initiator_ = value;
        bitField0_ |= 0x00000080;
        onChanged();
        return this;
      }

      private java.util.List<looprpc.Common.RouteHint> routeHints_ =
        java.util.Collections.emptyList();
      private void ensureRouteHintsIsMutable() {
        if (!((bitField0_ & 0x00000100) != 0)) {
          routeHints_ = new java.util.ArrayList<looprpc.Common.RouteHint>(routeHints_);
          bitField0_ |= 0x00000100;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
          looprpc.Common.RouteHint, looprpc.Common.RouteHint.Builder, looprpc.Common.RouteHintOrBuilder> routeHintsBuilder_;

      /**
       * <pre>
       *
       *Optional route hints to reach the destination through private channels.
       * </pre>
       *
       * <code>repeated .looprpc.RouteHint route_hints = 9;</code>
       */
      public java.util.List<looprpc.Common.RouteHint> getRouteHintsList() {
        if (routeHintsBuilder_ == null) {
          return java.util.Collections.unmodifiableList(routeHints_);
        } else {
          return routeHintsBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       *
       *Optional route hints to reach the destination through private channels.
       * </pre>
       *
       * <code>repeated .looprpc.RouteHint route_hints = 9;</code>
       */
      public int getRouteHintsCount() {
        if (routeHintsBuilder_ == null) {
          return routeHints_.size();
        } else {
          return routeHintsBuilder_.getCount();
        }
      }
      /**
       * <pre>
       *
       *Optional route hints to reach the destination through private channels.
       * </pre>
       *
       * <code>repeated .looprpc.RouteHint route_hints = 9;</code>
       */
      public looprpc.Common.RouteHint getRouteHints(int index) {
        if (routeHintsBuilder_ == null) {
          return routeHints_.get(index);
        } else {
          return routeHintsBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       *
       *Optional route hints to reach the destination through private channels.
       * </pre>
       *
       * <code>repeated .looprpc.RouteHint route_hints = 9;</code>
       */
      public Builder setRouteHints(
          int index, looprpc.Common.RouteHint value) {
        if (routeHintsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureRouteHintsIsMutable();
          routeHints_.set(index, value);
          onChanged();
        } else {
          routeHintsBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       *
       *Optional route hints to reach the destination through private channels.
       * </pre>
       *
       * <code>repeated .looprpc.RouteHint route_hints = 9;</code>
       */
      public Builder setRouteHints(
          int index, looprpc.Common.RouteHint.Builder builderForValue) {
        if (routeHintsBuilder_ == null) {
          ensureRouteHintsIsMutable();
          routeHints_.set(index, builderForValue.build());
          onChanged();
        } else {
          routeHintsBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       *
       *Optional route hints to reach the destination through private channels.
       * </pre>
       *
       * <code>repeated .looprpc.RouteHint route_hints = 9;</code>
       */
      public Builder addRouteHints(looprpc.Common.RouteHint value) {
        if (routeHintsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureRouteHintsIsMutable();
          routeHints_.add(value);
          onChanged();
        } else {
          routeHintsBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       *
       *Optional route hints to reach the destination through private channels.
       * </pre>
       *
       * <code>repeated .looprpc.RouteHint route_hints = 9;</code>
       */
      public Builder addRouteHints(
          int index, looprpc.Common.RouteHint value) {
        if (routeHintsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureRouteHintsIsMutable();
          routeHints_.add(index, value);
          onChanged();
        } else {
          routeHintsBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       *
       *Optional route hints to reach the destination through private channels.
       * </pre>
       *
       * <code>repeated .looprpc.RouteHint route_hints = 9;</code>
       */
      public Builder addRouteHints(
          looprpc.Common.RouteHint.Builder builderForValue) {
        if (routeHintsBuilder_ == null) {
          ensureRouteHintsIsMutable();
          routeHints_.add(builderForValue.build());
          onChanged();
        } else {
          routeHintsBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       *
       *Optional route hints to reach the destination through private channels.
       * </pre>
       *
       * <code>repeated .looprpc.RouteHint route_hints = 9;</code>
       */
      public Builder addRouteHints(
          int index, looprpc.Common.RouteHint.Builder builderForValue) {
        if (routeHintsBuilder_ == null) {
          ensureRouteHintsIsMutable();
          routeHints_.add(index, builderForValue.build());
          onChanged();
        } else {
          routeHintsBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       *
       *Optional route hints to reach the destination through private channels.
       * </pre>
       *
       * <code>repeated .looprpc.RouteHint route_hints = 9;</code>
       */
      public Builder addAllRouteHints(
          java.lang.Iterable<? extends looprpc.Common.RouteHint> values) {
        if (routeHintsBuilder_ == null) {
          ensureRouteHintsIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, routeHints_);
          onChanged();
        } else {
          routeHintsBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       *
       *Optional route hints to reach the destination through private channels.
       * </pre>
       *
       * <code>repeated .looprpc.RouteHint route_hints = 9;</code>
       */
      public Builder clearRouteHints() {
        if (routeHintsBuilder_ == null) {
          routeHints_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000100);
          onChanged();
        } else {
          routeHintsBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       *
       *Optional route hints to reach the destination through private channels.
       * </pre>
       *
       * <code>repeated .looprpc.RouteHint route_hints = 9;</code>
       */
      public Builder removeRouteHints(int index) {
        if (routeHintsBuilder_ == null) {
          ensureRouteHintsIsMutable();
          routeHints_.remove(index);
          onChanged();
        } else {
          routeHintsBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       *
       *Optional route hints to reach the destination through private channels.
       * </pre>
       *
       * <code>repeated .looprpc.RouteHint route_hints = 9;</code>
       */
      public looprpc.Common.RouteHint.Builder getRouteHintsBuilder(
          int index) {
        return getRouteHintsFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       *
       *Optional route hints to reach the destination through private channels.
       * </pre>
       *
       * <code>repeated .looprpc.RouteHint route_hints = 9;</code>
       */
      public looprpc.Common.RouteHintOrBuilder getRouteHintsOrBuilder(
          int index) {
        if (routeHintsBuilder_ == null) {
          return routeHints_.get(index);  } else {
          return routeHintsBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       *
       *Optional route hints to reach the destination through private channels.
       * </pre>
       *
       * <code>repeated .looprpc.RouteHint route_hints = 9;</code>
       */
      public java.util.List<? extends looprpc.Common.RouteHintOrBuilder> 
           getRouteHintsOrBuilderList() {
        if (routeHintsBuilder_ != null) {
          return routeHintsBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(routeHints_);
        }
      }
      /**
       * <pre>
       *
       *Optional route hints to reach the destination through private channels.
       * </pre>
       *
       * <code>repeated .looprpc.RouteHint route_hints = 9;</code>
       */
      public looprpc.Common.RouteHint.Builder addRouteHintsBuilder() {
        return getRouteHintsFieldBuilder().addBuilder(
            looprpc.Common.RouteHint.getDefaultInstance());
      }
      /**
       * <pre>
       *
       *Optional route hints to reach the destination through private channels.
       * </pre>
       *
       * <code>repeated .looprpc.RouteHint route_hints = 9;</code>
       */
      public looprpc.Common.RouteHint.Builder addRouteHintsBuilder(
          int index) {
        return getRouteHintsFieldBuilder().addBuilder(
            index, looprpc.Common.RouteHint.getDefaultInstance());
      }
      /**
       * <pre>
       *
       *Optional route hints to reach the destination through private channels.
       * </pre>
       *
       * <code>repeated .looprpc.RouteHint route_hints = 9;</code>
       */
      public java.util.List<looprpc.Common.RouteHint.Builder> 
           getRouteHintsBuilderList() {
        return getRouteHintsFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilderV3<
          looprpc.Common.RouteHint, looprpc.Common.RouteHint.Builder, looprpc.Common.RouteHintOrBuilder> 
          getRouteHintsFieldBuilder() {
        if (routeHintsBuilder_ == null) {
          routeHintsBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<
              looprpc.Common.RouteHint, looprpc.Common.RouteHint.Builder, looprpc.Common.RouteHintOrBuilder>(
                  routeHints_,
                  ((bitField0_ & 0x00000100) != 0),
                  getParentForChildren(),
                  isClean());
          routeHints_ = null;
        }
        return routeHintsBuilder_;
      }

      private boolean private_ ;
      /**
       * <pre>
       *
       *Private indicates whether the destination node should be considered
       *private. In which case, loop will generate hophints to assist with
       *probing and payment.
       * </pre>
       *
       * <code>bool private = 10;</code>
       * @return The private.
       */
      @java.lang.Override
      public boolean getPrivate() {
        return private_;
      }
      /**
       * <pre>
       *
       *Private indicates whether the destination node should be considered
       *private. In which case, loop will generate hophints to assist with
       *probing and payment.
       * </pre>
       *
       * <code>bool private = 10;</code>
       * @param value The private to set.
       * @return This builder for chaining.
       */
      public Builder setPrivate(boolean value) {

        private_ = value;
        bitField0_ |= 0x00000200;
        onChanged();
        return this;
      }
      /**
       * <pre>
       *
       *Private indicates whether the destination node should be considered
       *private. In which case, loop will generate hophints to assist with
       *probing and payment.
       * </pre>
       *
       * <code>bool private = 10;</code>
       * @return This builder for chaining.
       */
      public Builder clearPrivate() {
        bitField0_ = (bitField0_ & ~0x00000200);
        private_ = false;
        onChanged();
        return this;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:looprpc.LoopInRequest)
    }

    // @@protoc_insertion_point(class_scope:looprpc.LoopInRequest)
    private static final looprpc.Loop.LoopInRequest DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new looprpc.Loop.LoopInRequest();
    }

    public static looprpc.Loop.LoopInRequest getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<LoopInRequest>
        PARSER = new com.google.protobuf.AbstractParser<LoopInRequest>() {
      @java.lang.Override
      public LoopInRequest parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<LoopInRequest> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<LoopInRequest> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public looprpc.Loop.LoopInRequest getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface SwapResponseOrBuilder extends
      // @@protoc_insertion_point(interface_extends:looprpc.SwapResponse)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     *
     *Swap identifier to track status in the update stream that is returned from
     *the Start() call. Currently this is the hash that locks the htlcs.
     * </pre>
     *
     * <code>bytes id_bytes = 3;</code>
     * @return The idBytes.
     */
    com.google.protobuf.ByteString getIdBytes();

    /**
     * <pre>
     *
     *DEPRECATED. This field stores the address of the onchain htlc, but
     *depending on the request, the semantics are different.
     *- For internal loop-in htlc_address contains the address of the
     *native segwit (P2WSH) htlc.
     * /    - For loop-out htlc_address always contains the native segwit (P2WSH)
     *htlc address.
     * </pre>
     *
     * <code>string htlc_address = 2 [deprecated = true];</code>
     * @deprecated looprpc.SwapResponse.htlc_address is deprecated.
     *     See loop.proto;l=328
     * @return The htlcAddress.
     */
    @java.lang.Deprecated java.lang.String getHtlcAddress();
    /**
     * <pre>
     *
     *DEPRECATED. This field stores the address of the onchain htlc, but
     *depending on the request, the semantics are different.
     *- For internal loop-in htlc_address contains the address of the
     *native segwit (P2WSH) htlc.
     * /    - For loop-out htlc_address always contains the native segwit (P2WSH)
     *htlc address.
     * </pre>
     *
     * <code>string htlc_address = 2 [deprecated = true];</code>
     * @deprecated looprpc.SwapResponse.htlc_address is deprecated.
     *     See loop.proto;l=328
     * @return The bytes for htlcAddress.
     */
    @java.lang.Deprecated com.google.protobuf.ByteString
        getHtlcAddressBytes();

    /**
     * <pre>
     *
     *The native segwit address of the on-chain htlc.
     *Used for both loop-in and loop-out.
     * </pre>
     *
     * <code>string htlc_address_p2wsh = 5;</code>
     * @return The htlcAddressP2wsh.
     */
    java.lang.String getHtlcAddressP2Wsh();
    /**
     * <pre>
     *
     *The native segwit address of the on-chain htlc.
     *Used for both loop-in and loop-out.
     * </pre>
     *
     * <code>string htlc_address_p2wsh = 5;</code>
     * @return The bytes for htlcAddressP2wsh.
     */
    com.google.protobuf.ByteString
        getHtlcAddressP2WshBytes();

    /**
     * <pre>
     * The address of the v3 (taproot) htlc. Used for both loop-in and loop-out.
     * </pre>
     *
     * <code>string htlc_address_p2tr = 7;</code>
     * @return The htlcAddressP2tr.
     */
    java.lang.String getHtlcAddressP2Tr();
    /**
     * <pre>
     * The address of the v3 (taproot) htlc. Used for both loop-in and loop-out.
     * </pre>
     *
     * <code>string htlc_address_p2tr = 7;</code>
     * @return The bytes for htlcAddressP2tr.
     */
    com.google.protobuf.ByteString
        getHtlcAddressP2TrBytes();

    /**
     * <pre>
     * A human-readable message received from the loop server.
     * </pre>
     *
     * <code>string server_message = 6;</code>
     * @return The serverMessage.
     */
    java.lang.String getServerMessage();
    /**
     * <pre>
     * A human-readable message received from the loop server.
     * </pre>
     *
     * <code>string server_message = 6;</code>
     * @return The bytes for serverMessage.
     */
    com.google.protobuf.ByteString
        getServerMessageBytes();
  }
  /**
   * Protobuf type {@code looprpc.SwapResponse}
   */
  public static final class SwapResponse extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:looprpc.SwapResponse)
      SwapResponseOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use SwapResponse.newBuilder() to construct.
    private SwapResponse(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private SwapResponse() {
      idBytes_ = com.google.protobuf.ByteString.EMPTY;
      htlcAddress_ = "";
      htlcAddressP2Wsh_ = "";
      htlcAddressP2Tr_ = "";
      serverMessage_ = "";
    }

    @java.lang.Override
    @SuppressWarnings({"unused"})
    protected java.lang.Object newInstance(
        UnusedPrivateParameter unused) {
      return new SwapResponse();
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return looprpc.Loop.internal_static_looprpc_SwapResponse_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return looprpc.Loop.internal_static_looprpc_SwapResponse_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              looprpc.Loop.SwapResponse.class, looprpc.Loop.SwapResponse.Builder.class);
    }

    public static final int ID_BYTES_FIELD_NUMBER = 3;
    private com.google.protobuf.ByteString idBytes_ = com.google.protobuf.ByteString.EMPTY;
    /**
     * <pre>
     *
     *Swap identifier to track status in the update stream that is returned from
     *the Start() call. Currently this is the hash that locks the htlcs.
     * </pre>
     *
     * <code>bytes id_bytes = 3;</code>
     * @return The idBytes.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString getIdBytes() {
      return idBytes_;
    }

    public static final int HTLC_ADDRESS_FIELD_NUMBER = 2;
    @SuppressWarnings("serial")
    private volatile java.lang.Object htlcAddress_ = "";
    /**
     * <pre>
     *
     *DEPRECATED. This field stores the address of the onchain htlc, but
     *depending on the request, the semantics are different.
     *- For internal loop-in htlc_address contains the address of the
     *native segwit (P2WSH) htlc.
     * /    - For loop-out htlc_address always contains the native segwit (P2WSH)
     *htlc address.
     * </pre>
     *
     * <code>string htlc_address = 2 [deprecated = true];</code>
     * @deprecated looprpc.SwapResponse.htlc_address is deprecated.
     *     See loop.proto;l=328
     * @return The htlcAddress.
     */
    @java.lang.Override
    @java.lang.Deprecated public java.lang.String getHtlcAddress() {
      java.lang.Object ref = htlcAddress_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        htlcAddress_ = s;
        return s;
      }
    }
    /**
     * <pre>
     *
     *DEPRECATED. This field stores the address of the onchain htlc, but
     *depending on the request, the semantics are different.
     *- For internal loop-in htlc_address contains the address of the
     *native segwit (P2WSH) htlc.
     * /    - For loop-out htlc_address always contains the native segwit (P2WSH)
     *htlc address.
     * </pre>
     *
     * <code>string htlc_address = 2 [deprecated = true];</code>
     * @deprecated looprpc.SwapResponse.htlc_address is deprecated.
     *     See loop.proto;l=328
     * @return The bytes for htlcAddress.
     */
    @java.lang.Override
    @java.lang.Deprecated public com.google.protobuf.ByteString
        getHtlcAddressBytes() {
      java.lang.Object ref = htlcAddress_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        htlcAddress_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int HTLC_ADDRESS_P2WSH_FIELD_NUMBER = 5;
    @SuppressWarnings("serial")
    private volatile java.lang.Object htlcAddressP2Wsh_ = "";
    /**
     * <pre>
     *
     *The native segwit address of the on-chain htlc.
     *Used for both loop-in and loop-out.
     * </pre>
     *
     * <code>string htlc_address_p2wsh = 5;</code>
     * @return The htlcAddressP2wsh.
     */
    @java.lang.Override
    public java.lang.String getHtlcAddressP2Wsh() {
      java.lang.Object ref = htlcAddressP2Wsh_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        htlcAddressP2Wsh_ = s;
        return s;
      }
    }
    /**
     * <pre>
     *
     *The native segwit address of the on-chain htlc.
     *Used for both loop-in and loop-out.
     * </pre>
     *
     * <code>string htlc_address_p2wsh = 5;</code>
     * @return The bytes for htlcAddressP2wsh.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getHtlcAddressP2WshBytes() {
      java.lang.Object ref = htlcAddressP2Wsh_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        htlcAddressP2Wsh_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int HTLC_ADDRESS_P2TR_FIELD_NUMBER = 7;
    @SuppressWarnings("serial")
    private volatile java.lang.Object htlcAddressP2Tr_ = "";
    /**
     * <pre>
     * The address of the v3 (taproot) htlc. Used for both loop-in and loop-out.
     * </pre>
     *
     * <code>string htlc_address_p2tr = 7;</code>
     * @return The htlcAddressP2tr.
     */
    @java.lang.Override
    public java.lang.String getHtlcAddressP2Tr() {
      java.lang.Object ref = htlcAddressP2Tr_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        htlcAddressP2Tr_ = s;
        return s;
      }
    }
    /**
     * <pre>
     * The address of the v3 (taproot) htlc. Used for both loop-in and loop-out.
     * </pre>
     *
     * <code>string htlc_address_p2tr = 7;</code>
     * @return The bytes for htlcAddressP2tr.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getHtlcAddressP2TrBytes() {
      java.lang.Object ref = htlcAddressP2Tr_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        htlcAddressP2Tr_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int SERVER_MESSAGE_FIELD_NUMBER = 6;
    @SuppressWarnings("serial")
    private volatile java.lang.Object serverMessage_ = "";
    /**
     * <pre>
     * A human-readable message received from the loop server.
     * </pre>
     *
     * <code>string server_message = 6;</code>
     * @return The serverMessage.
     */
    @java.lang.Override
    public java.lang.String getServerMessage() {
      java.lang.Object ref = serverMessage_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        serverMessage_ = s;
        return s;
      }
    }
    /**
     * <pre>
     * A human-readable message received from the loop server.
     * </pre>
     *
     * <code>string server_message = 6;</code>
     * @return The bytes for serverMessage.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getServerMessageBytes() {
      java.lang.Object ref = serverMessage_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        serverMessage_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(htlcAddress_)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 2, htlcAddress_);
      }
      if (!idBytes_.isEmpty()) {
        output.writeBytes(3, idBytes_);
      }
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(htlcAddressP2Wsh_)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 5, htlcAddressP2Wsh_);
      }
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(serverMessage_)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 6, serverMessage_);
      }
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(htlcAddressP2Tr_)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 7, htlcAddressP2Tr_);
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(htlcAddress_)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(2, htlcAddress_);
      }
      if (!idBytes_.isEmpty()) {
        size += com.google.protobuf.CodedOutputStream
          .computeBytesSize(3, idBytes_);
      }
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(htlcAddressP2Wsh_)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(5, htlcAddressP2Wsh_);
      }
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(serverMessage_)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(6, serverMessage_);
      }
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(htlcAddressP2Tr_)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(7, htlcAddressP2Tr_);
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof looprpc.Loop.SwapResponse)) {
        return super.equals(obj);
      }
      looprpc.Loop.SwapResponse other = (looprpc.Loop.SwapResponse) obj;

      if (!getIdBytes()
          .equals(other.getIdBytes())) return false;
      if (!getHtlcAddress()
          .equals(other.getHtlcAddress())) return false;
      if (!getHtlcAddressP2Wsh()
          .equals(other.getHtlcAddressP2Wsh())) return false;
      if (!getHtlcAddressP2Tr()
          .equals(other.getHtlcAddressP2Tr())) return false;
      if (!getServerMessage()
          .equals(other.getServerMessage())) return false;
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      hash = (37 * hash) + ID_BYTES_FIELD_NUMBER;
      hash = (53 * hash) + getIdBytes().hashCode();
      hash = (37 * hash) + HTLC_ADDRESS_FIELD_NUMBER;
      hash = (53 * hash) + getHtlcAddress().hashCode();
      hash = (37 * hash) + HTLC_ADDRESS_P2WSH_FIELD_NUMBER;
      hash = (53 * hash) + getHtlcAddressP2Wsh().hashCode();
      hash = (37 * hash) + HTLC_ADDRESS_P2TR_FIELD_NUMBER;
      hash = (53 * hash) + getHtlcAddressP2Tr().hashCode();
      hash = (37 * hash) + SERVER_MESSAGE_FIELD_NUMBER;
      hash = (53 * hash) + getServerMessage().hashCode();
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static looprpc.Loop.SwapResponse parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static looprpc.Loop.SwapResponse parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static looprpc.Loop.SwapResponse parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static looprpc.Loop.SwapResponse parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static looprpc.Loop.SwapResponse parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static looprpc.Loop.SwapResponse parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static looprpc.Loop.SwapResponse parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static looprpc.Loop.SwapResponse parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static looprpc.Loop.SwapResponse parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static looprpc.Loop.SwapResponse parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static looprpc.Loop.SwapResponse parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static looprpc.Loop.SwapResponse parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(looprpc.Loop.SwapResponse prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * Protobuf type {@code looprpc.SwapResponse}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:looprpc.SwapResponse)
        looprpc.Loop.SwapResponseOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return looprpc.Loop.internal_static_looprpc_SwapResponse_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return looprpc.Loop.internal_static_looprpc_SwapResponse_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                looprpc.Loop.SwapResponse.class, looprpc.Loop.SwapResponse.Builder.class);
      }

      // Construct using looprpc.Loop.SwapResponse.newBuilder()
      private Builder() {

      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);

      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        idBytes_ = com.google.protobuf.ByteString.EMPTY;
        htlcAddress_ = "";
        htlcAddressP2Wsh_ = "";
        htlcAddressP2Tr_ = "";
        serverMessage_ = "";
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return looprpc.Loop.internal_static_looprpc_SwapResponse_descriptor;
      }

      @java.lang.Override
      public looprpc.Loop.SwapResponse getDefaultInstanceForType() {
        return looprpc.Loop.SwapResponse.getDefaultInstance();
      }

      @java.lang.Override
      public looprpc.Loop.SwapResponse build() {
        looprpc.Loop.SwapResponse result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public looprpc.Loop.SwapResponse buildPartial() {
        looprpc.Loop.SwapResponse result = new looprpc.Loop.SwapResponse(this);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartial0(looprpc.Loop.SwapResponse result) {
        int from_bitField0_ = bitField0_;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.idBytes_ = idBytes_;
        }
        if (((from_bitField0_ & 0x00000002) != 0)) {
          result.htlcAddress_ = htlcAddress_;
        }
        if (((from_bitField0_ & 0x00000004) != 0)) {
          result.htlcAddressP2Wsh_ = htlcAddressP2Wsh_;
        }
        if (((from_bitField0_ & 0x00000008) != 0)) {
          result.htlcAddressP2Tr_ = htlcAddressP2Tr_;
        }
        if (((from_bitField0_ & 0x00000010) != 0)) {
          result.serverMessage_ = serverMessage_;
        }
      }

      @java.lang.Override
      public Builder clone() {
        return super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof looprpc.Loop.SwapResponse) {
          return mergeFrom((looprpc.Loop.SwapResponse)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(looprpc.Loop.SwapResponse other) {
        if (other == looprpc.Loop.SwapResponse.getDefaultInstance()) return this;
        if (other.getIdBytes() != com.google.protobuf.ByteString.EMPTY) {
          setIdBytes(other.getIdBytes());
        }
        if (!other.getHtlcAddress().isEmpty()) {
          htlcAddress_ = other.htlcAddress_;
          bitField0_ |= 0x00000002;
          onChanged();
        }
        if (!other.getHtlcAddressP2Wsh().isEmpty()) {
          htlcAddressP2Wsh_ = other.htlcAddressP2Wsh_;
          bitField0_ |= 0x00000004;
          onChanged();
        }
        if (!other.getHtlcAddressP2Tr().isEmpty()) {
          htlcAddressP2Tr_ = other.htlcAddressP2Tr_;
          bitField0_ |= 0x00000008;
          onChanged();
        }
        if (!other.getServerMessage().isEmpty()) {
          serverMessage_ = other.serverMessage_;
          bitField0_ |= 0x00000010;
          onChanged();
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 18: {
                htlcAddress_ = input.readStringRequireUtf8();
                bitField0_ |= 0x00000002;
                break;
              } // case 18
              case 26: {
                idBytes_ = input.readBytes();
                bitField0_ |= 0x00000001;
                break;
              } // case 26
              case 42: {
                htlcAddressP2Wsh_ = input.readStringRequireUtf8();
                bitField0_ |= 0x00000004;
                break;
              } // case 42
              case 50: {
                serverMessage_ = input.readStringRequireUtf8();
                bitField0_ |= 0x00000010;
                break;
              } // case 50
              case 58: {
                htlcAddressP2Tr_ = input.readStringRequireUtf8();
                bitField0_ |= 0x00000008;
                break;
              } // case 58
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private com.google.protobuf.ByteString idBytes_ = com.google.protobuf.ByteString.EMPTY;
      /**
       * <pre>
       *
       *Swap identifier to track status in the update stream that is returned from
       *the Start() call. Currently this is the hash that locks the htlcs.
       * </pre>
       *
       * <code>bytes id_bytes = 3;</code>
       * @return The idBytes.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString getIdBytes() {
        return idBytes_;
      }
      /**
       * <pre>
       *
       *Swap identifier to track status in the update stream that is returned from
       *the Start() call. Currently this is the hash that locks the htlcs.
       * </pre>
       *
       * <code>bytes id_bytes = 3;</code>
       * @param value The idBytes to set.
       * @return This builder for chaining.
       */
      public Builder setIdBytes(com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        idBytes_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       *
       *Swap identifier to track status in the update stream that is returned from
       *the Start() call. Currently this is the hash that locks the htlcs.
       * </pre>
       *
       * <code>bytes id_bytes = 3;</code>
       * @return This builder for chaining.
       */
      public Builder clearIdBytes() {
        bitField0_ = (bitField0_ & ~0x00000001);
        idBytes_ = getDefaultInstance().getIdBytes();
        onChanged();
        return this;
      }

      private java.lang.Object htlcAddress_ = "";
      /**
       * <pre>
       *
       *DEPRECATED. This field stores the address of the onchain htlc, but
       *depending on the request, the semantics are different.
       *- For internal loop-in htlc_address contains the address of the
       *native segwit (P2WSH) htlc.
       * /    - For loop-out htlc_address always contains the native segwit (P2WSH)
       *htlc address.
       * </pre>
       *
       * <code>string htlc_address = 2 [deprecated = true];</code>
       * @deprecated looprpc.SwapResponse.htlc_address is deprecated.
       *     See loop.proto;l=328
       * @return The htlcAddress.
       */
      @java.lang.Deprecated public java.lang.String getHtlcAddress() {
        java.lang.Object ref = htlcAddress_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          htlcAddress_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       *
       *DEPRECATED. This field stores the address of the onchain htlc, but
       *depending on the request, the semantics are different.
       *- For internal loop-in htlc_address contains the address of the
       *native segwit (P2WSH) htlc.
       * /    - For loop-out htlc_address always contains the native segwit (P2WSH)
       *htlc address.
       * </pre>
       *
       * <code>string htlc_address = 2 [deprecated = true];</code>
       * @deprecated looprpc.SwapResponse.htlc_address is deprecated.
       *     See loop.proto;l=328
       * @return The bytes for htlcAddress.
       */
      @java.lang.Deprecated public com.google.protobuf.ByteString
          getHtlcAddressBytes() {
        java.lang.Object ref = htlcAddress_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          htlcAddress_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       *
       *DEPRECATED. This field stores the address of the onchain htlc, but
       *depending on the request, the semantics are different.
       *- For internal loop-in htlc_address contains the address of the
       *native segwit (P2WSH) htlc.
       * /    - For loop-out htlc_address always contains the native segwit (P2WSH)
       *htlc address.
       * </pre>
       *
       * <code>string htlc_address = 2 [deprecated = true];</code>
       * @deprecated looprpc.SwapResponse.htlc_address is deprecated.
       *     See loop.proto;l=328
       * @param value The htlcAddress to set.
       * @return This builder for chaining.
       */
      @java.lang.Deprecated public Builder setHtlcAddress(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        htlcAddress_ = value;
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       *
       *DEPRECATED. This field stores the address of the onchain htlc, but
       *depending on the request, the semantics are different.
       *- For internal loop-in htlc_address contains the address of the
       *native segwit (P2WSH) htlc.
       * /    - For loop-out htlc_address always contains the native segwit (P2WSH)
       *htlc address.
       * </pre>
       *
       * <code>string htlc_address = 2 [deprecated = true];</code>
       * @deprecated looprpc.SwapResponse.htlc_address is deprecated.
       *     See loop.proto;l=328
       * @return This builder for chaining.
       */
      @java.lang.Deprecated public Builder clearHtlcAddress() {
        htlcAddress_ = getDefaultInstance().getHtlcAddress();
        bitField0_ = (bitField0_ & ~0x00000002);
        onChanged();
        return this;
      }
      /**
       * <pre>
       *
       *DEPRECATED. This field stores the address of the onchain htlc, but
       *depending on the request, the semantics are different.
       *- For internal loop-in htlc_address contains the address of the
       *native segwit (P2WSH) htlc.
       * /    - For loop-out htlc_address always contains the native segwit (P2WSH)
       *htlc address.
       * </pre>
       *
       * <code>string htlc_address = 2 [deprecated = true];</code>
       * @deprecated looprpc.SwapResponse.htlc_address is deprecated.
       *     See loop.proto;l=328
       * @param value The bytes for htlcAddress to set.
       * @return This builder for chaining.
       */
      @java.lang.Deprecated public Builder setHtlcAddressBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        checkByteStringIsUtf8(value);
        htlcAddress_ = value;
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }

      private java.lang.Object htlcAddressP2Wsh_ = "";
      /**
       * <pre>
       *
       *The native segwit address of the on-chain htlc.
       *Used for both loop-in and loop-out.
       * </pre>
       *
       * <code>string htlc_address_p2wsh = 5;</code>
       * @return The htlcAddressP2wsh.
       */
      public java.lang.String getHtlcAddressP2Wsh() {
        java.lang.Object ref = htlcAddressP2Wsh_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          htlcAddressP2Wsh_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       *
       *The native segwit address of the on-chain htlc.
       *Used for both loop-in and loop-out.
       * </pre>
       *
       * <code>string htlc_address_p2wsh = 5;</code>
       * @return The bytes for htlcAddressP2wsh.
       */
      public com.google.protobuf.ByteString
          getHtlcAddressP2WshBytes() {
        java.lang.Object ref = htlcAddressP2Wsh_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          htlcAddressP2Wsh_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       *
       *The native segwit address of the on-chain htlc.
       *Used for both loop-in and loop-out.
       * </pre>
       *
       * <code>string htlc_address_p2wsh = 5;</code>
       * @param value The htlcAddressP2wsh to set.
       * @return This builder for chaining.
       */
      public Builder setHtlcAddressP2Wsh(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        htlcAddressP2Wsh_ = value;
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }
      /**
       * <pre>
       *
       *The native segwit address of the on-chain htlc.
       *Used for both loop-in and loop-out.
       * </pre>
       *
       * <code>string htlc_address_p2wsh = 5;</code>
       * @return This builder for chaining.
       */
      public Builder clearHtlcAddressP2Wsh() {
        htlcAddressP2Wsh_ = getDefaultInstance().getHtlcAddressP2Wsh();
        bitField0_ = (bitField0_ & ~0x00000004);
        onChanged();
        return this;
      }
      /**
       * <pre>
       *
       *The native segwit address of the on-chain htlc.
       *Used for both loop-in and loop-out.
       * </pre>
       *
       * <code>string htlc_address_p2wsh = 5;</code>
       * @param value The bytes for htlcAddressP2wsh to set.
       * @return This builder for chaining.
       */
      public Builder setHtlcAddressP2WshBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        checkByteStringIsUtf8(value);
        htlcAddressP2Wsh_ = value;
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }

      private java.lang.Object htlcAddressP2Tr_ = "";
      /**
       * <pre>
       * The address of the v3 (taproot) htlc. Used for both loop-in and loop-out.
       * </pre>
       *
       * <code>string htlc_address_p2tr = 7;</code>
       * @return The htlcAddressP2tr.
       */
      public java.lang.String getHtlcAddressP2Tr() {
        java.lang.Object ref = htlcAddressP2Tr_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          htlcAddressP2Tr_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * The address of the v3 (taproot) htlc. Used for both loop-in and loop-out.
       * </pre>
       *
       * <code>string htlc_address_p2tr = 7;</code>
       * @return The bytes for htlcAddressP2tr.
       */
      public com.google.protobuf.ByteString
          getHtlcAddressP2TrBytes() {
        java.lang.Object ref = htlcAddressP2Tr_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          htlcAddressP2Tr_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * The address of the v3 (taproot) htlc. Used for both loop-in and loop-out.
       * </pre>
       *
       * <code>string htlc_address_p2tr = 7;</code>
       * @param value The htlcAddressP2tr to set.
       * @return This builder for chaining.
       */
      public Builder setHtlcAddressP2Tr(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        htlcAddressP2Tr_ = value;
        bitField0_ |= 0x00000008;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The address of the v3 (taproot) htlc. Used for both loop-in and loop-out.
       * </pre>
       *
       * <code>string htlc_address_p2tr = 7;</code>
       * @return This builder for chaining.
       */
      public Builder clearHtlcAddressP2Tr() {
        htlcAddressP2Tr_ = getDefaultInstance().getHtlcAddressP2Tr();
        bitField0_ = (bitField0_ & ~0x00000008);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The address of the v3 (taproot) htlc. Used for both loop-in and loop-out.
       * </pre>
       *
       * <code>string htlc_address_p2tr = 7;</code>
       * @param value The bytes for htlcAddressP2tr to set.
       * @return This builder for chaining.
       */
      public Builder setHtlcAddressP2TrBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        checkByteStringIsUtf8(value);
        htlcAddressP2Tr_ = value;
        bitField0_ |= 0x00000008;
        onChanged();
        return this;
      }

      private java.lang.Object serverMessage_ = "";
      /**
       * <pre>
       * A human-readable message received from the loop server.
       * </pre>
       *
       * <code>string server_message = 6;</code>
       * @return The serverMessage.
       */
      public java.lang.String getServerMessage() {
        java.lang.Object ref = serverMessage_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          serverMessage_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * A human-readable message received from the loop server.
       * </pre>
       *
       * <code>string server_message = 6;</code>
       * @return The bytes for serverMessage.
       */
      public com.google.protobuf.ByteString
          getServerMessageBytes() {
        java.lang.Object ref = serverMessage_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          serverMessage_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * A human-readable message received from the loop server.
       * </pre>
       *
       * <code>string server_message = 6;</code>
       * @param value The serverMessage to set.
       * @return This builder for chaining.
       */
      public Builder setServerMessage(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        serverMessage_ = value;
        bitField0_ |= 0x00000010;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * A human-readable message received from the loop server.
       * </pre>
       *
       * <code>string server_message = 6;</code>
       * @return This builder for chaining.
       */
      public Builder clearServerMessage() {
        serverMessage_ = getDefaultInstance().getServerMessage();
        bitField0_ = (bitField0_ & ~0x00000010);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * A human-readable message received from the loop server.
       * </pre>
       *
       * <code>string server_message = 6;</code>
       * @param value The bytes for serverMessage to set.
       * @return This builder for chaining.
       */
      public Builder setServerMessageBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        checkByteStringIsUtf8(value);
        serverMessage_ = value;
        bitField0_ |= 0x00000010;
        onChanged();
        return this;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:looprpc.SwapResponse)
    }

    // @@protoc_insertion_point(class_scope:looprpc.SwapResponse)
    private static final looprpc.Loop.SwapResponse DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new looprpc.Loop.SwapResponse();
    }

    public static looprpc.Loop.SwapResponse getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<SwapResponse>
        PARSER = new com.google.protobuf.AbstractParser<SwapResponse>() {
      @java.lang.Override
      public SwapResponse parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<SwapResponse> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<SwapResponse> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public looprpc.Loop.SwapResponse getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface MonitorRequestOrBuilder extends
      // @@protoc_insertion_point(interface_extends:looprpc.MonitorRequest)
      com.google.protobuf.MessageOrBuilder {
  }
  /**
   * Protobuf type {@code looprpc.MonitorRequest}
   */
  public static final class MonitorRequest extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:looprpc.MonitorRequest)
      MonitorRequestOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use MonitorRequest.newBuilder() to construct.
    private MonitorRequest(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private MonitorRequest() {
    }

    @java.lang.Override
    @SuppressWarnings({"unused"})
    protected java.lang.Object newInstance(
        UnusedPrivateParameter unused) {
      return new MonitorRequest();
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return looprpc.Loop.internal_static_looprpc_MonitorRequest_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return looprpc.Loop.internal_static_looprpc_MonitorRequest_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              looprpc.Loop.MonitorRequest.class, looprpc.Loop.MonitorRequest.Builder.class);
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof looprpc.Loop.MonitorRequest)) {
        return super.equals(obj);
      }
      looprpc.Loop.MonitorRequest other = (looprpc.Loop.MonitorRequest) obj;

      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static looprpc.Loop.MonitorRequest parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static looprpc.Loop.MonitorRequest parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static looprpc.Loop.MonitorRequest parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static looprpc.Loop.MonitorRequest parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static looprpc.Loop.MonitorRequest parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static looprpc.Loop.MonitorRequest parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static looprpc.Loop.MonitorRequest parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static looprpc.Loop.MonitorRequest parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static looprpc.Loop.MonitorRequest parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static looprpc.Loop.MonitorRequest parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static looprpc.Loop.MonitorRequest parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static looprpc.Loop.MonitorRequest parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(looprpc.Loop.MonitorRequest prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * Protobuf type {@code looprpc.MonitorRequest}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:looprpc.MonitorRequest)
        looprpc.Loop.MonitorRequestOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return looprpc.Loop.internal_static_looprpc_MonitorRequest_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return looprpc.Loop.internal_static_looprpc_MonitorRequest_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                looprpc.Loop.MonitorRequest.class, looprpc.Loop.MonitorRequest.Builder.class);
      }

      // Construct using looprpc.Loop.MonitorRequest.newBuilder()
      private Builder() {

      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);

      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return looprpc.Loop.internal_static_looprpc_MonitorRequest_descriptor;
      }

      @java.lang.Override
      public looprpc.Loop.MonitorRequest getDefaultInstanceForType() {
        return looprpc.Loop.MonitorRequest.getDefaultInstance();
      }

      @java.lang.Override
      public looprpc.Loop.MonitorRequest build() {
        looprpc.Loop.MonitorRequest result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public looprpc.Loop.MonitorRequest buildPartial() {
        looprpc.Loop.MonitorRequest result = new looprpc.Loop.MonitorRequest(this);
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof looprpc.Loop.MonitorRequest) {
          return mergeFrom((looprpc.Loop.MonitorRequest)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(looprpc.Loop.MonitorRequest other) {
        if (other == looprpc.Loop.MonitorRequest.getDefaultInstance()) return this;
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:looprpc.MonitorRequest)
    }

    // @@protoc_insertion_point(class_scope:looprpc.MonitorRequest)
    private static final looprpc.Loop.MonitorRequest DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new looprpc.Loop.MonitorRequest();
    }

    public static looprpc.Loop.MonitorRequest getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<MonitorRequest>
        PARSER = new com.google.protobuf.AbstractParser<MonitorRequest>() {
      @java.lang.Override
      public MonitorRequest parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<MonitorRequest> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<MonitorRequest> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public looprpc.Loop.MonitorRequest getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface SwapStatusOrBuilder extends
      // @@protoc_insertion_point(interface_extends:looprpc.SwapStatus)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     *
     *Requested swap amount in sat. This does not include the swap and miner
     *fee.
     * </pre>
     *
     * <code>int64 amt = 1 [jstype = JS_STRING];</code>
     * @return The amt.
     */
    long getAmt();

    /**
     * <pre>
     *
     *Swap identifier to track status in the update stream that is returned from
     *the Start() call. Currently this is the hash that locks the htlcs.
     * </pre>
     *
     * <code>bytes id_bytes = 11;</code>
     * @return The idBytes.
     */
    com.google.protobuf.ByteString getIdBytes();

    /**
     * <pre>
     *
     *The type of the swap.
     * </pre>
     *
     * <code>.looprpc.SwapType type = 3;</code>
     * @return The enum numeric value on the wire for type.
     */
    int getTypeValue();
    /**
     * <pre>
     *
     *The type of the swap.
     * </pre>
     *
     * <code>.looprpc.SwapType type = 3;</code>
     * @return The type.
     */
    looprpc.Loop.SwapType getType();

    /**
     * <pre>
     *
     *State the swap is currently in, see State enum.
     * </pre>
     *
     * <code>.looprpc.SwapState state = 4;</code>
     * @return The enum numeric value on the wire for state.
     */
    int getStateValue();
    /**
     * <pre>
     *
     *State the swap is currently in, see State enum.
     * </pre>
     *
     * <code>.looprpc.SwapState state = 4;</code>
     * @return The state.
     */
    looprpc.Loop.SwapState getState();

    /**
     * <pre>
     *
     *A failure reason for the swap, only set if the swap has failed.
     * </pre>
     *
     * <code>.looprpc.FailureReason failure_reason = 14;</code>
     * @return The enum numeric value on the wire for failureReason.
     */
    int getFailureReasonValue();
    /**
     * <pre>
     *
     *A failure reason for the swap, only set if the swap has failed.
     * </pre>
     *
     * <code>.looprpc.FailureReason failure_reason = 14;</code>
     * @return The failureReason.
     */
    looprpc.Loop.FailureReason getFailureReason();

    /**
     * <pre>
     *
     *Initiation time of the swap.
     * </pre>
     *
     * <code>int64 initiation_time = 5 [jstype = JS_STRING];</code>
     * @return The initiationTime.
     */
    long getInitiationTime();

    /**
     * <pre>
     *
     *Initiation time of the swap.
     * </pre>
     *
     * <code>int64 last_update_time = 6 [jstype = JS_STRING];</code>
     * @return The lastUpdateTime.
     */
    long getLastUpdateTime();

    /**
     * <pre>
     *
     *DEPRECATED:  This field stores the address of the onchain htlc.
     *- For internal loop-in htlc_address contains the address of the
     *native segwit (P2WSH) htlc.
     *- For loop-out htlc_address always contains the native segwit (P2WSH)
     *htlc address.
     * </pre>
     *
     * <code>string htlc_address = 7 [deprecated = true];</code>
     * @deprecated looprpc.SwapStatus.htlc_address is deprecated.
     *     See loop.proto;l=393
     * @return The htlcAddress.
     */
    @java.lang.Deprecated java.lang.String getHtlcAddress();
    /**
     * <pre>
     *
     *DEPRECATED:  This field stores the address of the onchain htlc.
     *- For internal loop-in htlc_address contains the address of the
     *native segwit (P2WSH) htlc.
     *- For loop-out htlc_address always contains the native segwit (P2WSH)
     *htlc address.
     * </pre>
     *
     * <code>string htlc_address = 7 [deprecated = true];</code>
     * @deprecated looprpc.SwapStatus.htlc_address is deprecated.
     *     See loop.proto;l=393
     * @return The bytes for htlcAddress.
     */
    @java.lang.Deprecated com.google.protobuf.ByteString
        getHtlcAddressBytes();

    /**
     * <pre>
     * HTLC address (native segwit), used in loop-in and loop-out swaps.
     * </pre>
     *
     * <code>string htlc_address_p2wsh = 12;</code>
     * @return The htlcAddressP2wsh.
     */
    java.lang.String getHtlcAddressP2Wsh();
    /**
     * <pre>
     * HTLC address (native segwit), used in loop-in and loop-out swaps.
     * </pre>
     *
     * <code>string htlc_address_p2wsh = 12;</code>
     * @return The bytes for htlcAddressP2wsh.
     */
    com.google.protobuf.ByteString
        getHtlcAddressP2WshBytes();

    /**
     * <pre>
     * The address of the v3 (taproot) htlc. Used for both loop-in and loop-out.
     * </pre>
     *
     * <code>string htlc_address_p2tr = 18;</code>
     * @return The htlcAddressP2tr.
     */
    java.lang.String getHtlcAddressP2Tr();
    /**
     * <pre>
     * The address of the v3 (taproot) htlc. Used for both loop-in and loop-out.
     * </pre>
     *
     * <code>string htlc_address_p2tr = 18;</code>
     * @return The bytes for htlcAddressP2tr.
     */
    com.google.protobuf.ByteString
        getHtlcAddressP2TrBytes();

    /**
     * <pre>
     * Swap server cost
     * </pre>
     *
     * <code>int64 cost_server = 8 [jstype = JS_STRING];</code>
     * @return The costServer.
     */
    long getCostServer();

    /**
     * <pre>
     * On-chain transaction cost
     * </pre>
     *
     * <code>int64 cost_onchain = 9 [jstype = JS_STRING];</code>
     * @return The costOnchain.
     */
    long getCostOnchain();

    /**
     * <pre>
     * Off-chain routing fees
     * </pre>
     *
     * <code>int64 cost_offchain = 10 [jstype = JS_STRING];</code>
     * @return The costOffchain.
     */
    long getCostOffchain();

    /**
     * <pre>
     * Optional last hop if provided in the loop in request.
     * </pre>
     *
     * <code>bytes last_hop = 16;</code>
     * @return The lastHop.
     */
    com.google.protobuf.ByteString getLastHop();

    /**
     * <pre>
     * Optional outgoing channel set if provided in the loop out request.
     * </pre>
     *
     * <code>repeated uint64 outgoing_chan_set = 17 [jstype = JS_STRING];</code>
     * @return A list containing the outgoingChanSet.
     */
    java.util.List<java.lang.Long> getOutgoingChanSetList();
    /**
     * <pre>
     * Optional outgoing channel set if provided in the loop out request.
     * </pre>
     *
     * <code>repeated uint64 outgoing_chan_set = 17 [jstype = JS_STRING];</code>
     * @return The count of outgoingChanSet.
     */
    int getOutgoingChanSetCount();
    /**
     * <pre>
     * Optional outgoing channel set if provided in the loop out request.
     * </pre>
     *
     * <code>repeated uint64 outgoing_chan_set = 17 [jstype = JS_STRING];</code>
     * @param index The index of the element to return.
     * @return The outgoingChanSet at the given index.
     */
    long getOutgoingChanSet(int index);

    /**
     * <pre>
     * An optional label given to the swap on creation.
     * </pre>
     *
     * <code>string label = 15;</code>
     * @return The label.
     */
    java.lang.String getLabel();
    /**
     * <pre>
     * An optional label given to the swap on creation.
     * </pre>
     *
     * <code>string label = 15;</code>
     * @return The bytes for label.
     */
    com.google.protobuf.ByteString
        getLabelBytes();
  }
  /**
   * Protobuf type {@code looprpc.SwapStatus}
   */
  public static final class SwapStatus extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:looprpc.SwapStatus)
      SwapStatusOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use SwapStatus.newBuilder() to construct.
    private SwapStatus(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private SwapStatus() {
      idBytes_ = com.google.protobuf.ByteString.EMPTY;
      type_ = 0;
      state_ = 0;
      failureReason_ = 0;
      htlcAddress_ = "";
      htlcAddressP2Wsh_ = "";
      htlcAddressP2Tr_ = "";
      lastHop_ = com.google.protobuf.ByteString.EMPTY;
      outgoingChanSet_ = emptyLongList();
      label_ = "";
    }

    @java.lang.Override
    @SuppressWarnings({"unused"})
    protected java.lang.Object newInstance(
        UnusedPrivateParameter unused) {
      return new SwapStatus();
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return looprpc.Loop.internal_static_looprpc_SwapStatus_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return looprpc.Loop.internal_static_looprpc_SwapStatus_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              looprpc.Loop.SwapStatus.class, looprpc.Loop.SwapStatus.Builder.class);
    }

    public static final int AMT_FIELD_NUMBER = 1;
    private long amt_ = 0L;
    /**
     * <pre>
     *
     *Requested swap amount in sat. This does not include the swap and miner
     *fee.
     * </pre>
     *
     * <code>int64 amt = 1 [jstype = JS_STRING];</code>
     * @return The amt.
     */
    @java.lang.Override
    public long getAmt() {
      return amt_;
    }

    public static final int ID_BYTES_FIELD_NUMBER = 11;
    private com.google.protobuf.ByteString idBytes_ = com.google.protobuf.ByteString.EMPTY;
    /**
     * <pre>
     *
     *Swap identifier to track status in the update stream that is returned from
     *the Start() call. Currently this is the hash that locks the htlcs.
     * </pre>
     *
     * <code>bytes id_bytes = 11;</code>
     * @return The idBytes.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString getIdBytes() {
      return idBytes_;
    }

    public static final int TYPE_FIELD_NUMBER = 3;
    private int type_ = 0;
    /**
     * <pre>
     *
     *The type of the swap.
     * </pre>
     *
     * <code>.looprpc.SwapType type = 3;</code>
     * @return The enum numeric value on the wire for type.
     */
    @java.lang.Override public int getTypeValue() {
      return type_;
    }
    /**
     * <pre>
     *
     *The type of the swap.
     * </pre>
     *
     * <code>.looprpc.SwapType type = 3;</code>
     * @return The type.
     */
    @java.lang.Override public looprpc.Loop.SwapType getType() {
      looprpc.Loop.SwapType result = looprpc.Loop.SwapType.forNumber(type_);
      return result == null ? looprpc.Loop.SwapType.UNRECOGNIZED : result;
    }

    public static final int STATE_FIELD_NUMBER = 4;
    private int state_ = 0;
    /**
     * <pre>
     *
     *State the swap is currently in, see State enum.
     * </pre>
     *
     * <code>.looprpc.SwapState state = 4;</code>
     * @return The enum numeric value on the wire for state.
     */
    @java.lang.Override public int getStateValue() {
      return state_;
    }
    /**
     * <pre>
     *
     *State the swap is currently in, see State enum.
     * </pre>
     *
     * <code>.looprpc.SwapState state = 4;</code>
     * @return The state.
     */
    @java.lang.Override public looprpc.Loop.SwapState getState() {
      looprpc.Loop.SwapState result = looprpc.Loop.SwapState.forNumber(state_);
      return result == null ? looprpc.Loop.SwapState.UNRECOGNIZED : result;
    }

    public static final int FAILURE_REASON_FIELD_NUMBER = 14;
    private int failureReason_ = 0;
    /**
     * <pre>
     *
     *A failure reason for the swap, only set if the swap has failed.
     * </pre>
     *
     * <code>.looprpc.FailureReason failure_reason = 14;</code>
     * @return The enum numeric value on the wire for failureReason.
     */
    @java.lang.Override public int getFailureReasonValue() {
      return failureReason_;
    }
    /**
     * <pre>
     *
     *A failure reason for the swap, only set if the swap has failed.
     * </pre>
     *
     * <code>.looprpc.FailureReason failure_reason = 14;</code>
     * @return The failureReason.
     */
    @java.lang.Override public looprpc.Loop.FailureReason getFailureReason() {
      looprpc.Loop.FailureReason result = looprpc.Loop.FailureReason.forNumber(failureReason_);
      return result == null ? looprpc.Loop.FailureReason.UNRECOGNIZED : result;
    }

    public static final int INITIATION_TIME_FIELD_NUMBER = 5;
    private long initiationTime_ = 0L;
    /**
     * <pre>
     *
     *Initiation time of the swap.
     * </pre>
     *
     * <code>int64 initiation_time = 5 [jstype = JS_STRING];</code>
     * @return The initiationTime.
     */
    @java.lang.Override
    public long getInitiationTime() {
      return initiationTime_;
    }

    public static final int LAST_UPDATE_TIME_FIELD_NUMBER = 6;
    private long lastUpdateTime_ = 0L;
    /**
     * <pre>
     *
     *Initiation time of the swap.
     * </pre>
     *
     * <code>int64 last_update_time = 6 [jstype = JS_STRING];</code>
     * @return The lastUpdateTime.
     */
    @java.lang.Override
    public long getLastUpdateTime() {
      return lastUpdateTime_;
    }

    public static final int HTLC_ADDRESS_FIELD_NUMBER = 7;
    @SuppressWarnings("serial")
    private volatile java.lang.Object htlcAddress_ = "";
    /**
     * <pre>
     *
     *DEPRECATED:  This field stores the address of the onchain htlc.
     *- For internal loop-in htlc_address contains the address of the
     *native segwit (P2WSH) htlc.
     *- For loop-out htlc_address always contains the native segwit (P2WSH)
     *htlc address.
     * </pre>
     *
     * <code>string htlc_address = 7 [deprecated = true];</code>
     * @deprecated looprpc.SwapStatus.htlc_address is deprecated.
     *     See loop.proto;l=393
     * @return The htlcAddress.
     */
    @java.lang.Override
    @java.lang.Deprecated public java.lang.String getHtlcAddress() {
      java.lang.Object ref = htlcAddress_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        htlcAddress_ = s;
        return s;
      }
    }
    /**
     * <pre>
     *
     *DEPRECATED:  This field stores the address of the onchain htlc.
     *- For internal loop-in htlc_address contains the address of the
     *native segwit (P2WSH) htlc.
     *- For loop-out htlc_address always contains the native segwit (P2WSH)
     *htlc address.
     * </pre>
     *
     * <code>string htlc_address = 7 [deprecated = true];</code>
     * @deprecated looprpc.SwapStatus.htlc_address is deprecated.
     *     See loop.proto;l=393
     * @return The bytes for htlcAddress.
     */
    @java.lang.Override
    @java.lang.Deprecated public com.google.protobuf.ByteString
        getHtlcAddressBytes() {
      java.lang.Object ref = htlcAddress_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        htlcAddress_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int HTLC_ADDRESS_P2WSH_FIELD_NUMBER = 12;
    @SuppressWarnings("serial")
    private volatile java.lang.Object htlcAddressP2Wsh_ = "";
    /**
     * <pre>
     * HTLC address (native segwit), used in loop-in and loop-out swaps.
     * </pre>
     *
     * <code>string htlc_address_p2wsh = 12;</code>
     * @return The htlcAddressP2wsh.
     */
    @java.lang.Override
    public java.lang.String getHtlcAddressP2Wsh() {
      java.lang.Object ref = htlcAddressP2Wsh_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        htlcAddressP2Wsh_ = s;
        return s;
      }
    }
    /**
     * <pre>
     * HTLC address (native segwit), used in loop-in and loop-out swaps.
     * </pre>
     *
     * <code>string htlc_address_p2wsh = 12;</code>
     * @return The bytes for htlcAddressP2wsh.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getHtlcAddressP2WshBytes() {
      java.lang.Object ref = htlcAddressP2Wsh_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        htlcAddressP2Wsh_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int HTLC_ADDRESS_P2TR_FIELD_NUMBER = 18;
    @SuppressWarnings("serial")
    private volatile java.lang.Object htlcAddressP2Tr_ = "";
    /**
     * <pre>
     * The address of the v3 (taproot) htlc. Used for both loop-in and loop-out.
     * </pre>
     *
     * <code>string htlc_address_p2tr = 18;</code>
     * @return The htlcAddressP2tr.
     */
    @java.lang.Override
    public java.lang.String getHtlcAddressP2Tr() {
      java.lang.Object ref = htlcAddressP2Tr_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        htlcAddressP2Tr_ = s;
        return s;
      }
    }
    /**
     * <pre>
     * The address of the v3 (taproot) htlc. Used for both loop-in and loop-out.
     * </pre>
     *
     * <code>string htlc_address_p2tr = 18;</code>
     * @return The bytes for htlcAddressP2tr.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getHtlcAddressP2TrBytes() {
      java.lang.Object ref = htlcAddressP2Tr_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        htlcAddressP2Tr_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int COST_SERVER_FIELD_NUMBER = 8;
    private long costServer_ = 0L;
    /**
     * <pre>
     * Swap server cost
     * </pre>
     *
     * <code>int64 cost_server = 8 [jstype = JS_STRING];</code>
     * @return The costServer.
     */
    @java.lang.Override
    public long getCostServer() {
      return costServer_;
    }

    public static final int COST_ONCHAIN_FIELD_NUMBER = 9;
    private long costOnchain_ = 0L;
    /**
     * <pre>
     * On-chain transaction cost
     * </pre>
     *
     * <code>int64 cost_onchain = 9 [jstype = JS_STRING];</code>
     * @return The costOnchain.
     */
    @java.lang.Override
    public long getCostOnchain() {
      return costOnchain_;
    }

    public static final int COST_OFFCHAIN_FIELD_NUMBER = 10;
    private long costOffchain_ = 0L;
    /**
     * <pre>
     * Off-chain routing fees
     * </pre>
     *
     * <code>int64 cost_offchain = 10 [jstype = JS_STRING];</code>
     * @return The costOffchain.
     */
    @java.lang.Override
    public long getCostOffchain() {
      return costOffchain_;
    }

    public static final int LAST_HOP_FIELD_NUMBER = 16;
    private com.google.protobuf.ByteString lastHop_ = com.google.protobuf.ByteString.EMPTY;
    /**
     * <pre>
     * Optional last hop if provided in the loop in request.
     * </pre>
     *
     * <code>bytes last_hop = 16;</code>
     * @return The lastHop.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString getLastHop() {
      return lastHop_;
    }

    public static final int OUTGOING_CHAN_SET_FIELD_NUMBER = 17;
    @SuppressWarnings("serial")
    private com.google.protobuf.Internal.LongList outgoingChanSet_ =
        emptyLongList();
    /**
     * <pre>
     * Optional outgoing channel set if provided in the loop out request.
     * </pre>
     *
     * <code>repeated uint64 outgoing_chan_set = 17 [jstype = JS_STRING];</code>
     * @return A list containing the outgoingChanSet.
     */
    @java.lang.Override
    public java.util.List<java.lang.Long>
        getOutgoingChanSetList() {
      return outgoingChanSet_;
    }
    /**
     * <pre>
     * Optional outgoing channel set if provided in the loop out request.
     * </pre>
     *
     * <code>repeated uint64 outgoing_chan_set = 17 [jstype = JS_STRING];</code>
     * @return The count of outgoingChanSet.
     */
    public int getOutgoingChanSetCount() {
      return outgoingChanSet_.size();
    }
    /**
     * <pre>
     * Optional outgoing channel set if provided in the loop out request.
     * </pre>
     *
     * <code>repeated uint64 outgoing_chan_set = 17 [jstype = JS_STRING];</code>
     * @param index The index of the element to return.
     * @return The outgoingChanSet at the given index.
     */
    public long getOutgoingChanSet(int index) {
      return outgoingChanSet_.getLong(index);
    }
    private int outgoingChanSetMemoizedSerializedSize = -1;

    public static final int LABEL_FIELD_NUMBER = 15;
    @SuppressWarnings("serial")
    private volatile java.lang.Object label_ = "";
    /**
     * <pre>
     * An optional label given to the swap on creation.
     * </pre>
     *
     * <code>string label = 15;</code>
     * @return The label.
     */
    @java.lang.Override
    public java.lang.String getLabel() {
      java.lang.Object ref = label_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        label_ = s;
        return s;
      }
    }
    /**
     * <pre>
     * An optional label given to the swap on creation.
     * </pre>
     *
     * <code>string label = 15;</code>
     * @return The bytes for label.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getLabelBytes() {
      java.lang.Object ref = label_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        label_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      getSerializedSize();
      if (amt_ != 0L) {
        output.writeInt64(1, amt_);
      }
      if (type_ != looprpc.Loop.SwapType.LOOP_OUT.getNumber()) {
        output.writeEnum(3, type_);
      }
      if (state_ != looprpc.Loop.SwapState.INITIATED.getNumber()) {
        output.writeEnum(4, state_);
      }
      if (initiationTime_ != 0L) {
        output.writeInt64(5, initiationTime_);
      }
      if (lastUpdateTime_ != 0L) {
        output.writeInt64(6, lastUpdateTime_);
      }
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(htlcAddress_)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 7, htlcAddress_);
      }
      if (costServer_ != 0L) {
        output.writeInt64(8, costServer_);
      }
      if (costOnchain_ != 0L) {
        output.writeInt64(9, costOnchain_);
      }
      if (costOffchain_ != 0L) {
        output.writeInt64(10, costOffchain_);
      }
      if (!idBytes_.isEmpty()) {
        output.writeBytes(11, idBytes_);
      }
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(htlcAddressP2Wsh_)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 12, htlcAddressP2Wsh_);
      }
      if (failureReason_ != looprpc.Loop.FailureReason.FAILURE_REASON_NONE.getNumber()) {
        output.writeEnum(14, failureReason_);
      }
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(label_)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 15, label_);
      }
      if (!lastHop_.isEmpty()) {
        output.writeBytes(16, lastHop_);
      }
      if (getOutgoingChanSetList().size() > 0) {
        output.writeUInt32NoTag(138);
        output.writeUInt32NoTag(outgoingChanSetMemoizedSerializedSize);
      }
      for (int i = 0; i < outgoingChanSet_.size(); i++) {
        output.writeUInt64NoTag(outgoingChanSet_.getLong(i));
      }
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(htlcAddressP2Tr_)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 18, htlcAddressP2Tr_);
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (amt_ != 0L) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt64Size(1, amt_);
      }
      if (type_ != looprpc.Loop.SwapType.LOOP_OUT.getNumber()) {
        size += com.google.protobuf.CodedOutputStream
          .computeEnumSize(3, type_);
      }
      if (state_ != looprpc.Loop.SwapState.INITIATED.getNumber()) {
        size += com.google.protobuf.CodedOutputStream
          .computeEnumSize(4, state_);
      }
      if (initiationTime_ != 0L) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt64Size(5, initiationTime_);
      }
      if (lastUpdateTime_ != 0L) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt64Size(6, lastUpdateTime_);
      }
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(htlcAddress_)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(7, htlcAddress_);
      }
      if (costServer_ != 0L) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt64Size(8, costServer_);
      }
      if (costOnchain_ != 0L) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt64Size(9, costOnchain_);
      }
      if (costOffchain_ != 0L) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt64Size(10, costOffchain_);
      }
      if (!idBytes_.isEmpty()) {
        size += com.google.protobuf.CodedOutputStream
          .computeBytesSize(11, idBytes_);
      }
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(htlcAddressP2Wsh_)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(12, htlcAddressP2Wsh_);
      }
      if (failureReason_ != looprpc.Loop.FailureReason.FAILURE_REASON_NONE.getNumber()) {
        size += com.google.protobuf.CodedOutputStream
          .computeEnumSize(14, failureReason_);
      }
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(label_)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(15, label_);
      }
      if (!lastHop_.isEmpty()) {
        size += com.google.protobuf.CodedOutputStream
          .computeBytesSize(16, lastHop_);
      }
      {
        int dataSize = 0;
        for (int i = 0; i < outgoingChanSet_.size(); i++) {
          dataSize += com.google.protobuf.CodedOutputStream
            .computeUInt64SizeNoTag(outgoingChanSet_.getLong(i));
        }
        size += dataSize;
        if (!getOutgoingChanSetList().isEmpty()) {
          size += 2;
          size += com.google.protobuf.CodedOutputStream
              .computeInt32SizeNoTag(dataSize);
        }
        outgoingChanSetMemoizedSerializedSize = dataSize;
      }
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(htlcAddressP2Tr_)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(18, htlcAddressP2Tr_);
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof looprpc.Loop.SwapStatus)) {
        return super.equals(obj);
      }
      looprpc.Loop.SwapStatus other = (looprpc.Loop.SwapStatus) obj;

      if (getAmt()
          != other.getAmt()) return false;
      if (!getIdBytes()
          .equals(other.getIdBytes())) return false;
      if (type_ != other.type_) return false;
      if (state_ != other.state_) return false;
      if (failureReason_ != other.failureReason_) return false;
      if (getInitiationTime()
          != other.getInitiationTime()) return false;
      if (getLastUpdateTime()
          != other.getLastUpdateTime()) return false;
      if (!getHtlcAddress()
          .equals(other.getHtlcAddress())) return false;
      if (!getHtlcAddressP2Wsh()
          .equals(other.getHtlcAddressP2Wsh())) return false;
      if (!getHtlcAddressP2Tr()
          .equals(other.getHtlcAddressP2Tr())) return false;
      if (getCostServer()
          != other.getCostServer()) return false;
      if (getCostOnchain()
          != other.getCostOnchain()) return false;
      if (getCostOffchain()
          != other.getCostOffchain()) return false;
      if (!getLastHop()
          .equals(other.getLastHop())) return false;
      if (!getOutgoingChanSetList()
          .equals(other.getOutgoingChanSetList())) return false;
      if (!getLabel()
          .equals(other.getLabel())) return false;
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      hash = (37 * hash) + AMT_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
          getAmt());
      hash = (37 * hash) + ID_BYTES_FIELD_NUMBER;
      hash = (53 * hash) + getIdBytes().hashCode();
      hash = (37 * hash) + TYPE_FIELD_NUMBER;
      hash = (53 * hash) + type_;
      hash = (37 * hash) + STATE_FIELD_NUMBER;
      hash = (53 * hash) + state_;
      hash = (37 * hash) + FAILURE_REASON_FIELD_NUMBER;
      hash = (53 * hash) + failureReason_;
      hash = (37 * hash) + INITIATION_TIME_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
          getInitiationTime());
      hash = (37 * hash) + LAST_UPDATE_TIME_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
          getLastUpdateTime());
      hash = (37 * hash) + HTLC_ADDRESS_FIELD_NUMBER;
      hash = (53 * hash) + getHtlcAddress().hashCode();
      hash = (37 * hash) + HTLC_ADDRESS_P2WSH_FIELD_NUMBER;
      hash = (53 * hash) + getHtlcAddressP2Wsh().hashCode();
      hash = (37 * hash) + HTLC_ADDRESS_P2TR_FIELD_NUMBER;
      hash = (53 * hash) + getHtlcAddressP2Tr().hashCode();
      hash = (37 * hash) + COST_SERVER_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
          getCostServer());
      hash = (37 * hash) + COST_ONCHAIN_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
          getCostOnchain());
      hash = (37 * hash) + COST_OFFCHAIN_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
          getCostOffchain());
      hash = (37 * hash) + LAST_HOP_FIELD_NUMBER;
      hash = (53 * hash) + getLastHop().hashCode();
      if (getOutgoingChanSetCount() > 0) {
        hash = (37 * hash) + OUTGOING_CHAN_SET_FIELD_NUMBER;
        hash = (53 * hash) + getOutgoingChanSetList().hashCode();
      }
      hash = (37 * hash) + LABEL_FIELD_NUMBER;
      hash = (53 * hash) + getLabel().hashCode();
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static looprpc.Loop.SwapStatus parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static looprpc.Loop.SwapStatus parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static looprpc.Loop.SwapStatus parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static looprpc.Loop.SwapStatus parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static looprpc.Loop.SwapStatus parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static looprpc.Loop.SwapStatus parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static looprpc.Loop.SwapStatus parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static looprpc.Loop.SwapStatus parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static looprpc.Loop.SwapStatus parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static looprpc.Loop.SwapStatus parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static looprpc.Loop.SwapStatus parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static looprpc.Loop.SwapStatus parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(looprpc.Loop.SwapStatus prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * Protobuf type {@code looprpc.SwapStatus}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:looprpc.SwapStatus)
        looprpc.Loop.SwapStatusOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return looprpc.Loop.internal_static_looprpc_SwapStatus_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return looprpc.Loop.internal_static_looprpc_SwapStatus_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                looprpc.Loop.SwapStatus.class, looprpc.Loop.SwapStatus.Builder.class);
      }

      // Construct using looprpc.Loop.SwapStatus.newBuilder()
      private Builder() {

      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);

      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        amt_ = 0L;
        idBytes_ = com.google.protobuf.ByteString.EMPTY;
        type_ = 0;
        state_ = 0;
        failureReason_ = 0;
        initiationTime_ = 0L;
        lastUpdateTime_ = 0L;
        htlcAddress_ = "";
        htlcAddressP2Wsh_ = "";
        htlcAddressP2Tr_ = "";
        costServer_ = 0L;
        costOnchain_ = 0L;
        costOffchain_ = 0L;
        lastHop_ = com.google.protobuf.ByteString.EMPTY;
        outgoingChanSet_ = emptyLongList();
        label_ = "";
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return looprpc.Loop.internal_static_looprpc_SwapStatus_descriptor;
      }

      @java.lang.Override
      public looprpc.Loop.SwapStatus getDefaultInstanceForType() {
        return looprpc.Loop.SwapStatus.getDefaultInstance();
      }

      @java.lang.Override
      public looprpc.Loop.SwapStatus build() {
        looprpc.Loop.SwapStatus result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public looprpc.Loop.SwapStatus buildPartial() {
        looprpc.Loop.SwapStatus result = new looprpc.Loop.SwapStatus(this);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartial0(looprpc.Loop.SwapStatus result) {
        int from_bitField0_ = bitField0_;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.amt_ = amt_;
        }
        if (((from_bitField0_ & 0x00000002) != 0)) {
          result.idBytes_ = idBytes_;
        }
        if (((from_bitField0_ & 0x00000004) != 0)) {
          result.type_ = type_;
        }
        if (((from_bitField0_ & 0x00000008) != 0)) {
          result.state_ = state_;
        }
        if (((from_bitField0_ & 0x00000010) != 0)) {
          result.failureReason_ = failureReason_;
        }
        if (((from_bitField0_ & 0x00000020) != 0)) {
          result.initiationTime_ = initiationTime_;
        }
        if (((from_bitField0_ & 0x00000040) != 0)) {
          result.lastUpdateTime_ = lastUpdateTime_;
        }
        if (((from_bitField0_ & 0x00000080) != 0)) {
          result.htlcAddress_ = htlcAddress_;
        }
        if (((from_bitField0_ & 0x00000100) != 0)) {
          result.htlcAddressP2Wsh_ = htlcAddressP2Wsh_;
        }
        if (((from_bitField0_ & 0x00000200) != 0)) {
          result.htlcAddressP2Tr_ = htlcAddressP2Tr_;
        }
        if (((from_bitField0_ & 0x00000400) != 0)) {
          result.costServer_ = costServer_;
        }
        if (((from_bitField0_ & 0x00000800) != 0)) {
          result.costOnchain_ = costOnchain_;
        }
        if (((from_bitField0_ & 0x00001000) != 0)) {
          result.costOffchain_ = costOffchain_;
        }
        if (((from_bitField0_ & 0x00002000) != 0)) {
          result.lastHop_ = lastHop_;
        }
        if (((from_bitField0_ & 0x00004000) != 0)) {
          outgoingChanSet_.makeImmutable();
          result.outgoingChanSet_ = outgoingChanSet_;
        }
        if (((from_bitField0_ & 0x00008000) != 0)) {
          result.label_ = label_;
        }
      }

      @java.lang.Override
      public Builder clone() {
        return super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof looprpc.Loop.SwapStatus) {
          return mergeFrom((looprpc.Loop.SwapStatus)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(looprpc.Loop.SwapStatus other) {
        if (other == looprpc.Loop.SwapStatus.getDefaultInstance()) return this;
        if (other.getAmt() != 0L) {
          setAmt(other.getAmt());
        }
        if (other.getIdBytes() != com.google.protobuf.ByteString.EMPTY) {
          setIdBytes(other.getIdBytes());
        }
        if (other.type_ != 0) {
          setTypeValue(other.getTypeValue());
        }
        if (other.state_ != 0) {
          setStateValue(other.getStateValue());
        }
        if (other.failureReason_ != 0) {
          setFailureReasonValue(other.getFailureReasonValue());
        }
        if (other.getInitiationTime() != 0L) {
          setInitiationTime(other.getInitiationTime());
        }
        if (other.getLastUpdateTime() != 0L) {
          setLastUpdateTime(other.getLastUpdateTime());
        }
        if (!other.getHtlcAddress().isEmpty()) {
          htlcAddress_ = other.htlcAddress_;
          bitField0_ |= 0x00000080;
          onChanged();
        }
        if (!other.getHtlcAddressP2Wsh().isEmpty()) {
          htlcAddressP2Wsh_ = other.htlcAddressP2Wsh_;
          bitField0_ |= 0x00000100;
          onChanged();
        }
        if (!other.getHtlcAddressP2Tr().isEmpty()) {
          htlcAddressP2Tr_ = other.htlcAddressP2Tr_;
          bitField0_ |= 0x00000200;
          onChanged();
        }
        if (other.getCostServer() != 0L) {
          setCostServer(other.getCostServer());
        }
        if (other.getCostOnchain() != 0L) {
          setCostOnchain(other.getCostOnchain());
        }
        if (other.getCostOffchain() != 0L) {
          setCostOffchain(other.getCostOffchain());
        }
        if (other.getLastHop() != com.google.protobuf.ByteString.EMPTY) {
          setLastHop(other.getLastHop());
        }
        if (!other.outgoingChanSet_.isEmpty()) {
          if (outgoingChanSet_.isEmpty()) {
            outgoingChanSet_ = other.outgoingChanSet_;
            outgoingChanSet_.makeImmutable();
            bitField0_ |= 0x00004000;
          } else {
            ensureOutgoingChanSetIsMutable();
            outgoingChanSet_.addAll(other.outgoingChanSet_);
          }
          onChanged();
        }
        if (!other.getLabel().isEmpty()) {
          label_ = other.label_;
          bitField0_ |= 0x00008000;
          onChanged();
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 8: {
                amt_ = input.readInt64();
                bitField0_ |= 0x00000001;
                break;
              } // case 8
              case 24: {
                type_ = input.readEnum();
                bitField0_ |= 0x00000004;
                break;
              } // case 24
              case 32: {
                state_ = input.readEnum();
                bitField0_ |= 0x00000008;
                break;
              } // case 32
              case 40: {
                initiationTime_ = input.readInt64();
                bitField0_ |= 0x00000020;
                break;
              } // case 40
              case 48: {
                lastUpdateTime_ = input.readInt64();
                bitField0_ |= 0x00000040;
                break;
              } // case 48
              case 58: {
                htlcAddress_ = input.readStringRequireUtf8();
                bitField0_ |= 0x00000080;
                break;
              } // case 58
              case 64: {
                costServer_ = input.readInt64();
                bitField0_ |= 0x00000400;
                break;
              } // case 64
              case 72: {
                costOnchain_ = input.readInt64();
                bitField0_ |= 0x00000800;
                break;
              } // case 72
              case 80: {
                costOffchain_ = input.readInt64();
                bitField0_ |= 0x00001000;
                break;
              } // case 80
              case 90: {
                idBytes_ = input.readBytes();
                bitField0_ |= 0x00000002;
                break;
              } // case 90
              case 98: {
                htlcAddressP2Wsh_ = input.readStringRequireUtf8();
                bitField0_ |= 0x00000100;
                break;
              } // case 98
              case 112: {
                failureReason_ = input.readEnum();
                bitField0_ |= 0x00000010;
                break;
              } // case 112
              case 122: {
                label_ = input.readStringRequireUtf8();
                bitField0_ |= 0x00008000;
                break;
              } // case 122
              case 130: {
                lastHop_ = input.readBytes();
                bitField0_ |= 0x00002000;
                break;
              } // case 130
              case 136: {
                long v = input.readUInt64();
                ensureOutgoingChanSetIsMutable();
                outgoingChanSet_.addLong(v);
                break;
              } // case 136
              case 138: {
                int length = input.readRawVarint32();
                int limit = input.pushLimit(length);
                ensureOutgoingChanSetIsMutable();
                while (input.getBytesUntilLimit() > 0) {
                  outgoingChanSet_.addLong(input.readUInt64());
                }
                input.popLimit(limit);
                break;
              } // case 138
              case 146: {
                htlcAddressP2Tr_ = input.readStringRequireUtf8();
                bitField0_ |= 0x00000200;
                break;
              } // case 146
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private long amt_ ;
      /**
       * <pre>
       *
       *Requested swap amount in sat. This does not include the swap and miner
       *fee.
       * </pre>
       *
       * <code>int64 amt = 1 [jstype = JS_STRING];</code>
       * @return The amt.
       */
      @java.lang.Override
      public long getAmt() {
        return amt_;
      }
      /**
       * <pre>
       *
       *Requested swap amount in sat. This does not include the swap and miner
       *fee.
       * </pre>
       *
       * <code>int64 amt = 1 [jstype = JS_STRING];</code>
       * @param value The amt to set.
       * @return This builder for chaining.
       */
      public Builder setAmt(long value) {

        amt_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       *
       *Requested swap amount in sat. This does not include the swap and miner
       *fee.
       * </pre>
       *
       * <code>int64 amt = 1 [jstype = JS_STRING];</code>
       * @return This builder for chaining.
       */
      public Builder clearAmt() {
        bitField0_ = (bitField0_ & ~0x00000001);
        amt_ = 0L;
        onChanged();
        return this;
      }

      private com.google.protobuf.ByteString idBytes_ = com.google.protobuf.ByteString.EMPTY;
      /**
       * <pre>
       *
       *Swap identifier to track status in the update stream that is returned from
       *the Start() call. Currently this is the hash that locks the htlcs.
       * </pre>
       *
       * <code>bytes id_bytes = 11;</code>
       * @return The idBytes.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString getIdBytes() {
        return idBytes_;
      }
      /**
       * <pre>
       *
       *Swap identifier to track status in the update stream that is returned from
       *the Start() call. Currently this is the hash that locks the htlcs.
       * </pre>
       *
       * <code>bytes id_bytes = 11;</code>
       * @param value The idBytes to set.
       * @return This builder for chaining.
       */
      public Builder setIdBytes(com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        idBytes_ = value;
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       *
       *Swap identifier to track status in the update stream that is returned from
       *the Start() call. Currently this is the hash that locks the htlcs.
       * </pre>
       *
       * <code>bytes id_bytes = 11;</code>
       * @return This builder for chaining.
       */
      public Builder clearIdBytes() {
        bitField0_ = (bitField0_ & ~0x00000002);
        idBytes_ = getDefaultInstance().getIdBytes();
        onChanged();
        return this;
      }

      private int type_ = 0;
      /**
       * <pre>
       *
       *The type of the swap.
       * </pre>
       *
       * <code>.looprpc.SwapType type = 3;</code>
       * @return The enum numeric value on the wire for type.
       */
      @java.lang.Override public int getTypeValue() {
        return type_;
      }
      /**
       * <pre>
       *
       *The type of the swap.
       * </pre>
       *
       * <code>.looprpc.SwapType type = 3;</code>
       * @param value The enum numeric value on the wire for type to set.
       * @return This builder for chaining.
       */
      public Builder setTypeValue(int value) {
        type_ = value;
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }
      /**
       * <pre>
       *
       *The type of the swap.
       * </pre>
       *
       * <code>.looprpc.SwapType type = 3;</code>
       * @return The type.
       */
      @java.lang.Override
      public looprpc.Loop.SwapType getType() {
        looprpc.Loop.SwapType result = looprpc.Loop.SwapType.forNumber(type_);
        return result == null ? looprpc.Loop.SwapType.UNRECOGNIZED : result;
      }
      /**
       * <pre>
       *
       *The type of the swap.
       * </pre>
       *
       * <code>.looprpc.SwapType type = 3;</code>
       * @param value The type to set.
       * @return This builder for chaining.
       */
      public Builder setType(looprpc.Loop.SwapType value) {
        if (value == null) {
          throw new NullPointerException();
        }
        bitField0_ |= 0x00000004;
        type_ = value.getNumber();
        onChanged();
        return this;
      }
      /**
       * <pre>
       *
       *The type of the swap.
       * </pre>
       *
       * <code>.looprpc.SwapType type = 3;</code>
       * @return This builder for chaining.
       */
      public Builder clearType() {
        bitField0_ = (bitField0_ & ~0x00000004);
        type_ = 0;
        onChanged();
        return this;
      }

      private int state_ = 0;
      /**
       * <pre>
       *
       *State the swap is currently in, see State enum.
       * </pre>
       *
       * <code>.looprpc.SwapState state = 4;</code>
       * @return The enum numeric value on the wire for state.
       */
      @java.lang.Override public int getStateValue() {
        return state_;
      }
      /**
       * <pre>
       *
       *State the swap is currently in, see State enum.
       * </pre>
       *
       * <code>.looprpc.SwapState state = 4;</code>
       * @param value The enum numeric value on the wire for state to set.
       * @return This builder for chaining.
       */
      public Builder setStateValue(int value) {
        state_ = value;
        bitField0_ |= 0x00000008;
        onChanged();
        return this;
      }
      /**
       * <pre>
       *
       *State the swap is currently in, see State enum.
       * </pre>
       *
       * <code>.looprpc.SwapState state = 4;</code>
       * @return The state.
       */
      @java.lang.Override
      public looprpc.Loop.SwapState getState() {
        looprpc.Loop.SwapState result = looprpc.Loop.SwapState.forNumber(state_);
        return result == null ? looprpc.Loop.SwapState.UNRECOGNIZED : result;
      }
      /**
       * <pre>
       *
       *State the swap is currently in, see State enum.
       * </pre>
       *
       * <code>.looprpc.SwapState state = 4;</code>
       * @param value The state to set.
       * @return This builder for chaining.
       */
      public Builder setState(looprpc.Loop.SwapState value) {
        if (value == null) {
          throw new NullPointerException();
        }
        bitField0_ |= 0x00000008;
        state_ = value.getNumber();
        onChanged();
        return this;
      }
      /**
       * <pre>
       *
       *State the swap is currently in, see State enum.
       * </pre>
       *
       * <code>.looprpc.SwapState state = 4;</code>
       * @return This builder for chaining.
       */
      public Builder clearState() {
        bitField0_ = (bitField0_ & ~0x00000008);
        state_ = 0;
        onChanged();
        return this;
      }

      private int failureReason_ = 0;
      /**
       * <pre>
       *
       *A failure reason for the swap, only set if the swap has failed.
       * </pre>
       *
       * <code>.looprpc.FailureReason failure_reason = 14;</code>
       * @return The enum numeric value on the wire for failureReason.
       */
      @java.lang.Override public int getFailureReasonValue() {
        return failureReason_;
      }
      /**
       * <pre>
       *
       *A failure reason for the swap, only set if the swap has failed.
       * </pre>
       *
       * <code>.looprpc.FailureReason failure_reason = 14;</code>
       * @param value The enum numeric value on the wire for failureReason to set.
       * @return This builder for chaining.
       */
      public Builder setFailureReasonValue(int value) {
        failureReason_ = value;
        bitField0_ |= 0x00000010;
        onChanged();
        return this;
      }
      /**
       * <pre>
       *
       *A failure reason for the swap, only set if the swap has failed.
       * </pre>
       *
       * <code>.looprpc.FailureReason failure_reason = 14;</code>
       * @return The failureReason.
       */
      @java.lang.Override
      public looprpc.Loop.FailureReason getFailureReason() {
        looprpc.Loop.FailureReason result = looprpc.Loop.FailureReason.forNumber(failureReason_);
        return result == null ? looprpc.Loop.FailureReason.UNRECOGNIZED : result;
      }
      /**
       * <pre>
       *
       *A failure reason for the swap, only set if the swap has failed.
       * </pre>
       *
       * <code>.looprpc.FailureReason failure_reason = 14;</code>
       * @param value The failureReason to set.
       * @return This builder for chaining.
       */
      public Builder setFailureReason(looprpc.Loop.FailureReason value) {
        if (value == null) {
          throw new NullPointerException();
        }
        bitField0_ |= 0x00000010;
        failureReason_ = value.getNumber();
        onChanged();
        return this;
      }
      /**
       * <pre>
       *
       *A failure reason for the swap, only set if the swap has failed.
       * </pre>
       *
       * <code>.looprpc.FailureReason failure_reason = 14;</code>
       * @return This builder for chaining.
       */
      public Builder clearFailureReason() {
        bitField0_ = (bitField0_ & ~0x00000010);
        failureReason_ = 0;
        onChanged();
        return this;
      }

      private long initiationTime_ ;
      /**
       * <pre>
       *
       *Initiation time of the swap.
       * </pre>
       *
       * <code>int64 initiation_time = 5 [jstype = JS_STRING];</code>
       * @return The initiationTime.
       */
      @java.lang.Override
      public long getInitiationTime() {
        return initiationTime_;
      }
      /**
       * <pre>
       *
       *Initiation time of the swap.
       * </pre>
       *
       * <code>int64 initiation_time = 5 [jstype = JS_STRING];</code>
       * @param value The initiationTime to set.
       * @return This builder for chaining.
       */
      public Builder setInitiationTime(long value) {

        initiationTime_ = value;
        bitField0_ |= 0x00000020;
        onChanged();
        return this;
      }
      /**
       * <pre>
       *
       *Initiation time of the swap.
       * </pre>
       *
       * <code>int64 initiation_time = 5 [jstype = JS_STRING];</code>
       * @return This builder for chaining.
       */
      public Builder clearInitiationTime() {
        bitField0_ = (bitField0_ & ~0x00000020);
        initiationTime_ = 0L;
        onChanged();
        return this;
      }

      private long lastUpdateTime_ ;
      /**
       * <pre>
       *
       *Initiation time of the swap.
       * </pre>
       *
       * <code>int64 last_update_time = 6 [jstype = JS_STRING];</code>
       * @return The lastUpdateTime.
       */
      @java.lang.Override
      public long getLastUpdateTime() {
        return lastUpdateTime_;
      }
      /**
       * <pre>
       *
       *Initiation time of the swap.
       * </pre>
       *
       * <code>int64 last_update_time = 6 [jstype = JS_STRING];</code>
       * @param value The lastUpdateTime to set.
       * @return This builder for chaining.
       */
      public Builder setLastUpdateTime(long value) {

        lastUpdateTime_ = value;
        bitField0_ |= 0x00000040;
        onChanged();
        return this;
      }
      /**
       * <pre>
       *
       *Initiation time of the swap.
       * </pre>
       *
       * <code>int64 last_update_time = 6 [jstype = JS_STRING];</code>
       * @return This builder for chaining.
       */
      public Builder clearLastUpdateTime() {
        bitField0_ = (bitField0_ & ~0x00000040);
        lastUpdateTime_ = 0L;
        onChanged();
        return this;
      }

      private java.lang.Object htlcAddress_ = "";
      /**
       * <pre>
       *
       *DEPRECATED:  This field stores the address of the onchain htlc.
       *- For internal loop-in htlc_address contains the address of the
       *native segwit (P2WSH) htlc.
       *- For loop-out htlc_address always contains the native segwit (P2WSH)
       *htlc address.
       * </pre>
       *
       * <code>string htlc_address = 7 [deprecated = true];</code>
       * @deprecated looprpc.SwapStatus.htlc_address is deprecated.
       *     See loop.proto;l=393
       * @return The htlcAddress.
       */
      @java.lang.Deprecated public java.lang.String getHtlcAddress() {
        java.lang.Object ref = htlcAddress_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          htlcAddress_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       *
       *DEPRECATED:  This field stores the address of the onchain htlc.
       *- For internal loop-in htlc_address contains the address of the
       *native segwit (P2WSH) htlc.
       *- For loop-out htlc_address always contains the native segwit (P2WSH)
       *htlc address.
       * </pre>
       *
       * <code>string htlc_address = 7 [deprecated = true];</code>
       * @deprecated looprpc.SwapStatus.htlc_address is deprecated.
       *     See loop.proto;l=393
       * @return The bytes for htlcAddress.
       */
      @java.lang.Deprecated public com.google.protobuf.ByteString
          getHtlcAddressBytes() {
        java.lang.Object ref = htlcAddress_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          htlcAddress_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       *
       *DEPRECATED:  This field stores the address of the onchain htlc.
       *- For internal loop-in htlc_address contains the address of the
       *native segwit (P2WSH) htlc.
       *- For loop-out htlc_address always contains the native segwit (P2WSH)
       *htlc address.
       * </pre>
       *
       * <code>string htlc_address = 7 [deprecated = true];</code>
       * @deprecated looprpc.SwapStatus.htlc_address is deprecated.
       *     See loop.proto;l=393
       * @param value The htlcAddress to set.
       * @return This builder for chaining.
       */
      @java.lang.Deprecated public Builder setHtlcAddress(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        htlcAddress_ = value;
        bitField0_ |= 0x00000080;
        onChanged();
        return this;
      }
      /**
       * <pre>
       *
       *DEPRECATED:  This field stores the address of the onchain htlc.
       *- For internal loop-in htlc_address contains the address of the
       *native segwit (P2WSH) htlc.
       *- For loop-out htlc_address always contains the native segwit (P2WSH)
       *htlc address.
       * </pre>
       *
       * <code>string htlc_address = 7 [deprecated = true];</code>
       * @deprecated looprpc.SwapStatus.htlc_address is deprecated.
       *     See loop.proto;l=393
       * @return This builder for chaining.
       */
      @java.lang.Deprecated public Builder clearHtlcAddress() {
        htlcAddress_ = getDefaultInstance().getHtlcAddress();
        bitField0_ = (bitField0_ & ~0x00000080);
        onChanged();
        return this;
      }
      /**
       * <pre>
       *
       *DEPRECATED:  This field stores the address of the onchain htlc.
       *- For internal loop-in htlc_address contains the address of the
       *native segwit (P2WSH) htlc.
       *- For loop-out htlc_address always contains the native segwit (P2WSH)
       *htlc address.
       * </pre>
       *
       * <code>string htlc_address = 7 [deprecated = true];</code>
       * @deprecated looprpc.SwapStatus.htlc_address is deprecated.
       *     See loop.proto;l=393
       * @param value The bytes for htlcAddress to set.
       * @return This builder for chaining.
       */
      @java.lang.Deprecated public Builder setHtlcAddressBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        checkByteStringIsUtf8(value);
        htlcAddress_ = value;
        bitField0_ |= 0x00000080;
        onChanged();
        return this;
      }

      private java.lang.Object htlcAddressP2Wsh_ = "";
      /**
       * <pre>
       * HTLC address (native segwit), used in loop-in and loop-out swaps.
       * </pre>
       *
       * <code>string htlc_address_p2wsh = 12;</code>
       * @return The htlcAddressP2wsh.
       */
      public java.lang.String getHtlcAddressP2Wsh() {
        java.lang.Object ref = htlcAddressP2Wsh_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          htlcAddressP2Wsh_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * HTLC address (native segwit), used in loop-in and loop-out swaps.
       * </pre>
       *
       * <code>string htlc_address_p2wsh = 12;</code>
       * @return The bytes for htlcAddressP2wsh.
       */
      public com.google.protobuf.ByteString
          getHtlcAddressP2WshBytes() {
        java.lang.Object ref = htlcAddressP2Wsh_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          htlcAddressP2Wsh_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * HTLC address (native segwit), used in loop-in and loop-out swaps.
       * </pre>
       *
       * <code>string htlc_address_p2wsh = 12;</code>
       * @param value The htlcAddressP2wsh to set.
       * @return This builder for chaining.
       */
      public Builder setHtlcAddressP2Wsh(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        htlcAddressP2Wsh_ = value;
        bitField0_ |= 0x00000100;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * HTLC address (native segwit), used in loop-in and loop-out swaps.
       * </pre>
       *
       * <code>string htlc_address_p2wsh = 12;</code>
       * @return This builder for chaining.
       */
      public Builder clearHtlcAddressP2Wsh() {
        htlcAddressP2Wsh_ = getDefaultInstance().getHtlcAddressP2Wsh();
        bitField0_ = (bitField0_ & ~0x00000100);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * HTLC address (native segwit), used in loop-in and loop-out swaps.
       * </pre>
       *
       * <code>string htlc_address_p2wsh = 12;</code>
       * @param value The bytes for htlcAddressP2wsh to set.
       * @return This builder for chaining.
       */
      public Builder setHtlcAddressP2WshBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        checkByteStringIsUtf8(value);
        htlcAddressP2Wsh_ = value;
        bitField0_ |= 0x00000100;
        onChanged();
        return this;
      }

      private java.lang.Object htlcAddressP2Tr_ = "";
      /**
       * <pre>
       * The address of the v3 (taproot) htlc. Used for both loop-in and loop-out.
       * </pre>
       *
       * <code>string htlc_address_p2tr = 18;</code>
       * @return The htlcAddressP2tr.
       */
      public java.lang.String getHtlcAddressP2Tr() {
        java.lang.Object ref = htlcAddressP2Tr_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          htlcAddressP2Tr_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * The address of the v3 (taproot) htlc. Used for both loop-in and loop-out.
       * </pre>
       *
       * <code>string htlc_address_p2tr = 18;</code>
       * @return The bytes for htlcAddressP2tr.
       */
      public com.google.protobuf.ByteString
          getHtlcAddressP2TrBytes() {
        java.lang.Object ref = htlcAddressP2Tr_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          htlcAddressP2Tr_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * The address of the v3 (taproot) htlc. Used for both loop-in and loop-out.
       * </pre>
       *
       * <code>string htlc_address_p2tr = 18;</code>
       * @param value The htlcAddressP2tr to set.
       * @return This builder for chaining.
       */
      public Builder setHtlcAddressP2Tr(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        htlcAddressP2Tr_ = value;
        bitField0_ |= 0x00000200;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The address of the v3 (taproot) htlc. Used for both loop-in and loop-out.
       * </pre>
       *
       * <code>string htlc_address_p2tr = 18;</code>
       * @return This builder for chaining.
       */
      public Builder clearHtlcAddressP2Tr() {
        htlcAddressP2Tr_ = getDefaultInstance().getHtlcAddressP2Tr();
        bitField0_ = (bitField0_ & ~0x00000200);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The address of the v3 (taproot) htlc. Used for both loop-in and loop-out.
       * </pre>
       *
       * <code>string htlc_address_p2tr = 18;</code>
       * @param value The bytes for htlcAddressP2tr to set.
       * @return This builder for chaining.
       */
      public Builder setHtlcAddressP2TrBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        checkByteStringIsUtf8(value);
        htlcAddressP2Tr_ = value;
        bitField0_ |= 0x00000200;
        onChanged();
        return this;
      }

      private long costServer_ ;
      /**
       * <pre>
       * Swap server cost
       * </pre>
       *
       * <code>int64 cost_server = 8 [jstype = JS_STRING];</code>
       * @return The costServer.
       */
      @java.lang.Override
      public long getCostServer() {
        return costServer_;
      }
      /**
       * <pre>
       * Swap server cost
       * </pre>
       *
       * <code>int64 cost_server = 8 [jstype = JS_STRING];</code>
       * @param value The costServer to set.
       * @return This builder for chaining.
       */
      public Builder setCostServer(long value) {

        costServer_ = value;
        bitField0_ |= 0x00000400;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Swap server cost
       * </pre>
       *
       * <code>int64 cost_server = 8 [jstype = JS_STRING];</code>
       * @return This builder for chaining.
       */
      public Builder clearCostServer() {
        bitField0_ = (bitField0_ & ~0x00000400);
        costServer_ = 0L;
        onChanged();
        return this;
      }

      private long costOnchain_ ;
      /**
       * <pre>
       * On-chain transaction cost
       * </pre>
       *
       * <code>int64 cost_onchain = 9 [jstype = JS_STRING];</code>
       * @return The costOnchain.
       */
      @java.lang.Override
      public long getCostOnchain() {
        return costOnchain_;
      }
      /**
       * <pre>
       * On-chain transaction cost
       * </pre>
       *
       * <code>int64 cost_onchain = 9 [jstype = JS_STRING];</code>
       * @param value The costOnchain to set.
       * @return This builder for chaining.
       */
      public Builder setCostOnchain(long value) {

        costOnchain_ = value;
        bitField0_ |= 0x00000800;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * On-chain transaction cost
       * </pre>
       *
       * <code>int64 cost_onchain = 9 [jstype = JS_STRING];</code>
       * @return This builder for chaining.
       */
      public Builder clearCostOnchain() {
        bitField0_ = (bitField0_ & ~0x00000800);
        costOnchain_ = 0L;
        onChanged();
        return this;
      }

      private long costOffchain_ ;
      /**
       * <pre>
       * Off-chain routing fees
       * </pre>
       *
       * <code>int64 cost_offchain = 10 [jstype = JS_STRING];</code>
       * @return The costOffchain.
       */
      @java.lang.Override
      public long getCostOffchain() {
        return costOffchain_;
      }
      /**
       * <pre>
       * Off-chain routing fees
       * </pre>
       *
       * <code>int64 cost_offchain = 10 [jstype = JS_STRING];</code>
       * @param value The costOffchain to set.
       * @return This builder for chaining.
       */
      public Builder setCostOffchain(long value) {

        costOffchain_ = value;
        bitField0_ |= 0x00001000;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Off-chain routing fees
       * </pre>
       *
       * <code>int64 cost_offchain = 10 [jstype = JS_STRING];</code>
       * @return This builder for chaining.
       */
      public Builder clearCostOffchain() {
        bitField0_ = (bitField0_ & ~0x00001000);
        costOffchain_ = 0L;
        onChanged();
        return this;
      }

      private com.google.protobuf.ByteString lastHop_ = com.google.protobuf.ByteString.EMPTY;
      /**
       * <pre>
       * Optional last hop if provided in the loop in request.
       * </pre>
       *
       * <code>bytes last_hop = 16;</code>
       * @return The lastHop.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString getLastHop() {
        return lastHop_;
      }
      /**
       * <pre>
       * Optional last hop if provided in the loop in request.
       * </pre>
       *
       * <code>bytes last_hop = 16;</code>
       * @param value The lastHop to set.
       * @return This builder for chaining.
       */
      public Builder setLastHop(com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        lastHop_ = value;
        bitField0_ |= 0x00002000;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Optional last hop if provided in the loop in request.
       * </pre>
       *
       * <code>bytes last_hop = 16;</code>
       * @return This builder for chaining.
       */
      public Builder clearLastHop() {
        bitField0_ = (bitField0_ & ~0x00002000);
        lastHop_ = getDefaultInstance().getLastHop();
        onChanged();
        return this;
      }

      private com.google.protobuf.Internal.LongList outgoingChanSet_ = emptyLongList();
      private void ensureOutgoingChanSetIsMutable() {
        if (!outgoingChanSet_.isModifiable()) {
          outgoingChanSet_ = makeMutableCopy(outgoingChanSet_);
        }
        bitField0_ |= 0x00004000;
      }
      /**
       * <pre>
       * Optional outgoing channel set if provided in the loop out request.
       * </pre>
       *
       * <code>repeated uint64 outgoing_chan_set = 17 [jstype = JS_STRING];</code>
       * @return A list containing the outgoingChanSet.
       */
      public java.util.List<java.lang.Long>
          getOutgoingChanSetList() {
        outgoingChanSet_.makeImmutable();
        return outgoingChanSet_;
      }
      /**
       * <pre>
       * Optional outgoing channel set if provided in the loop out request.
       * </pre>
       *
       * <code>repeated uint64 outgoing_chan_set = 17 [jstype = JS_STRING];</code>
       * @return The count of outgoingChanSet.
       */
      public int getOutgoingChanSetCount() {
        return outgoingChanSet_.size();
      }
      /**
       * <pre>
       * Optional outgoing channel set if provided in the loop out request.
       * </pre>
       *
       * <code>repeated uint64 outgoing_chan_set = 17 [jstype = JS_STRING];</code>
       * @param index The index of the element to return.
       * @return The outgoingChanSet at the given index.
       */
      public long getOutgoingChanSet(int index) {
        return outgoingChanSet_.getLong(index);
      }
      /**
       * <pre>
       * Optional outgoing channel set if provided in the loop out request.
       * </pre>
       *
       * <code>repeated uint64 outgoing_chan_set = 17 [jstype = JS_STRING];</code>
       * @param index The index to set the value at.
       * @param value The outgoingChanSet to set.
       * @return This builder for chaining.
       */
      public Builder setOutgoingChanSet(
          int index, long value) {

        ensureOutgoingChanSetIsMutable();
        outgoingChanSet_.setLong(index, value);
        bitField0_ |= 0x00004000;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Optional outgoing channel set if provided in the loop out request.
       * </pre>
       *
       * <code>repeated uint64 outgoing_chan_set = 17 [jstype = JS_STRING];</code>
       * @param value The outgoingChanSet to add.
       * @return This builder for chaining.
       */
      public Builder addOutgoingChanSet(long value) {

        ensureOutgoingChanSetIsMutable();
        outgoingChanSet_.addLong(value);
        bitField0_ |= 0x00004000;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Optional outgoing channel set if provided in the loop out request.
       * </pre>
       *
       * <code>repeated uint64 outgoing_chan_set = 17 [jstype = JS_STRING];</code>
       * @param values The outgoingChanSet to add.
       * @return This builder for chaining.
       */
      public Builder addAllOutgoingChanSet(
          java.lang.Iterable<? extends java.lang.Long> values) {
        ensureOutgoingChanSetIsMutable();
        com.google.protobuf.AbstractMessageLite.Builder.addAll(
            values, outgoingChanSet_);
        bitField0_ |= 0x00004000;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Optional outgoing channel set if provided in the loop out request.
       * </pre>
       *
       * <code>repeated uint64 outgoing_chan_set = 17 [jstype = JS_STRING];</code>
       * @return This builder for chaining.
       */
      public Builder clearOutgoingChanSet() {
        outgoingChanSet_ = emptyLongList();
        bitField0_ = (bitField0_ & ~0x00004000);
        onChanged();
        return this;
      }

      private java.lang.Object label_ = "";
      /**
       * <pre>
       * An optional label given to the swap on creation.
       * </pre>
       *
       * <code>string label = 15;</code>
       * @return The label.
       */
      public java.lang.String getLabel() {
        java.lang.Object ref = label_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          label_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * An optional label given to the swap on creation.
       * </pre>
       *
       * <code>string label = 15;</code>
       * @return The bytes for label.
       */
      public com.google.protobuf.ByteString
          getLabelBytes() {
        java.lang.Object ref = label_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          label_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * An optional label given to the swap on creation.
       * </pre>
       *
       * <code>string label = 15;</code>
       * @param value The label to set.
       * @return This builder for chaining.
       */
      public Builder setLabel(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        label_ = value;
        bitField0_ |= 0x00008000;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * An optional label given to the swap on creation.
       * </pre>
       *
       * <code>string label = 15;</code>
       * @return This builder for chaining.
       */
      public Builder clearLabel() {
        label_ = getDefaultInstance().getLabel();
        bitField0_ = (bitField0_ & ~0x00008000);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * An optional label given to the swap on creation.
       * </pre>
       *
       * <code>string label = 15;</code>
       * @param value The bytes for label to set.
       * @return This builder for chaining.
       */
      public Builder setLabelBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        checkByteStringIsUtf8(value);
        label_ = value;
        bitField0_ |= 0x00008000;
        onChanged();
        return this;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:looprpc.SwapStatus)
    }

    // @@protoc_insertion_point(class_scope:looprpc.SwapStatus)
    private static final looprpc.Loop.SwapStatus DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new looprpc.Loop.SwapStatus();
    }

    public static looprpc.Loop.SwapStatus getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<SwapStatus>
        PARSER = new com.google.protobuf.AbstractParser<SwapStatus>() {
      @java.lang.Override
      public SwapStatus parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<SwapStatus> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<SwapStatus> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public looprpc.Loop.SwapStatus getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface ListSwapsRequestOrBuilder extends
      // @@protoc_insertion_point(interface_extends:looprpc.ListSwapsRequest)
      com.google.protobuf.MessageOrBuilder {
  }
  /**
   * Protobuf type {@code looprpc.ListSwapsRequest}
   */
  public static final class ListSwapsRequest extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:looprpc.ListSwapsRequest)
      ListSwapsRequestOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use ListSwapsRequest.newBuilder() to construct.
    private ListSwapsRequest(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private ListSwapsRequest() {
    }

    @java.lang.Override
    @SuppressWarnings({"unused"})
    protected java.lang.Object newInstance(
        UnusedPrivateParameter unused) {
      return new ListSwapsRequest();
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return looprpc.Loop.internal_static_looprpc_ListSwapsRequest_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return looprpc.Loop.internal_static_looprpc_ListSwapsRequest_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              looprpc.Loop.ListSwapsRequest.class, looprpc.Loop.ListSwapsRequest.Builder.class);
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof looprpc.Loop.ListSwapsRequest)) {
        return super.equals(obj);
      }
      looprpc.Loop.ListSwapsRequest other = (looprpc.Loop.ListSwapsRequest) obj;

      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static looprpc.Loop.ListSwapsRequest parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static looprpc.Loop.ListSwapsRequest parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static looprpc.Loop.ListSwapsRequest parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static looprpc.Loop.ListSwapsRequest parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static looprpc.Loop.ListSwapsRequest parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static looprpc.Loop.ListSwapsRequest parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static looprpc.Loop.ListSwapsRequest parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static looprpc.Loop.ListSwapsRequest parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static looprpc.Loop.ListSwapsRequest parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static looprpc.Loop.ListSwapsRequest parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static looprpc.Loop.ListSwapsRequest parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static looprpc.Loop.ListSwapsRequest parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(looprpc.Loop.ListSwapsRequest prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * Protobuf type {@code looprpc.ListSwapsRequest}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:looprpc.ListSwapsRequest)
        looprpc.Loop.ListSwapsRequestOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return looprpc.Loop.internal_static_looprpc_ListSwapsRequest_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return looprpc.Loop.internal_static_looprpc_ListSwapsRequest_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                looprpc.Loop.ListSwapsRequest.class, looprpc.Loop.ListSwapsRequest.Builder.class);
      }

      // Construct using looprpc.Loop.ListSwapsRequest.newBuilder()
      private Builder() {

      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);

      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return looprpc.Loop.internal_static_looprpc_ListSwapsRequest_descriptor;
      }

      @java.lang.Override
      public looprpc.Loop.ListSwapsRequest getDefaultInstanceForType() {
        return looprpc.Loop.ListSwapsRequest.getDefaultInstance();
      }

      @java.lang.Override
      public looprpc.Loop.ListSwapsRequest build() {
        looprpc.Loop.ListSwapsRequest result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public looprpc.Loop.ListSwapsRequest buildPartial() {
        looprpc.Loop.ListSwapsRequest result = new looprpc.Loop.ListSwapsRequest(this);
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof looprpc.Loop.ListSwapsRequest) {
          return mergeFrom((looprpc.Loop.ListSwapsRequest)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(looprpc.Loop.ListSwapsRequest other) {
        if (other == looprpc.Loop.ListSwapsRequest.getDefaultInstance()) return this;
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:looprpc.ListSwapsRequest)
    }

    // @@protoc_insertion_point(class_scope:looprpc.ListSwapsRequest)
    private static final looprpc.Loop.ListSwapsRequest DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new looprpc.Loop.ListSwapsRequest();
    }

    public static looprpc.Loop.ListSwapsRequest getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<ListSwapsRequest>
        PARSER = new com.google.protobuf.AbstractParser<ListSwapsRequest>() {
      @java.lang.Override
      public ListSwapsRequest parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<ListSwapsRequest> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<ListSwapsRequest> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public looprpc.Loop.ListSwapsRequest getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface ListSwapsResponseOrBuilder extends
      // @@protoc_insertion_point(interface_extends:looprpc.ListSwapsResponse)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     *
     *The list of all currently known swaps and their status.
     * </pre>
     *
     * <code>repeated .looprpc.SwapStatus swaps = 1;</code>
     */
    java.util.List<looprpc.Loop.SwapStatus> 
        getSwapsList();
    /**
     * <pre>
     *
     *The list of all currently known swaps and their status.
     * </pre>
     *
     * <code>repeated .looprpc.SwapStatus swaps = 1;</code>
     */
    looprpc.Loop.SwapStatus getSwaps(int index);
    /**
     * <pre>
     *
     *The list of all currently known swaps and their status.
     * </pre>
     *
     * <code>repeated .looprpc.SwapStatus swaps = 1;</code>
     */
    int getSwapsCount();
    /**
     * <pre>
     *
     *The list of all currently known swaps and their status.
     * </pre>
     *
     * <code>repeated .looprpc.SwapStatus swaps = 1;</code>
     */
    java.util.List<? extends looprpc.Loop.SwapStatusOrBuilder> 
        getSwapsOrBuilderList();
    /**
     * <pre>
     *
     *The list of all currently known swaps and their status.
     * </pre>
     *
     * <code>repeated .looprpc.SwapStatus swaps = 1;</code>
     */
    looprpc.Loop.SwapStatusOrBuilder getSwapsOrBuilder(
        int index);
  }
  /**
   * Protobuf type {@code looprpc.ListSwapsResponse}
   */
  public static final class ListSwapsResponse extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:looprpc.ListSwapsResponse)
      ListSwapsResponseOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use ListSwapsResponse.newBuilder() to construct.
    private ListSwapsResponse(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private ListSwapsResponse() {
      swaps_ = java.util.Collections.emptyList();
    }

    @java.lang.Override
    @SuppressWarnings({"unused"})
    protected java.lang.Object newInstance(
        UnusedPrivateParameter unused) {
      return new ListSwapsResponse();
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return looprpc.Loop.internal_static_looprpc_ListSwapsResponse_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return looprpc.Loop.internal_static_looprpc_ListSwapsResponse_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              looprpc.Loop.ListSwapsResponse.class, looprpc.Loop.ListSwapsResponse.Builder.class);
    }

    public static final int SWAPS_FIELD_NUMBER = 1;
    @SuppressWarnings("serial")
    private java.util.List<looprpc.Loop.SwapStatus> swaps_;
    /**
     * <pre>
     *
     *The list of all currently known swaps and their status.
     * </pre>
     *
     * <code>repeated .looprpc.SwapStatus swaps = 1;</code>
     */
    @java.lang.Override
    public java.util.List<looprpc.Loop.SwapStatus> getSwapsList() {
      return swaps_;
    }
    /**
     * <pre>
     *
     *The list of all currently known swaps and their status.
     * </pre>
     *
     * <code>repeated .looprpc.SwapStatus swaps = 1;</code>
     */
    @java.lang.Override
    public java.util.List<? extends looprpc.Loop.SwapStatusOrBuilder> 
        getSwapsOrBuilderList() {
      return swaps_;
    }
    /**
     * <pre>
     *
     *The list of all currently known swaps and their status.
     * </pre>
     *
     * <code>repeated .looprpc.SwapStatus swaps = 1;</code>
     */
    @java.lang.Override
    public int getSwapsCount() {
      return swaps_.size();
    }
    /**
     * <pre>
     *
     *The list of all currently known swaps and their status.
     * </pre>
     *
     * <code>repeated .looprpc.SwapStatus swaps = 1;</code>
     */
    @java.lang.Override
    public looprpc.Loop.SwapStatus getSwaps(int index) {
      return swaps_.get(index);
    }
    /**
     * <pre>
     *
     *The list of all currently known swaps and their status.
     * </pre>
     *
     * <code>repeated .looprpc.SwapStatus swaps = 1;</code>
     */
    @java.lang.Override
    public looprpc.Loop.SwapStatusOrBuilder getSwapsOrBuilder(
        int index) {
      return swaps_.get(index);
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      for (int i = 0; i < swaps_.size(); i++) {
        output.writeMessage(1, swaps_.get(i));
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      for (int i = 0; i < swaps_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(1, swaps_.get(i));
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof looprpc.Loop.ListSwapsResponse)) {
        return super.equals(obj);
      }
      looprpc.Loop.ListSwapsResponse other = (looprpc.Loop.ListSwapsResponse) obj;

      if (!getSwapsList()
          .equals(other.getSwapsList())) return false;
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (getSwapsCount() > 0) {
        hash = (37 * hash) + SWAPS_FIELD_NUMBER;
        hash = (53 * hash) + getSwapsList().hashCode();
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static looprpc.Loop.ListSwapsResponse parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static looprpc.Loop.ListSwapsResponse parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static looprpc.Loop.ListSwapsResponse parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static looprpc.Loop.ListSwapsResponse parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static looprpc.Loop.ListSwapsResponse parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static looprpc.Loop.ListSwapsResponse parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static looprpc.Loop.ListSwapsResponse parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static looprpc.Loop.ListSwapsResponse parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static looprpc.Loop.ListSwapsResponse parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static looprpc.Loop.ListSwapsResponse parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static looprpc.Loop.ListSwapsResponse parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static looprpc.Loop.ListSwapsResponse parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(looprpc.Loop.ListSwapsResponse prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * Protobuf type {@code looprpc.ListSwapsResponse}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:looprpc.ListSwapsResponse)
        looprpc.Loop.ListSwapsResponseOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return looprpc.Loop.internal_static_looprpc_ListSwapsResponse_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return looprpc.Loop.internal_static_looprpc_ListSwapsResponse_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                looprpc.Loop.ListSwapsResponse.class, looprpc.Loop.ListSwapsResponse.Builder.class);
      }

      // Construct using looprpc.Loop.ListSwapsResponse.newBuilder()
      private Builder() {

      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);

      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        if (swapsBuilder_ == null) {
          swaps_ = java.util.Collections.emptyList();
        } else {
          swaps_ = null;
          swapsBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000001);
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return looprpc.Loop.internal_static_looprpc_ListSwapsResponse_descriptor;
      }

      @java.lang.Override
      public looprpc.Loop.ListSwapsResponse getDefaultInstanceForType() {
        return looprpc.Loop.ListSwapsResponse.getDefaultInstance();
      }

      @java.lang.Override
      public looprpc.Loop.ListSwapsResponse build() {
        looprpc.Loop.ListSwapsResponse result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public looprpc.Loop.ListSwapsResponse buildPartial() {
        looprpc.Loop.ListSwapsResponse result = new looprpc.Loop.ListSwapsResponse(this);
        buildPartialRepeatedFields(result);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartialRepeatedFields(looprpc.Loop.ListSwapsResponse result) {
        if (swapsBuilder_ == null) {
          if (((bitField0_ & 0x00000001) != 0)) {
            swaps_ = java.util.Collections.unmodifiableList(swaps_);
            bitField0_ = (bitField0_ & ~0x00000001);
          }
          result.swaps_ = swaps_;
        } else {
          result.swaps_ = swapsBuilder_.build();
        }
      }

      private void buildPartial0(looprpc.Loop.ListSwapsResponse result) {
        int from_bitField0_ = bitField0_;
      }

      @java.lang.Override
      public Builder clone() {
        return super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof looprpc.Loop.ListSwapsResponse) {
          return mergeFrom((looprpc.Loop.ListSwapsResponse)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(looprpc.Loop.ListSwapsResponse other) {
        if (other == looprpc.Loop.ListSwapsResponse.getDefaultInstance()) return this;
        if (swapsBuilder_ == null) {
          if (!other.swaps_.isEmpty()) {
            if (swaps_.isEmpty()) {
              swaps_ = other.swaps_;
              bitField0_ = (bitField0_ & ~0x00000001);
            } else {
              ensureSwapsIsMutable();
              swaps_.addAll(other.swaps_);
            }
            onChanged();
          }
        } else {
          if (!other.swaps_.isEmpty()) {
            if (swapsBuilder_.isEmpty()) {
              swapsBuilder_.dispose();
              swapsBuilder_ = null;
              swaps_ = other.swaps_;
              bitField0_ = (bitField0_ & ~0x00000001);
              swapsBuilder_ = 
                com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
                   getSwapsFieldBuilder() : null;
            } else {
              swapsBuilder_.addAllMessages(other.swaps_);
            }
          }
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10: {
                looprpc.Loop.SwapStatus m =
                    input.readMessage(
                        looprpc.Loop.SwapStatus.parser(),
                        extensionRegistry);
                if (swapsBuilder_ == null) {
                  ensureSwapsIsMutable();
                  swaps_.add(m);
                } else {
                  swapsBuilder_.addMessage(m);
                }
                break;
              } // case 10
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private java.util.List<looprpc.Loop.SwapStatus> swaps_ =
        java.util.Collections.emptyList();
      private void ensureSwapsIsMutable() {
        if (!((bitField0_ & 0x00000001) != 0)) {
          swaps_ = new java.util.ArrayList<looprpc.Loop.SwapStatus>(swaps_);
          bitField0_ |= 0x00000001;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
          looprpc.Loop.SwapStatus, looprpc.Loop.SwapStatus.Builder, looprpc.Loop.SwapStatusOrBuilder> swapsBuilder_;

      /**
       * <pre>
       *
       *The list of all currently known swaps and their status.
       * </pre>
       *
       * <code>repeated .looprpc.SwapStatus swaps = 1;</code>
       */
      public java.util.List<looprpc.Loop.SwapStatus> getSwapsList() {
        if (swapsBuilder_ == null) {
          return java.util.Collections.unmodifiableList(swaps_);
        } else {
          return swapsBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       *
       *The list of all currently known swaps and their status.
       * </pre>
       *
       * <code>repeated .looprpc.SwapStatus swaps = 1;</code>
       */
      public int getSwapsCount() {
        if (swapsBuilder_ == null) {
          return swaps_.size();
        } else {
          return swapsBuilder_.getCount();
        }
      }
      /**
       * <pre>
       *
       *The list of all currently known swaps and their status.
       * </pre>
       *
       * <code>repeated .looprpc.SwapStatus swaps = 1;</code>
       */
      public looprpc.Loop.SwapStatus getSwaps(int index) {
        if (swapsBuilder_ == null) {
          return swaps_.get(index);
        } else {
          return swapsBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       *
       *The list of all currently known swaps and their status.
       * </pre>
       *
       * <code>repeated .looprpc.SwapStatus swaps = 1;</code>
       */
      public Builder setSwaps(
          int index, looprpc.Loop.SwapStatus value) {
        if (swapsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureSwapsIsMutable();
          swaps_.set(index, value);
          onChanged();
        } else {
          swapsBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       *
       *The list of all currently known swaps and their status.
       * </pre>
       *
       * <code>repeated .looprpc.SwapStatus swaps = 1;</code>
       */
      public Builder setSwaps(
          int index, looprpc.Loop.SwapStatus.Builder builderForValue) {
        if (swapsBuilder_ == null) {
          ensureSwapsIsMutable();
          swaps_.set(index, builderForValue.build());
          onChanged();
        } else {
          swapsBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       *
       *The list of all currently known swaps and their status.
       * </pre>
       *
       * <code>repeated .looprpc.SwapStatus swaps = 1;</code>
       */
      public Builder addSwaps(looprpc.Loop.SwapStatus value) {
        if (swapsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureSwapsIsMutable();
          swaps_.add(value);
          onChanged();
        } else {
          swapsBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       *
       *The list of all currently known swaps and their status.
       * </pre>
       *
       * <code>repeated .looprpc.SwapStatus swaps = 1;</code>
       */
      public Builder addSwaps(
          int index, looprpc.Loop.SwapStatus value) {
        if (swapsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureSwapsIsMutable();
          swaps_.add(index, value);
          onChanged();
        } else {
          swapsBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       *
       *The list of all currently known swaps and their status.
       * </pre>
       *
       * <code>repeated .looprpc.SwapStatus swaps = 1;</code>
       */
      public Builder addSwaps(
          looprpc.Loop.SwapStatus.Builder builderForValue) {
        if (swapsBuilder_ == null) {
          ensureSwapsIsMutable();
          swaps_.add(builderForValue.build());
          onChanged();
        } else {
          swapsBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       *
       *The list of all currently known swaps and their status.
       * </pre>
       *
       * <code>repeated .looprpc.SwapStatus swaps = 1;</code>
       */
      public Builder addSwaps(
          int index, looprpc.Loop.SwapStatus.Builder builderForValue) {
        if (swapsBuilder_ == null) {
          ensureSwapsIsMutable();
          swaps_.add(index, builderForValue.build());
          onChanged();
        } else {
          swapsBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       *
       *The list of all currently known swaps and their status.
       * </pre>
       *
       * <code>repeated .looprpc.SwapStatus swaps = 1;</code>
       */
      public Builder addAllSwaps(
          java.lang.Iterable<? extends looprpc.Loop.SwapStatus> values) {
        if (swapsBuilder_ == null) {
          ensureSwapsIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, swaps_);
          onChanged();
        } else {
          swapsBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       *
       *The list of all currently known swaps and their status.
       * </pre>
       *
       * <code>repeated .looprpc.SwapStatus swaps = 1;</code>
       */
      public Builder clearSwaps() {
        if (swapsBuilder_ == null) {
          swaps_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000001);
          onChanged();
        } else {
          swapsBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       *
       *The list of all currently known swaps and their status.
       * </pre>
       *
       * <code>repeated .looprpc.SwapStatus swaps = 1;</code>
       */
      public Builder removeSwaps(int index) {
        if (swapsBuilder_ == null) {
          ensureSwapsIsMutable();
          swaps_.remove(index);
          onChanged();
        } else {
          swapsBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       *
       *The list of all currently known swaps and their status.
       * </pre>
       *
       * <code>repeated .looprpc.SwapStatus swaps = 1;</code>
       */
      public looprpc.Loop.SwapStatus.Builder getSwapsBuilder(
          int index) {
        return getSwapsFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       *
       *The list of all currently known swaps and their status.
       * </pre>
       *
       * <code>repeated .looprpc.SwapStatus swaps = 1;</code>
       */
      public looprpc.Loop.SwapStatusOrBuilder getSwapsOrBuilder(
          int index) {
        if (swapsBuilder_ == null) {
          return swaps_.get(index);  } else {
          return swapsBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       *
       *The list of all currently known swaps and their status.
       * </pre>
       *
       * <code>repeated .looprpc.SwapStatus swaps = 1;</code>
       */
      public java.util.List<? extends looprpc.Loop.SwapStatusOrBuilder> 
           getSwapsOrBuilderList() {
        if (swapsBuilder_ != null) {
          return swapsBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(swaps_);
        }
      }
      /**
       * <pre>
       *
       *The list of all currently known swaps and their status.
       * </pre>
       *
       * <code>repeated .looprpc.SwapStatus swaps = 1;</code>
       */
      public looprpc.Loop.SwapStatus.Builder addSwapsBuilder() {
        return getSwapsFieldBuilder().addBuilder(
            looprpc.Loop.SwapStatus.getDefaultInstance());
      }
      /**
       * <pre>
       *
       *The list of all currently known swaps and their status.
       * </pre>
       *
       * <code>repeated .looprpc.SwapStatus swaps = 1;</code>
       */
      public looprpc.Loop.SwapStatus.Builder addSwapsBuilder(
          int index) {
        return getSwapsFieldBuilder().addBuilder(
            index, looprpc.Loop.SwapStatus.getDefaultInstance());
      }
      /**
       * <pre>
       *
       *The list of all currently known swaps and their status.
       * </pre>
       *
       * <code>repeated .looprpc.SwapStatus swaps = 1;</code>
       */
      public java.util.List<looprpc.Loop.SwapStatus.Builder> 
           getSwapsBuilderList() {
        return getSwapsFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilderV3<
          looprpc.Loop.SwapStatus, looprpc.Loop.SwapStatus.Builder, looprpc.Loop.SwapStatusOrBuilder> 
          getSwapsFieldBuilder() {
        if (swapsBuilder_ == null) {
          swapsBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<
              looprpc.Loop.SwapStatus, looprpc.Loop.SwapStatus.Builder, looprpc.Loop.SwapStatusOrBuilder>(
                  swaps_,
                  ((bitField0_ & 0x00000001) != 0),
                  getParentForChildren(),
                  isClean());
          swaps_ = null;
        }
        return swapsBuilder_;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:looprpc.ListSwapsResponse)
    }

    // @@protoc_insertion_point(class_scope:looprpc.ListSwapsResponse)
    private static final looprpc.Loop.ListSwapsResponse DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new looprpc.Loop.ListSwapsResponse();
    }

    public static looprpc.Loop.ListSwapsResponse getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<ListSwapsResponse>
        PARSER = new com.google.protobuf.AbstractParser<ListSwapsResponse>() {
      @java.lang.Override
      public ListSwapsResponse parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<ListSwapsResponse> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<ListSwapsResponse> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public looprpc.Loop.ListSwapsResponse getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface SwapInfoRequestOrBuilder extends
      // @@protoc_insertion_point(interface_extends:looprpc.SwapInfoRequest)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     *
     *The swap identifier which currently is the hash that locks the HTLCs. When
     *using REST, this field must be encoded as URL safe base64.
     * </pre>
     *
     * <code>bytes id = 1;</code>
     * @return The id.
     */
    com.google.protobuf.ByteString getId();
  }
  /**
   * Protobuf type {@code looprpc.SwapInfoRequest}
   */
  public static final class SwapInfoRequest extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:looprpc.SwapInfoRequest)
      SwapInfoRequestOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use SwapInfoRequest.newBuilder() to construct.
    private SwapInfoRequest(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private SwapInfoRequest() {
      id_ = com.google.protobuf.ByteString.EMPTY;
    }

    @java.lang.Override
    @SuppressWarnings({"unused"})
    protected java.lang.Object newInstance(
        UnusedPrivateParameter unused) {
      return new SwapInfoRequest();
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return looprpc.Loop.internal_static_looprpc_SwapInfoRequest_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return looprpc.Loop.internal_static_looprpc_SwapInfoRequest_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              looprpc.Loop.SwapInfoRequest.class, looprpc.Loop.SwapInfoRequest.Builder.class);
    }

    public static final int ID_FIELD_NUMBER = 1;
    private com.google.protobuf.ByteString id_ = com.google.protobuf.ByteString.EMPTY;
    /**
     * <pre>
     *
     *The swap identifier which currently is the hash that locks the HTLCs. When
     *using REST, this field must be encoded as URL safe base64.
     * </pre>
     *
     * <code>bytes id = 1;</code>
     * @return The id.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString getId() {
      return id_;
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (!id_.isEmpty()) {
        output.writeBytes(1, id_);
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (!id_.isEmpty()) {
        size += com.google.protobuf.CodedOutputStream
          .computeBytesSize(1, id_);
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof looprpc.Loop.SwapInfoRequest)) {
        return super.equals(obj);
      }
      looprpc.Loop.SwapInfoRequest other = (looprpc.Loop.SwapInfoRequest) obj;

      if (!getId()
          .equals(other.getId())) return false;
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      hash = (37 * hash) + ID_FIELD_NUMBER;
      hash = (53 * hash) + getId().hashCode();
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static looprpc.Loop.SwapInfoRequest parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static looprpc.Loop.SwapInfoRequest parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static looprpc.Loop.SwapInfoRequest parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static looprpc.Loop.SwapInfoRequest parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static looprpc.Loop.SwapInfoRequest parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static looprpc.Loop.SwapInfoRequest parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static looprpc.Loop.SwapInfoRequest parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static looprpc.Loop.SwapInfoRequest parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static looprpc.Loop.SwapInfoRequest parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static looprpc.Loop.SwapInfoRequest parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static looprpc.Loop.SwapInfoRequest parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static looprpc.Loop.SwapInfoRequest parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(looprpc.Loop.SwapInfoRequest prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * Protobuf type {@code looprpc.SwapInfoRequest}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:looprpc.SwapInfoRequest)
        looprpc.Loop.SwapInfoRequestOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return looprpc.Loop.internal_static_looprpc_SwapInfoRequest_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return looprpc.Loop.internal_static_looprpc_SwapInfoRequest_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                looprpc.Loop.SwapInfoRequest.class, looprpc.Loop.SwapInfoRequest.Builder.class);
      }

      // Construct using looprpc.Loop.SwapInfoRequest.newBuilder()
      private Builder() {

      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);

      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        id_ = com.google.protobuf.ByteString.EMPTY;
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return looprpc.Loop.internal_static_looprpc_SwapInfoRequest_descriptor;
      }

      @java.lang.Override
      public looprpc.Loop.SwapInfoRequest getDefaultInstanceForType() {
        return looprpc.Loop.SwapInfoRequest.getDefaultInstance();
      }

      @java.lang.Override
      public looprpc.Loop.SwapInfoRequest build() {
        looprpc.Loop.SwapInfoRequest result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public looprpc.Loop.SwapInfoRequest buildPartial() {
        looprpc.Loop.SwapInfoRequest result = new looprpc.Loop.SwapInfoRequest(this);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartial0(looprpc.Loop.SwapInfoRequest result) {
        int from_bitField0_ = bitField0_;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.id_ = id_;
        }
      }

      @java.lang.Override
      public Builder clone() {
        return super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof looprpc.Loop.SwapInfoRequest) {
          return mergeFrom((looprpc.Loop.SwapInfoRequest)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(looprpc.Loop.SwapInfoRequest other) {
        if (other == looprpc.Loop.SwapInfoRequest.getDefaultInstance()) return this;
        if (other.getId() != com.google.protobuf.ByteString.EMPTY) {
          setId(other.getId());
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10: {
                id_ = input.readBytes();
                bitField0_ |= 0x00000001;
                break;
              } // case 10
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private com.google.protobuf.ByteString id_ = com.google.protobuf.ByteString.EMPTY;
      /**
       * <pre>
       *
       *The swap identifier which currently is the hash that locks the HTLCs. When
       *using REST, this field must be encoded as URL safe base64.
       * </pre>
       *
       * <code>bytes id = 1;</code>
       * @return The id.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString getId() {
        return id_;
      }
      /**
       * <pre>
       *
       *The swap identifier which currently is the hash that locks the HTLCs. When
       *using REST, this field must be encoded as URL safe base64.
       * </pre>
       *
       * <code>bytes id = 1;</code>
       * @param value The id to set.
       * @return This builder for chaining.
       */
      public Builder setId(com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        id_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       *
       *The swap identifier which currently is the hash that locks the HTLCs. When
       *using REST, this field must be encoded as URL safe base64.
       * </pre>
       *
       * <code>bytes id = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearId() {
        bitField0_ = (bitField0_ & ~0x00000001);
        id_ = getDefaultInstance().getId();
        onChanged();
        return this;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:looprpc.SwapInfoRequest)
    }

    // @@protoc_insertion_point(class_scope:looprpc.SwapInfoRequest)
    private static final looprpc.Loop.SwapInfoRequest DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new looprpc.Loop.SwapInfoRequest();
    }

    public static looprpc.Loop.SwapInfoRequest getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<SwapInfoRequest>
        PARSER = new com.google.protobuf.AbstractParser<SwapInfoRequest>() {
      @java.lang.Override
      public SwapInfoRequest parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<SwapInfoRequest> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<SwapInfoRequest> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public looprpc.Loop.SwapInfoRequest getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface TermsRequestOrBuilder extends
      // @@protoc_insertion_point(interface_extends:looprpc.TermsRequest)
      com.google.protobuf.MessageOrBuilder {
  }
  /**
   * Protobuf type {@code looprpc.TermsRequest}
   */
  public static final class TermsRequest extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:looprpc.TermsRequest)
      TermsRequestOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use TermsRequest.newBuilder() to construct.
    private TermsRequest(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private TermsRequest() {
    }

    @java.lang.Override
    @SuppressWarnings({"unused"})
    protected java.lang.Object newInstance(
        UnusedPrivateParameter unused) {
      return new TermsRequest();
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return looprpc.Loop.internal_static_looprpc_TermsRequest_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return looprpc.Loop.internal_static_looprpc_TermsRequest_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              looprpc.Loop.TermsRequest.class, looprpc.Loop.TermsRequest.Builder.class);
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof looprpc.Loop.TermsRequest)) {
        return super.equals(obj);
      }
      looprpc.Loop.TermsRequest other = (looprpc.Loop.TermsRequest) obj;

      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static looprpc.Loop.TermsRequest parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static looprpc.Loop.TermsRequest parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static looprpc.Loop.TermsRequest parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static looprpc.Loop.TermsRequest parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static looprpc.Loop.TermsRequest parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static looprpc.Loop.TermsRequest parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static looprpc.Loop.TermsRequest parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static looprpc.Loop.TermsRequest parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static looprpc.Loop.TermsRequest parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static looprpc.Loop.TermsRequest parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static looprpc.Loop.TermsRequest parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static looprpc.Loop.TermsRequest parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(looprpc.Loop.TermsRequest prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * Protobuf type {@code looprpc.TermsRequest}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:looprpc.TermsRequest)
        looprpc.Loop.TermsRequestOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return looprpc.Loop.internal_static_looprpc_TermsRequest_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return looprpc.Loop.internal_static_looprpc_TermsRequest_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                looprpc.Loop.TermsRequest.class, looprpc.Loop.TermsRequest.Builder.class);
      }

      // Construct using looprpc.Loop.TermsRequest.newBuilder()
      private Builder() {

      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);

      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return looprpc.Loop.internal_static_looprpc_TermsRequest_descriptor;
      }

      @java.lang.Override
      public looprpc.Loop.TermsRequest getDefaultInstanceForType() {
        return looprpc.Loop.TermsRequest.getDefaultInstance();
      }

      @java.lang.Override
      public looprpc.Loop.TermsRequest build() {
        looprpc.Loop.TermsRequest result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public looprpc.Loop.TermsRequest buildPartial() {
        looprpc.Loop.TermsRequest result = new looprpc.Loop.TermsRequest(this);
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof looprpc.Loop.TermsRequest) {
          return mergeFrom((looprpc.Loop.TermsRequest)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(looprpc.Loop.TermsRequest other) {
        if (other == looprpc.Loop.TermsRequest.getDefaultInstance()) return this;
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:looprpc.TermsRequest)
    }

    // @@protoc_insertion_point(class_scope:looprpc.TermsRequest)
    private static final looprpc.Loop.TermsRequest DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new looprpc.Loop.TermsRequest();
    }

    public static looprpc.Loop.TermsRequest getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<TermsRequest>
        PARSER = new com.google.protobuf.AbstractParser<TermsRequest>() {
      @java.lang.Override
      public TermsRequest parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<TermsRequest> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<TermsRequest> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public looprpc.Loop.TermsRequest getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface InTermsResponseOrBuilder extends
      // @@protoc_insertion_point(interface_extends:looprpc.InTermsResponse)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     *
     *Minimum swap amount (sat)
     * </pre>
     *
     * <code>int64 min_swap_amount = 5 [jstype = JS_STRING];</code>
     * @return The minSwapAmount.
     */
    long getMinSwapAmount();

    /**
     * <pre>
     *
     *Maximum swap amount (sat)
     * </pre>
     *
     * <code>int64 max_swap_amount = 6 [jstype = JS_STRING];</code>
     * @return The maxSwapAmount.
     */
    long getMaxSwapAmount();
  }
  /**
   * Protobuf type {@code looprpc.InTermsResponse}
   */
  public static final class InTermsResponse extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:looprpc.InTermsResponse)
      InTermsResponseOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use InTermsResponse.newBuilder() to construct.
    private InTermsResponse(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private InTermsResponse() {
    }

    @java.lang.Override
    @SuppressWarnings({"unused"})
    protected java.lang.Object newInstance(
        UnusedPrivateParameter unused) {
      return new InTermsResponse();
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return looprpc.Loop.internal_static_looprpc_InTermsResponse_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return looprpc.Loop.internal_static_looprpc_InTermsResponse_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              looprpc.Loop.InTermsResponse.class, looprpc.Loop.InTermsResponse.Builder.class);
    }

    public static final int MIN_SWAP_AMOUNT_FIELD_NUMBER = 5;
    private long minSwapAmount_ = 0L;
    /**
     * <pre>
     *
     *Minimum swap amount (sat)
     * </pre>
     *
     * <code>int64 min_swap_amount = 5 [jstype = JS_STRING];</code>
     * @return The minSwapAmount.
     */
    @java.lang.Override
    public long getMinSwapAmount() {
      return minSwapAmount_;
    }

    public static final int MAX_SWAP_AMOUNT_FIELD_NUMBER = 6;
    private long maxSwapAmount_ = 0L;
    /**
     * <pre>
     *
     *Maximum swap amount (sat)
     * </pre>
     *
     * <code>int64 max_swap_amount = 6 [jstype = JS_STRING];</code>
     * @return The maxSwapAmount.
     */
    @java.lang.Override
    public long getMaxSwapAmount() {
      return maxSwapAmount_;
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (minSwapAmount_ != 0L) {
        output.writeInt64(5, minSwapAmount_);
      }
      if (maxSwapAmount_ != 0L) {
        output.writeInt64(6, maxSwapAmount_);
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (minSwapAmount_ != 0L) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt64Size(5, minSwapAmount_);
      }
      if (maxSwapAmount_ != 0L) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt64Size(6, maxSwapAmount_);
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof looprpc.Loop.InTermsResponse)) {
        return super.equals(obj);
      }
      looprpc.Loop.InTermsResponse other = (looprpc.Loop.InTermsResponse) obj;

      if (getMinSwapAmount()
          != other.getMinSwapAmount()) return false;
      if (getMaxSwapAmount()
          != other.getMaxSwapAmount()) return false;
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      hash = (37 * hash) + MIN_SWAP_AMOUNT_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
          getMinSwapAmount());
      hash = (37 * hash) + MAX_SWAP_AMOUNT_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
          getMaxSwapAmount());
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static looprpc.Loop.InTermsResponse parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static looprpc.Loop.InTermsResponse parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static looprpc.Loop.InTermsResponse parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static looprpc.Loop.InTermsResponse parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static looprpc.Loop.InTermsResponse parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static looprpc.Loop.InTermsResponse parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static looprpc.Loop.InTermsResponse parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static looprpc.Loop.InTermsResponse parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static looprpc.Loop.InTermsResponse parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static looprpc.Loop.InTermsResponse parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static looprpc.Loop.InTermsResponse parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static looprpc.Loop.InTermsResponse parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(looprpc.Loop.InTermsResponse prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * Protobuf type {@code looprpc.InTermsResponse}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:looprpc.InTermsResponse)
        looprpc.Loop.InTermsResponseOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return looprpc.Loop.internal_static_looprpc_InTermsResponse_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return looprpc.Loop.internal_static_looprpc_InTermsResponse_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                looprpc.Loop.InTermsResponse.class, looprpc.Loop.InTermsResponse.Builder.class);
      }

      // Construct using looprpc.Loop.InTermsResponse.newBuilder()
      private Builder() {

      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);

      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        minSwapAmount_ = 0L;
        maxSwapAmount_ = 0L;
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return looprpc.Loop.internal_static_looprpc_InTermsResponse_descriptor;
      }

      @java.lang.Override
      public looprpc.Loop.InTermsResponse getDefaultInstanceForType() {
        return looprpc.Loop.InTermsResponse.getDefaultInstance();
      }

      @java.lang.Override
      public looprpc.Loop.InTermsResponse build() {
        looprpc.Loop.InTermsResponse result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public looprpc.Loop.InTermsResponse buildPartial() {
        looprpc.Loop.InTermsResponse result = new looprpc.Loop.InTermsResponse(this);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartial0(looprpc.Loop.InTermsResponse result) {
        int from_bitField0_ = bitField0_;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.minSwapAmount_ = minSwapAmount_;
        }
        if (((from_bitField0_ & 0x00000002) != 0)) {
          result.maxSwapAmount_ = maxSwapAmount_;
        }
      }

      @java.lang.Override
      public Builder clone() {
        return super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof looprpc.Loop.InTermsResponse) {
          return mergeFrom((looprpc.Loop.InTermsResponse)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(looprpc.Loop.InTermsResponse other) {
        if (other == looprpc.Loop.InTermsResponse.getDefaultInstance()) return this;
        if (other.getMinSwapAmount() != 0L) {
          setMinSwapAmount(other.getMinSwapAmount());
        }
        if (other.getMaxSwapAmount() != 0L) {
          setMaxSwapAmount(other.getMaxSwapAmount());
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 40: {
                minSwapAmount_ = input.readInt64();
                bitField0_ |= 0x00000001;
                break;
              } // case 40
              case 48: {
                maxSwapAmount_ = input.readInt64();
                bitField0_ |= 0x00000002;
                break;
              } // case 48
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private long minSwapAmount_ ;
      /**
       * <pre>
       *
       *Minimum swap amount (sat)
       * </pre>
       *
       * <code>int64 min_swap_amount = 5 [jstype = JS_STRING];</code>
       * @return The minSwapAmount.
       */
      @java.lang.Override
      public long getMinSwapAmount() {
        return minSwapAmount_;
      }
      /**
       * <pre>
       *
       *Minimum swap amount (sat)
       * </pre>
       *
       * <code>int64 min_swap_amount = 5 [jstype = JS_STRING];</code>
       * @param value The minSwapAmount to set.
       * @return This builder for chaining.
       */
      public Builder setMinSwapAmount(long value) {

        minSwapAmount_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       *
       *Minimum swap amount (sat)
       * </pre>
       *
       * <code>int64 min_swap_amount = 5 [jstype = JS_STRING];</code>
       * @return This builder for chaining.
       */
      public Builder clearMinSwapAmount() {
        bitField0_ = (bitField0_ & ~0x00000001);
        minSwapAmount_ = 0L;
        onChanged();
        return this;
      }

      private long maxSwapAmount_ ;
      /**
       * <pre>
       *
       *Maximum swap amount (sat)
       * </pre>
       *
       * <code>int64 max_swap_amount = 6 [jstype = JS_STRING];</code>
       * @return The maxSwapAmount.
       */
      @java.lang.Override
      public long getMaxSwapAmount() {
        return maxSwapAmount_;
      }
      /**
       * <pre>
       *
       *Maximum swap amount (sat)
       * </pre>
       *
       * <code>int64 max_swap_amount = 6 [jstype = JS_STRING];</code>
       * @param value The maxSwapAmount to set.
       * @return This builder for chaining.
       */
      public Builder setMaxSwapAmount(long value) {

        maxSwapAmount_ = value;
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       *
       *Maximum swap amount (sat)
       * </pre>
       *
       * <code>int64 max_swap_amount = 6 [jstype = JS_STRING];</code>
       * @return This builder for chaining.
       */
      public Builder clearMaxSwapAmount() {
        bitField0_ = (bitField0_ & ~0x00000002);
        maxSwapAmount_ = 0L;
        onChanged();
        return this;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:looprpc.InTermsResponse)
    }

    // @@protoc_insertion_point(class_scope:looprpc.InTermsResponse)
    private static final looprpc.Loop.InTermsResponse DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new looprpc.Loop.InTermsResponse();
    }

    public static looprpc.Loop.InTermsResponse getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<InTermsResponse>
        PARSER = new com.google.protobuf.AbstractParser<InTermsResponse>() {
      @java.lang.Override
      public InTermsResponse parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<InTermsResponse> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<InTermsResponse> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public looprpc.Loop.InTermsResponse getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface OutTermsResponseOrBuilder extends
      // @@protoc_insertion_point(interface_extends:looprpc.OutTermsResponse)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     *
     *Minimum swap amount (sat)
     * </pre>
     *
     * <code>int64 min_swap_amount = 5 [jstype = JS_STRING];</code>
     * @return The minSwapAmount.
     */
    long getMinSwapAmount();

    /**
     * <pre>
     *
     *Maximum swap amount (sat)
     * </pre>
     *
     * <code>int64 max_swap_amount = 6 [jstype = JS_STRING];</code>
     * @return The maxSwapAmount.
     */
    long getMaxSwapAmount();

    /**
     * <pre>
     * The minimally accepted cltv delta of the on-chain htlc.
     * </pre>
     *
     * <code>int32 min_cltv_delta = 8;</code>
     * @return The minCltvDelta.
     */
    int getMinCltvDelta();

    /**
     * <pre>
     * The maximally accepted cltv delta of the on-chain htlc.
     * </pre>
     *
     * <code>int32 max_cltv_delta = 9;</code>
     * @return The maxCltvDelta.
     */
    int getMaxCltvDelta();
  }
  /**
   * Protobuf type {@code looprpc.OutTermsResponse}
   */
  public static final class OutTermsResponse extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:looprpc.OutTermsResponse)
      OutTermsResponseOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use OutTermsResponse.newBuilder() to construct.
    private OutTermsResponse(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private OutTermsResponse() {
    }

    @java.lang.Override
    @SuppressWarnings({"unused"})
    protected java.lang.Object newInstance(
        UnusedPrivateParameter unused) {
      return new OutTermsResponse();
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return looprpc.Loop.internal_static_looprpc_OutTermsResponse_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return looprpc.Loop.internal_static_looprpc_OutTermsResponse_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              looprpc.Loop.OutTermsResponse.class, looprpc.Loop.OutTermsResponse.Builder.class);
    }

    public static final int MIN_SWAP_AMOUNT_FIELD_NUMBER = 5;
    private long minSwapAmount_ = 0L;
    /**
     * <pre>
     *
     *Minimum swap amount (sat)
     * </pre>
     *
     * <code>int64 min_swap_amount = 5 [jstype = JS_STRING];</code>
     * @return The minSwapAmount.
     */
    @java.lang.Override
    public long getMinSwapAmount() {
      return minSwapAmount_;
    }

    public static final int MAX_SWAP_AMOUNT_FIELD_NUMBER = 6;
    private long maxSwapAmount_ = 0L;
    /**
     * <pre>
     *
     *Maximum swap amount (sat)
     * </pre>
     *
     * <code>int64 max_swap_amount = 6 [jstype = JS_STRING];</code>
     * @return The maxSwapAmount.
     */
    @java.lang.Override
    public long getMaxSwapAmount() {
      return maxSwapAmount_;
    }

    public static final int MIN_CLTV_DELTA_FIELD_NUMBER = 8;
    private int minCltvDelta_ = 0;
    /**
     * <pre>
     * The minimally accepted cltv delta of the on-chain htlc.
     * </pre>
     *
     * <code>int32 min_cltv_delta = 8;</code>
     * @return The minCltvDelta.
     */
    @java.lang.Override
    public int getMinCltvDelta() {
      return minCltvDelta_;
    }

    public static final int MAX_CLTV_DELTA_FIELD_NUMBER = 9;
    private int maxCltvDelta_ = 0;
    /**
     * <pre>
     * The maximally accepted cltv delta of the on-chain htlc.
     * </pre>
     *
     * <code>int32 max_cltv_delta = 9;</code>
     * @return The maxCltvDelta.
     */
    @java.lang.Override
    public int getMaxCltvDelta() {
      return maxCltvDelta_;
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (minSwapAmount_ != 0L) {
        output.writeInt64(5, minSwapAmount_);
      }
      if (maxSwapAmount_ != 0L) {
        output.writeInt64(6, maxSwapAmount_);
      }
      if (minCltvDelta_ != 0) {
        output.writeInt32(8, minCltvDelta_);
      }
      if (maxCltvDelta_ != 0) {
        output.writeInt32(9, maxCltvDelta_);
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (minSwapAmount_ != 0L) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt64Size(5, minSwapAmount_);
      }
      if (maxSwapAmount_ != 0L) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt64Size(6, maxSwapAmount_);
      }
      if (minCltvDelta_ != 0) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt32Size(8, minCltvDelta_);
      }
      if (maxCltvDelta_ != 0) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt32Size(9, maxCltvDelta_);
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof looprpc.Loop.OutTermsResponse)) {
        return super.equals(obj);
      }
      looprpc.Loop.OutTermsResponse other = (looprpc.Loop.OutTermsResponse) obj;

      if (getMinSwapAmount()
          != other.getMinSwapAmount()) return false;
      if (getMaxSwapAmount()
          != other.getMaxSwapAmount()) return false;
      if (getMinCltvDelta()
          != other.getMinCltvDelta()) return false;
      if (getMaxCltvDelta()
          != other.getMaxCltvDelta()) return false;
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      hash = (37 * hash) + MIN_SWAP_AMOUNT_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
          getMinSwapAmount());
      hash = (37 * hash) + MAX_SWAP_AMOUNT_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
          getMaxSwapAmount());
      hash = (37 * hash) + MIN_CLTV_DELTA_FIELD_NUMBER;
      hash = (53 * hash) + getMinCltvDelta();
      hash = (37 * hash) + MAX_CLTV_DELTA_FIELD_NUMBER;
      hash = (53 * hash) + getMaxCltvDelta();
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static looprpc.Loop.OutTermsResponse parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static looprpc.Loop.OutTermsResponse parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static looprpc.Loop.OutTermsResponse parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static looprpc.Loop.OutTermsResponse parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static looprpc.Loop.OutTermsResponse parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static looprpc.Loop.OutTermsResponse parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static looprpc.Loop.OutTermsResponse parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static looprpc.Loop.OutTermsResponse parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static looprpc.Loop.OutTermsResponse parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static looprpc.Loop.OutTermsResponse parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static looprpc.Loop.OutTermsResponse parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static looprpc.Loop.OutTermsResponse parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(looprpc.Loop.OutTermsResponse prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * Protobuf type {@code looprpc.OutTermsResponse}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:looprpc.OutTermsResponse)
        looprpc.Loop.OutTermsResponseOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return looprpc.Loop.internal_static_looprpc_OutTermsResponse_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return looprpc.Loop.internal_static_looprpc_OutTermsResponse_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                looprpc.Loop.OutTermsResponse.class, looprpc.Loop.OutTermsResponse.Builder.class);
      }

      // Construct using looprpc.Loop.OutTermsResponse.newBuilder()
      private Builder() {

      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);

      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        minSwapAmount_ = 0L;
        maxSwapAmount_ = 0L;
        minCltvDelta_ = 0;
        maxCltvDelta_ = 0;
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return looprpc.Loop.internal_static_looprpc_OutTermsResponse_descriptor;
      }

      @java.lang.Override
      public looprpc.Loop.OutTermsResponse getDefaultInstanceForType() {
        return looprpc.Loop.OutTermsResponse.getDefaultInstance();
      }

      @java.lang.Override
      public looprpc.Loop.OutTermsResponse build() {
        looprpc.Loop.OutTermsResponse result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public looprpc.Loop.OutTermsResponse buildPartial() {
        looprpc.Loop.OutTermsResponse result = new looprpc.Loop.OutTermsResponse(this);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartial0(looprpc.Loop.OutTermsResponse result) {
        int from_bitField0_ = bitField0_;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.minSwapAmount_ = minSwapAmount_;
        }
        if (((from_bitField0_ & 0x00000002) != 0)) {
          result.maxSwapAmount_ = maxSwapAmount_;
        }
        if (((from_bitField0_ & 0x00000004) != 0)) {
          result.minCltvDelta_ = minCltvDelta_;
        }
        if (((from_bitField0_ & 0x00000008) != 0)) {
          result.maxCltvDelta_ = maxCltvDelta_;
        }
      }

      @java.lang.Override
      public Builder clone() {
        return super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof looprpc.Loop.OutTermsResponse) {
          return mergeFrom((looprpc.Loop.OutTermsResponse)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(looprpc.Loop.OutTermsResponse other) {
        if (other == looprpc.Loop.OutTermsResponse.getDefaultInstance()) return this;
        if (other.getMinSwapAmount() != 0L) {
          setMinSwapAmount(other.getMinSwapAmount());
        }
        if (other.getMaxSwapAmount() != 0L) {
          setMaxSwapAmount(other.getMaxSwapAmount());
        }
        if (other.getMinCltvDelta() != 0) {
          setMinCltvDelta(other.getMinCltvDelta());
        }
        if (other.getMaxCltvDelta() != 0) {
          setMaxCltvDelta(other.getMaxCltvDelta());
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 40: {
                minSwapAmount_ = input.readInt64();
                bitField0_ |= 0x00000001;
                break;
              } // case 40
              case 48: {
                maxSwapAmount_ = input.readInt64();
                bitField0_ |= 0x00000002;
                break;
              } // case 48
              case 64: {
                minCltvDelta_ = input.readInt32();
                bitField0_ |= 0x00000004;
                break;
              } // case 64
              case 72: {
                maxCltvDelta_ = input.readInt32();
                bitField0_ |= 0x00000008;
                break;
              } // case 72
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private long minSwapAmount_ ;
      /**
       * <pre>
       *
       *Minimum swap amount (sat)
       * </pre>
       *
       * <code>int64 min_swap_amount = 5 [jstype = JS_STRING];</code>
       * @return The minSwapAmount.
       */
      @java.lang.Override
      public long getMinSwapAmount() {
        return minSwapAmount_;
      }
      /**
       * <pre>
       *
       *Minimum swap amount (sat)
       * </pre>
       *
       * <code>int64 min_swap_amount = 5 [jstype = JS_STRING];</code>
       * @param value The minSwapAmount to set.
       * @return This builder for chaining.
       */
      public Builder setMinSwapAmount(long value) {

        minSwapAmount_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       *
       *Minimum swap amount (sat)
       * </pre>
       *
       * <code>int64 min_swap_amount = 5 [jstype = JS_STRING];</code>
       * @return This builder for chaining.
       */
      public Builder clearMinSwapAmount() {
        bitField0_ = (bitField0_ & ~0x00000001);
        minSwapAmount_ = 0L;
        onChanged();
        return this;
      }

      private long maxSwapAmount_ ;
      /**
       * <pre>
       *
       *Maximum swap amount (sat)
       * </pre>
       *
       * <code>int64 max_swap_amount = 6 [jstype = JS_STRING];</code>
       * @return The maxSwapAmount.
       */
      @java.lang.Override
      public long getMaxSwapAmount() {
        return maxSwapAmount_;
      }
      /**
       * <pre>
       *
       *Maximum swap amount (sat)
       * </pre>
       *
       * <code>int64 max_swap_amount = 6 [jstype = JS_STRING];</code>
       * @param value The maxSwapAmount to set.
       * @return This builder for chaining.
       */
      public Builder setMaxSwapAmount(long value) {

        maxSwapAmount_ = value;
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       *
       *Maximum swap amount (sat)
       * </pre>
       *
       * <code>int64 max_swap_amount = 6 [jstype = JS_STRING];</code>
       * @return This builder for chaining.
       */
      public Builder clearMaxSwapAmount() {
        bitField0_ = (bitField0_ & ~0x00000002);
        maxSwapAmount_ = 0L;
        onChanged();
        return this;
      }

      private int minCltvDelta_ ;
      /**
       * <pre>
       * The minimally accepted cltv delta of the on-chain htlc.
       * </pre>
       *
       * <code>int32 min_cltv_delta = 8;</code>
       * @return The minCltvDelta.
       */
      @java.lang.Override
      public int getMinCltvDelta() {
        return minCltvDelta_;
      }
      /**
       * <pre>
       * The minimally accepted cltv delta of the on-chain htlc.
       * </pre>
       *
       * <code>int32 min_cltv_delta = 8;</code>
       * @param value The minCltvDelta to set.
       * @return This builder for chaining.
       */
      public Builder setMinCltvDelta(int value) {

        minCltvDelta_ = value;
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The minimally accepted cltv delta of the on-chain htlc.
       * </pre>
       *
       * <code>int32 min_cltv_delta = 8;</code>
       * @return This builder for chaining.
       */
      public Builder clearMinCltvDelta() {
        bitField0_ = (bitField0_ & ~0x00000004);
        minCltvDelta_ = 0;
        onChanged();
        return this;
      }

      private int maxCltvDelta_ ;
      /**
       * <pre>
       * The maximally accepted cltv delta of the on-chain htlc.
       * </pre>
       *
       * <code>int32 max_cltv_delta = 9;</code>
       * @return The maxCltvDelta.
       */
      @java.lang.Override
      public int getMaxCltvDelta() {
        return maxCltvDelta_;
      }
      /**
       * <pre>
       * The maximally accepted cltv delta of the on-chain htlc.
       * </pre>
       *
       * <code>int32 max_cltv_delta = 9;</code>
       * @param value The maxCltvDelta to set.
       * @return This builder for chaining.
       */
      public Builder setMaxCltvDelta(int value) {

        maxCltvDelta_ = value;
        bitField0_ |= 0x00000008;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The maximally accepted cltv delta of the on-chain htlc.
       * </pre>
       *
       * <code>int32 max_cltv_delta = 9;</code>
       * @return This builder for chaining.
       */
      public Builder clearMaxCltvDelta() {
        bitField0_ = (bitField0_ & ~0x00000008);
        maxCltvDelta_ = 0;
        onChanged();
        return this;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:looprpc.OutTermsResponse)
    }

    // @@protoc_insertion_point(class_scope:looprpc.OutTermsResponse)
    private static final looprpc.Loop.OutTermsResponse DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new looprpc.Loop.OutTermsResponse();
    }

    public static looprpc.Loop.OutTermsResponse getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<OutTermsResponse>
        PARSER = new com.google.protobuf.AbstractParser<OutTermsResponse>() {
      @java.lang.Override
      public OutTermsResponse parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<OutTermsResponse> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<OutTermsResponse> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public looprpc.Loop.OutTermsResponse getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface QuoteRequestOrBuilder extends
      // @@protoc_insertion_point(interface_extends:looprpc.QuoteRequest)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     *
     *The amount to swap in satoshis.
     * </pre>
     *
     * <code>int64 amt = 1 [jstype = JS_STRING];</code>
     * @return The amt.
     */
    long getAmt();

    /**
     * <pre>
     *
     *The confirmation target that should be used either for the sweep of the
     *on-chain HTLC broadcast by the swap server in the case of a Loop Out, or for
     *the confirmation of the on-chain HTLC broadcast by the swap client in the
     *case of a Loop In.
     * </pre>
     *
     * <code>int32 conf_target = 2;</code>
     * @return The confTarget.
     */
    int getConfTarget();

    /**
     * <pre>
     *
     *If external_htlc is true, we expect the htlc to be published by an external
     *actor.
     * </pre>
     *
     * <code>bool external_htlc = 3;</code>
     * @return The externalHtlc.
     */
    boolean getExternalHtlc();

    /**
     * <pre>
     *
     *The latest time (in unix seconds) we allow the server to wait before
     *publishing the HTLC on chain. Setting this to a larger value will give the
     *server the opportunity to batch multiple swaps together, and wait for
     *low-fee periods before publishing the HTLC, potentially resulting in a
     *lower total swap fee. This only has an effect on loop out quotes.
     * </pre>
     *
     * <code>uint64 swap_publication_deadline = 4 [jstype = JS_STRING];</code>
     * @return The swapPublicationDeadline.
     */
    long getSwapPublicationDeadline();

    /**
     * <pre>
     *
     *Optionally the client can specify the last hop pubkey when requesting a
     *loop-in quote. This is useful to get better off-chain routing fee from the
     *server.
     * </pre>
     *
     * <code>bytes loop_in_last_hop = 5;</code>
     * @return The loopInLastHop.
     */
    com.google.protobuf.ByteString getLoopInLastHop();

    /**
     * <pre>
     *
     *Optional route hints to reach the destination through private channels.
     * </pre>
     *
     * <code>repeated .looprpc.RouteHint loop_in_route_hints = 6;</code>
     */
    java.util.List<looprpc.Common.RouteHint> 
        getLoopInRouteHintsList();
    /**
     * <pre>
     *
     *Optional route hints to reach the destination through private channels.
     * </pre>
     *
     * <code>repeated .looprpc.RouteHint loop_in_route_hints = 6;</code>
     */
    looprpc.Common.RouteHint getLoopInRouteHints(int index);
    /**
     * <pre>
     *
     *Optional route hints to reach the destination through private channels.
     * </pre>
     *
     * <code>repeated .looprpc.RouteHint loop_in_route_hints = 6;</code>
     */
    int getLoopInRouteHintsCount();
    /**
     * <pre>
     *
     *Optional route hints to reach the destination through private channels.
     * </pre>
     *
     * <code>repeated .looprpc.RouteHint loop_in_route_hints = 6;</code>
     */
    java.util.List<? extends looprpc.Common.RouteHintOrBuilder> 
        getLoopInRouteHintsOrBuilderList();
    /**
     * <pre>
     *
     *Optional route hints to reach the destination through private channels.
     * </pre>
     *
     * <code>repeated .looprpc.RouteHint loop_in_route_hints = 6;</code>
     */
    looprpc.Common.RouteHintOrBuilder getLoopInRouteHintsOrBuilder(
        int index);

    /**
     * <pre>
     *
     *Private indicates whether the destination node should be considered
     *private. In which case, loop will generate hophints to assist with
     *probing and payment.
     * </pre>
     *
     * <code>bool private = 7;</code>
     * @return The private.
     */
    boolean getPrivate();
  }
  /**
   * Protobuf type {@code looprpc.QuoteRequest}
   */
  public static final class QuoteRequest extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:looprpc.QuoteRequest)
      QuoteRequestOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use QuoteRequest.newBuilder() to construct.
    private QuoteRequest(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private QuoteRequest() {
      loopInLastHop_ = com.google.protobuf.ByteString.EMPTY;
      loopInRouteHints_ = java.util.Collections.emptyList();
    }

    @java.lang.Override
    @SuppressWarnings({"unused"})
    protected java.lang.Object newInstance(
        UnusedPrivateParameter unused) {
      return new QuoteRequest();
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return looprpc.Loop.internal_static_looprpc_QuoteRequest_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return looprpc.Loop.internal_static_looprpc_QuoteRequest_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              looprpc.Loop.QuoteRequest.class, looprpc.Loop.QuoteRequest.Builder.class);
    }

    public static final int AMT_FIELD_NUMBER = 1;
    private long amt_ = 0L;
    /**
     * <pre>
     *
     *The amount to swap in satoshis.
     * </pre>
     *
     * <code>int64 amt = 1 [jstype = JS_STRING];</code>
     * @return The amt.
     */
    @java.lang.Override
    public long getAmt() {
      return amt_;
    }

    public static final int CONF_TARGET_FIELD_NUMBER = 2;
    private int confTarget_ = 0;
    /**
     * <pre>
     *
     *The confirmation target that should be used either for the sweep of the
     *on-chain HTLC broadcast by the swap server in the case of a Loop Out, or for
     *the confirmation of the on-chain HTLC broadcast by the swap client in the
     *case of a Loop In.
     * </pre>
     *
     * <code>int32 conf_target = 2;</code>
     * @return The confTarget.
     */
    @java.lang.Override
    public int getConfTarget() {
      return confTarget_;
    }

    public static final int EXTERNAL_HTLC_FIELD_NUMBER = 3;
    private boolean externalHtlc_ = false;
    /**
     * <pre>
     *
     *If external_htlc is true, we expect the htlc to be published by an external
     *actor.
     * </pre>
     *
     * <code>bool external_htlc = 3;</code>
     * @return The externalHtlc.
     */
    @java.lang.Override
    public boolean getExternalHtlc() {
      return externalHtlc_;
    }

    public static final int SWAP_PUBLICATION_DEADLINE_FIELD_NUMBER = 4;
    private long swapPublicationDeadline_ = 0L;
    /**
     * <pre>
     *
     *The latest time (in unix seconds) we allow the server to wait before
     *publishing the HTLC on chain. Setting this to a larger value will give the
     *server the opportunity to batch multiple swaps together, and wait for
     *low-fee periods before publishing the HTLC, potentially resulting in a
     *lower total swap fee. This only has an effect on loop out quotes.
     * </pre>
     *
     * <code>uint64 swap_publication_deadline = 4 [jstype = JS_STRING];</code>
     * @return The swapPublicationDeadline.
     */
    @java.lang.Override
    public long getSwapPublicationDeadline() {
      return swapPublicationDeadline_;
    }

    public static final int LOOP_IN_LAST_HOP_FIELD_NUMBER = 5;
    private com.google.protobuf.ByteString loopInLastHop_ = com.google.protobuf.ByteString.EMPTY;
    /**
     * <pre>
     *
     *Optionally the client can specify the last hop pubkey when requesting a
     *loop-in quote. This is useful to get better off-chain routing fee from the
     *server.
     * </pre>
     *
     * <code>bytes loop_in_last_hop = 5;</code>
     * @return The loopInLastHop.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString getLoopInLastHop() {
      return loopInLastHop_;
    }

    public static final int LOOP_IN_ROUTE_HINTS_FIELD_NUMBER = 6;
    @SuppressWarnings("serial")
    private java.util.List<looprpc.Common.RouteHint> loopInRouteHints_;
    /**
     * <pre>
     *
     *Optional route hints to reach the destination through private channels.
     * </pre>
     *
     * <code>repeated .looprpc.RouteHint loop_in_route_hints = 6;</code>
     */
    @java.lang.Override
    public java.util.List<looprpc.Common.RouteHint> getLoopInRouteHintsList() {
      return loopInRouteHints_;
    }
    /**
     * <pre>
     *
     *Optional route hints to reach the destination through private channels.
     * </pre>
     *
     * <code>repeated .looprpc.RouteHint loop_in_route_hints = 6;</code>
     */
    @java.lang.Override
    public java.util.List<? extends looprpc.Common.RouteHintOrBuilder> 
        getLoopInRouteHintsOrBuilderList() {
      return loopInRouteHints_;
    }
    /**
     * <pre>
     *
     *Optional route hints to reach the destination through private channels.
     * </pre>
     *
     * <code>repeated .looprpc.RouteHint loop_in_route_hints = 6;</code>
     */
    @java.lang.Override
    public int getLoopInRouteHintsCount() {
      return loopInRouteHints_.size();
    }
    /**
     * <pre>
     *
     *Optional route hints to reach the destination through private channels.
     * </pre>
     *
     * <code>repeated .looprpc.RouteHint loop_in_route_hints = 6;</code>
     */
    @java.lang.Override
    public looprpc.Common.RouteHint getLoopInRouteHints(int index) {
      return loopInRouteHints_.get(index);
    }
    /**
     * <pre>
     *
     *Optional route hints to reach the destination through private channels.
     * </pre>
     *
     * <code>repeated .looprpc.RouteHint loop_in_route_hints = 6;</code>
     */
    @java.lang.Override
    public looprpc.Common.RouteHintOrBuilder getLoopInRouteHintsOrBuilder(
        int index) {
      return loopInRouteHints_.get(index);
    }

    public static final int PRIVATE_FIELD_NUMBER = 7;
    private boolean private_ = false;
    /**
     * <pre>
     *
     *Private indicates whether the destination node should be considered
     *private. In which case, loop will generate hophints to assist with
     *probing and payment.
     * </pre>
     *
     * <code>bool private = 7;</code>
     * @return The private.
     */
    @java.lang.Override
    public boolean getPrivate() {
      return private_;
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (amt_ != 0L) {
        output.writeInt64(1, amt_);
      }
      if (confTarget_ != 0) {
        output.writeInt32(2, confTarget_);
      }
      if (externalHtlc_ != false) {
        output.writeBool(3, externalHtlc_);
      }
      if (swapPublicationDeadline_ != 0L) {
        output.writeUInt64(4, swapPublicationDeadline_);
      }
      if (!loopInLastHop_.isEmpty()) {
        output.writeBytes(5, loopInLastHop_);
      }
      for (int i = 0; i < loopInRouteHints_.size(); i++) {
        output.writeMessage(6, loopInRouteHints_.get(i));
      }
      if (private_ != false) {
        output.writeBool(7, private_);
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (amt_ != 0L) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt64Size(1, amt_);
      }
      if (confTarget_ != 0) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt32Size(2, confTarget_);
      }
      if (externalHtlc_ != false) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(3, externalHtlc_);
      }
      if (swapPublicationDeadline_ != 0L) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt64Size(4, swapPublicationDeadline_);
      }
      if (!loopInLastHop_.isEmpty()) {
        size += com.google.protobuf.CodedOutputStream
          .computeBytesSize(5, loopInLastHop_);
      }
      for (int i = 0; i < loopInRouteHints_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(6, loopInRouteHints_.get(i));
      }
      if (private_ != false) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(7, private_);
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof looprpc.Loop.QuoteRequest)) {
        return super.equals(obj);
      }
      looprpc.Loop.QuoteRequest other = (looprpc.Loop.QuoteRequest) obj;

      if (getAmt()
          != other.getAmt()) return false;
      if (getConfTarget()
          != other.getConfTarget()) return false;
      if (getExternalHtlc()
          != other.getExternalHtlc()) return false;
      if (getSwapPublicationDeadline()
          != other.getSwapPublicationDeadline()) return false;
      if (!getLoopInLastHop()
          .equals(other.getLoopInLastHop())) return false;
      if (!getLoopInRouteHintsList()
          .equals(other.getLoopInRouteHintsList())) return false;
      if (getPrivate()
          != other.getPrivate()) return false;
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      hash = (37 * hash) + AMT_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
          getAmt());
      hash = (37 * hash) + CONF_TARGET_FIELD_NUMBER;
      hash = (53 * hash) + getConfTarget();
      hash = (37 * hash) + EXTERNAL_HTLC_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
          getExternalHtlc());
      hash = (37 * hash) + SWAP_PUBLICATION_DEADLINE_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
          getSwapPublicationDeadline());
      hash = (37 * hash) + LOOP_IN_LAST_HOP_FIELD_NUMBER;
      hash = (53 * hash) + getLoopInLastHop().hashCode();
      if (getLoopInRouteHintsCount() > 0) {
        hash = (37 * hash) + LOOP_IN_ROUTE_HINTS_FIELD_NUMBER;
        hash = (53 * hash) + getLoopInRouteHintsList().hashCode();
      }
      hash = (37 * hash) + PRIVATE_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
          getPrivate());
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static looprpc.Loop.QuoteRequest parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static looprpc.Loop.QuoteRequest parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static looprpc.Loop.QuoteRequest parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static looprpc.Loop.QuoteRequest parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static looprpc.Loop.QuoteRequest parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static looprpc.Loop.QuoteRequest parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static looprpc.Loop.QuoteRequest parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static looprpc.Loop.QuoteRequest parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static looprpc.Loop.QuoteRequest parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static looprpc.Loop.QuoteRequest parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static looprpc.Loop.QuoteRequest parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static looprpc.Loop.QuoteRequest parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(looprpc.Loop.QuoteRequest prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * Protobuf type {@code looprpc.QuoteRequest}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:looprpc.QuoteRequest)
        looprpc.Loop.QuoteRequestOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return looprpc.Loop.internal_static_looprpc_QuoteRequest_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return looprpc.Loop.internal_static_looprpc_QuoteRequest_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                looprpc.Loop.QuoteRequest.class, looprpc.Loop.QuoteRequest.Builder.class);
      }

      // Construct using looprpc.Loop.QuoteRequest.newBuilder()
      private Builder() {

      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);

      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        amt_ = 0L;
        confTarget_ = 0;
        externalHtlc_ = false;
        swapPublicationDeadline_ = 0L;
        loopInLastHop_ = com.google.protobuf.ByteString.EMPTY;
        if (loopInRouteHintsBuilder_ == null) {
          loopInRouteHints_ = java.util.Collections.emptyList();
        } else {
          loopInRouteHints_ = null;
          loopInRouteHintsBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000020);
        private_ = false;
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return looprpc.Loop.internal_static_looprpc_QuoteRequest_descriptor;
      }

      @java.lang.Override
      public looprpc.Loop.QuoteRequest getDefaultInstanceForType() {
        return looprpc.Loop.QuoteRequest.getDefaultInstance();
      }

      @java.lang.Override
      public looprpc.Loop.QuoteRequest build() {
        looprpc.Loop.QuoteRequest result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public looprpc.Loop.QuoteRequest buildPartial() {
        looprpc.Loop.QuoteRequest result = new looprpc.Loop.QuoteRequest(this);
        buildPartialRepeatedFields(result);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartialRepeatedFields(looprpc.Loop.QuoteRequest result) {
        if (loopInRouteHintsBuilder_ == null) {
          if (((bitField0_ & 0x00000020) != 0)) {
            loopInRouteHints_ = java.util.Collections.unmodifiableList(loopInRouteHints_);
            bitField0_ = (bitField0_ & ~0x00000020);
          }
          result.loopInRouteHints_ = loopInRouteHints_;
        } else {
          result.loopInRouteHints_ = loopInRouteHintsBuilder_.build();
        }
      }

      private void buildPartial0(looprpc.Loop.QuoteRequest result) {
        int from_bitField0_ = bitField0_;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.amt_ = amt_;
        }
        if (((from_bitField0_ & 0x00000002) != 0)) {
          result.confTarget_ = confTarget_;
        }
        if (((from_bitField0_ & 0x00000004) != 0)) {
          result.externalHtlc_ = externalHtlc_;
        }
        if (((from_bitField0_ & 0x00000008) != 0)) {
          result.swapPublicationDeadline_ = swapPublicationDeadline_;
        }
        if (((from_bitField0_ & 0x00000010) != 0)) {
          result.loopInLastHop_ = loopInLastHop_;
        }
        if (((from_bitField0_ & 0x00000040) != 0)) {
          result.private_ = private_;
        }
      }

      @java.lang.Override
      public Builder clone() {
        return super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof looprpc.Loop.QuoteRequest) {
          return mergeFrom((looprpc.Loop.QuoteRequest)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(looprpc.Loop.QuoteRequest other) {
        if (other == looprpc.Loop.QuoteRequest.getDefaultInstance()) return this;
        if (other.getAmt() != 0L) {
          setAmt(other.getAmt());
        }
        if (other.getConfTarget() != 0) {
          setConfTarget(other.getConfTarget());
        }
        if (other.getExternalHtlc() != false) {
          setExternalHtlc(other.getExternalHtlc());
        }
        if (other.getSwapPublicationDeadline() != 0L) {
          setSwapPublicationDeadline(other.getSwapPublicationDeadline());
        }
        if (other.getLoopInLastHop() != com.google.protobuf.ByteString.EMPTY) {
          setLoopInLastHop(other.getLoopInLastHop());
        }
        if (loopInRouteHintsBuilder_ == null) {
          if (!other.loopInRouteHints_.isEmpty()) {
            if (loopInRouteHints_.isEmpty()) {
              loopInRouteHints_ = other.loopInRouteHints_;
              bitField0_ = (bitField0_ & ~0x00000020);
            } else {
              ensureLoopInRouteHintsIsMutable();
              loopInRouteHints_.addAll(other.loopInRouteHints_);
            }
            onChanged();
          }
        } else {
          if (!other.loopInRouteHints_.isEmpty()) {
            if (loopInRouteHintsBuilder_.isEmpty()) {
              loopInRouteHintsBuilder_.dispose();
              loopInRouteHintsBuilder_ = null;
              loopInRouteHints_ = other.loopInRouteHints_;
              bitField0_ = (bitField0_ & ~0x00000020);
              loopInRouteHintsBuilder_ = 
                com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
                   getLoopInRouteHintsFieldBuilder() : null;
            } else {
              loopInRouteHintsBuilder_.addAllMessages(other.loopInRouteHints_);
            }
          }
        }
        if (other.getPrivate() != false) {
          setPrivate(other.getPrivate());
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 8: {
                amt_ = input.readInt64();
                bitField0_ |= 0x00000001;
                break;
              } // case 8
              case 16: {
                confTarget_ = input.readInt32();
                bitField0_ |= 0x00000002;
                break;
              } // case 16
              case 24: {
                externalHtlc_ = input.readBool();
                bitField0_ |= 0x00000004;
                break;
              } // case 24
              case 32: {
                swapPublicationDeadline_ = input.readUInt64();
                bitField0_ |= 0x00000008;
                break;
              } // case 32
              case 42: {
                loopInLastHop_ = input.readBytes();
                bitField0_ |= 0x00000010;
                break;
              } // case 42
              case 50: {
                looprpc.Common.RouteHint m =
                    input.readMessage(
                        looprpc.Common.RouteHint.parser(),
                        extensionRegistry);
                if (loopInRouteHintsBuilder_ == null) {
                  ensureLoopInRouteHintsIsMutable();
                  loopInRouteHints_.add(m);
                } else {
                  loopInRouteHintsBuilder_.addMessage(m);
                }
                break;
              } // case 50
              case 56: {
                private_ = input.readBool();
                bitField0_ |= 0x00000040;
                break;
              } // case 56
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private long amt_ ;
      /**
       * <pre>
       *
       *The amount to swap in satoshis.
       * </pre>
       *
       * <code>int64 amt = 1 [jstype = JS_STRING];</code>
       * @return The amt.
       */
      @java.lang.Override
      public long getAmt() {
        return amt_;
      }
      /**
       * <pre>
       *
       *The amount to swap in satoshis.
       * </pre>
       *
       * <code>int64 amt = 1 [jstype = JS_STRING];</code>
       * @param value The amt to set.
       * @return This builder for chaining.
       */
      public Builder setAmt(long value) {

        amt_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       *
       *The amount to swap in satoshis.
       * </pre>
       *
       * <code>int64 amt = 1 [jstype = JS_STRING];</code>
       * @return This builder for chaining.
       */
      public Builder clearAmt() {
        bitField0_ = (bitField0_ & ~0x00000001);
        amt_ = 0L;
        onChanged();
        return this;
      }

      private int confTarget_ ;
      /**
       * <pre>
       *
       *The confirmation target that should be used either for the sweep of the
       *on-chain HTLC broadcast by the swap server in the case of a Loop Out, or for
       *the confirmation of the on-chain HTLC broadcast by the swap client in the
       *case of a Loop In.
       * </pre>
       *
       * <code>int32 conf_target = 2;</code>
       * @return The confTarget.
       */
      @java.lang.Override
      public int getConfTarget() {
        return confTarget_;
      }
      /**
       * <pre>
       *
       *The confirmation target that should be used either for the sweep of the
       *on-chain HTLC broadcast by the swap server in the case of a Loop Out, or for
       *the confirmation of the on-chain HTLC broadcast by the swap client in the
       *case of a Loop In.
       * </pre>
       *
       * <code>int32 conf_target = 2;</code>
       * @param value The confTarget to set.
       * @return This builder for chaining.
       */
      public Builder setConfTarget(int value) {

        confTarget_ = value;
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       *
       *The confirmation target that should be used either for the sweep of the
       *on-chain HTLC broadcast by the swap server in the case of a Loop Out, or for
       *the confirmation of the on-chain HTLC broadcast by the swap client in the
       *case of a Loop In.
       * </pre>
       *
       * <code>int32 conf_target = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearConfTarget() {
        bitField0_ = (bitField0_ & ~0x00000002);
        confTarget_ = 0;
        onChanged();
        return this;
      }

      private boolean externalHtlc_ ;
      /**
       * <pre>
       *
       *If external_htlc is true, we expect the htlc to be published by an external
       *actor.
       * </pre>
       *
       * <code>bool external_htlc = 3;</code>
       * @return The externalHtlc.
       */
      @java.lang.Override
      public boolean getExternalHtlc() {
        return externalHtlc_;
      }
      /**
       * <pre>
       *
       *If external_htlc is true, we expect the htlc to be published by an external
       *actor.
       * </pre>
       *
       * <code>bool external_htlc = 3;</code>
       * @param value The externalHtlc to set.
       * @return This builder for chaining.
       */
      public Builder setExternalHtlc(boolean value) {

        externalHtlc_ = value;
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }
      /**
       * <pre>
       *
       *If external_htlc is true, we expect the htlc to be published by an external
       *actor.
       * </pre>
       *
       * <code>bool external_htlc = 3;</code>
       * @return This builder for chaining.
       */
      public Builder clearExternalHtlc() {
        bitField0_ = (bitField0_ & ~0x00000004);
        externalHtlc_ = false;
        onChanged();
        return this;
      }

      private long swapPublicationDeadline_ ;
      /**
       * <pre>
       *
       *The latest time (in unix seconds) we allow the server to wait before
       *publishing the HTLC on chain. Setting this to a larger value will give the
       *server the opportunity to batch multiple swaps together, and wait for
       *low-fee periods before publishing the HTLC, potentially resulting in a
       *lower total swap fee. This only has an effect on loop out quotes.
       * </pre>
       *
       * <code>uint64 swap_publication_deadline = 4 [jstype = JS_STRING];</code>
       * @return The swapPublicationDeadline.
       */
      @java.lang.Override
      public long getSwapPublicationDeadline() {
        return swapPublicationDeadline_;
      }
      /**
       * <pre>
       *
       *The latest time (in unix seconds) we allow the server to wait before
       *publishing the HTLC on chain. Setting this to a larger value will give the
       *server the opportunity to batch multiple swaps together, and wait for
       *low-fee periods before publishing the HTLC, potentially resulting in a
       *lower total swap fee. This only has an effect on loop out quotes.
       * </pre>
       *
       * <code>uint64 swap_publication_deadline = 4 [jstype = JS_STRING];</code>
       * @param value The swapPublicationDeadline to set.
       * @return This builder for chaining.
       */
      public Builder setSwapPublicationDeadline(long value) {

        swapPublicationDeadline_ = value;
        bitField0_ |= 0x00000008;
        onChanged();
        return this;
      }
      /**
       * <pre>
       *
       *The latest time (in unix seconds) we allow the server to wait before
       *publishing the HTLC on chain. Setting this to a larger value will give the
       *server the opportunity to batch multiple swaps together, and wait for
       *low-fee periods before publishing the HTLC, potentially resulting in a
       *lower total swap fee. This only has an effect on loop out quotes.
       * </pre>
       *
       * <code>uint64 swap_publication_deadline = 4 [jstype = JS_STRING];</code>
       * @return This builder for chaining.
       */
      public Builder clearSwapPublicationDeadline() {
        bitField0_ = (bitField0_ & ~0x00000008);
        swapPublicationDeadline_ = 0L;
        onChanged();
        return this;
      }

      private com.google.protobuf.ByteString loopInLastHop_ = com.google.protobuf.ByteString.EMPTY;
      /**
       * <pre>
       *
       *Optionally the client can specify the last hop pubkey when requesting a
       *loop-in quote. This is useful to get better off-chain routing fee from the
       *server.
       * </pre>
       *
       * <code>bytes loop_in_last_hop = 5;</code>
       * @return The loopInLastHop.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString getLoopInLastHop() {
        return loopInLastHop_;
      }
      /**
       * <pre>
       *
       *Optionally the client can specify the last hop pubkey when requesting a
       *loop-in quote. This is useful to get better off-chain routing fee from the
       *server.
       * </pre>
       *
       * <code>bytes loop_in_last_hop = 5;</code>
       * @param value The loopInLastHop to set.
       * @return This builder for chaining.
       */
      public Builder setLoopInLastHop(com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        loopInLastHop_ = value;
        bitField0_ |= 0x00000010;
        onChanged();
        return this;
      }
      /**
       * <pre>
       *
       *Optionally the client can specify the last hop pubkey when requesting a
       *loop-in quote. This is useful to get better off-chain routing fee from the
       *server.
       * </pre>
       *
       * <code>bytes loop_in_last_hop = 5;</code>
       * @return This builder for chaining.
       */
      public Builder clearLoopInLastHop() {
        bitField0_ = (bitField0_ & ~0x00000010);
        loopInLastHop_ = getDefaultInstance().getLoopInLastHop();
        onChanged();
        return this;
      }

      private java.util.List<looprpc.Common.RouteHint> loopInRouteHints_ =
        java.util.Collections.emptyList();
      private void ensureLoopInRouteHintsIsMutable() {
        if (!((bitField0_ & 0x00000020) != 0)) {
          loopInRouteHints_ = new java.util.ArrayList<looprpc.Common.RouteHint>(loopInRouteHints_);
          bitField0_ |= 0x00000020;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
          looprpc.Common.RouteHint, looprpc.Common.RouteHint.Builder, looprpc.Common.RouteHintOrBuilder> loopInRouteHintsBuilder_;

      /**
       * <pre>
       *
       *Optional route hints to reach the destination through private channels.
       * </pre>
       *
       * <code>repeated .looprpc.RouteHint loop_in_route_hints = 6;</code>
       */
      public java.util.List<looprpc.Common.RouteHint> getLoopInRouteHintsList() {
        if (loopInRouteHintsBuilder_ == null) {
          return java.util.Collections.unmodifiableList(loopInRouteHints_);
        } else {
          return loopInRouteHintsBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       *
       *Optional route hints to reach the destination through private channels.
       * </pre>
       *
       * <code>repeated .looprpc.RouteHint loop_in_route_hints = 6;</code>
       */
      public int getLoopInRouteHintsCount() {
        if (loopInRouteHintsBuilder_ == null) {
          return loopInRouteHints_.size();
        } else {
          return loopInRouteHintsBuilder_.getCount();
        }
      }
      /**
       * <pre>
       *
       *Optional route hints to reach the destination through private channels.
       * </pre>
       *
       * <code>repeated .looprpc.RouteHint loop_in_route_hints = 6;</code>
       */
      public looprpc.Common.RouteHint getLoopInRouteHints(int index) {
        if (loopInRouteHintsBuilder_ == null) {
          return loopInRouteHints_.get(index);
        } else {
          return loopInRouteHintsBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       *
       *Optional route hints to reach the destination through private channels.
       * </pre>
       *
       * <code>repeated .looprpc.RouteHint loop_in_route_hints = 6;</code>
       */
      public Builder setLoopInRouteHints(
          int index, looprpc.Common.RouteHint value) {
        if (loopInRouteHintsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureLoopInRouteHintsIsMutable();
          loopInRouteHints_.set(index, value);
          onChanged();
        } else {
          loopInRouteHintsBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       *
       *Optional route hints to reach the destination through private channels.
       * </pre>
       *
       * <code>repeated .looprpc.RouteHint loop_in_route_hints = 6;</code>
       */
      public Builder setLoopInRouteHints(
          int index, looprpc.Common.RouteHint.Builder builderForValue) {
        if (loopInRouteHintsBuilder_ == null) {
          ensureLoopInRouteHintsIsMutable();
          loopInRouteHints_.set(index, builderForValue.build());
          onChanged();
        } else {
          loopInRouteHintsBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       *
       *Optional route hints to reach the destination through private channels.
       * </pre>
       *
       * <code>repeated .looprpc.RouteHint loop_in_route_hints = 6;</code>
       */
      public Builder addLoopInRouteHints(looprpc.Common.RouteHint value) {
        if (loopInRouteHintsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureLoopInRouteHintsIsMutable();
          loopInRouteHints_.add(value);
          onChanged();
        } else {
          loopInRouteHintsBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       *
       *Optional route hints to reach the destination through private channels.
       * </pre>
       *
       * <code>repeated .looprpc.RouteHint loop_in_route_hints = 6;</code>
       */
      public Builder addLoopInRouteHints(
          int index, looprpc.Common.RouteHint value) {
        if (loopInRouteHintsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureLoopInRouteHintsIsMutable();
          loopInRouteHints_.add(index, value);
          onChanged();
        } else {
          loopInRouteHintsBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       *
       *Optional route hints to reach the destination through private channels.
       * </pre>
       *
       * <code>repeated .looprpc.RouteHint loop_in_route_hints = 6;</code>
       */
      public Builder addLoopInRouteHints(
          looprpc.Common.RouteHint.Builder builderForValue) {
        if (loopInRouteHintsBuilder_ == null) {
          ensureLoopInRouteHintsIsMutable();
          loopInRouteHints_.add(builderForValue.build());
          onChanged();
        } else {
          loopInRouteHintsBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       *
       *Optional route hints to reach the destination through private channels.
       * </pre>
       *
       * <code>repeated .looprpc.RouteHint loop_in_route_hints = 6;</code>
       */
      public Builder addLoopInRouteHints(
          int index, looprpc.Common.RouteHint.Builder builderForValue) {
        if (loopInRouteHintsBuilder_ == null) {
          ensureLoopInRouteHintsIsMutable();
          loopInRouteHints_.add(index, builderForValue.build());
          onChanged();
        } else {
          loopInRouteHintsBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       *
       *Optional route hints to reach the destination through private channels.
       * </pre>
       *
       * <code>repeated .looprpc.RouteHint loop_in_route_hints = 6;</code>
       */
      public Builder addAllLoopInRouteHints(
          java.lang.Iterable<? extends looprpc.Common.RouteHint> values) {
        if (loopInRouteHintsBuilder_ == null) {
          ensureLoopInRouteHintsIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, loopInRouteHints_);
          onChanged();
        } else {
          loopInRouteHintsBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       *
       *Optional route hints to reach the destination through private channels.
       * </pre>
       *
       * <code>repeated .looprpc.RouteHint loop_in_route_hints = 6;</code>
       */
      public Builder clearLoopInRouteHints() {
        if (loopInRouteHintsBuilder_ == null) {
          loopInRouteHints_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000020);
          onChanged();
        } else {
          loopInRouteHintsBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       *
       *Optional route hints to reach the destination through private channels.
       * </pre>
       *
       * <code>repeated .looprpc.RouteHint loop_in_route_hints = 6;</code>
       */
      public Builder removeLoopInRouteHints(int index) {
        if (loopInRouteHintsBuilder_ == null) {
          ensureLoopInRouteHintsIsMutable();
          loopInRouteHints_.remove(index);
          onChanged();
        } else {
          loopInRouteHintsBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       *
       *Optional route hints to reach the destination through private channels.
       * </pre>
       *
       * <code>repeated .looprpc.RouteHint loop_in_route_hints = 6;</code>
       */
      public looprpc.Common.RouteHint.Builder getLoopInRouteHintsBuilder(
          int index) {
        return getLoopInRouteHintsFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       *
       *Optional route hints to reach the destination through private channels.
       * </pre>
       *
       * <code>repeated .looprpc.RouteHint loop_in_route_hints = 6;</code>
       */
      public looprpc.Common.RouteHintOrBuilder getLoopInRouteHintsOrBuilder(
          int index) {
        if (loopInRouteHintsBuilder_ == null) {
          return loopInRouteHints_.get(index);  } else {
          return loopInRouteHintsBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       *
       *Optional route hints to reach the destination through private channels.
       * </pre>
       *
       * <code>repeated .looprpc.RouteHint loop_in_route_hints = 6;</code>
       */
      public java.util.List<? extends looprpc.Common.RouteHintOrBuilder> 
           getLoopInRouteHintsOrBuilderList() {
        if (loopInRouteHintsBuilder_ != null) {
          return loopInRouteHintsBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(loopInRouteHints_);
        }
      }
      /**
       * <pre>
       *
       *Optional route hints to reach the destination through private channels.
       * </pre>
       *
       * <code>repeated .looprpc.RouteHint loop_in_route_hints = 6;</code>
       */
      public looprpc.Common.RouteHint.Builder addLoopInRouteHintsBuilder() {
        return getLoopInRouteHintsFieldBuilder().addBuilder(
            looprpc.Common.RouteHint.getDefaultInstance());
      }
      /**
       * <pre>
       *
       *Optional route hints to reach the destination through private channels.
       * </pre>
       *
       * <code>repeated .looprpc.RouteHint loop_in_route_hints = 6;</code>
       */
      public looprpc.Common.RouteHint.Builder addLoopInRouteHintsBuilder(
          int index) {
        return getLoopInRouteHintsFieldBuilder().addBuilder(
            index, looprpc.Common.RouteHint.getDefaultInstance());
      }
      /**
       * <pre>
       *
       *Optional route hints to reach the destination through private channels.
       * </pre>
       *
       * <code>repeated .looprpc.RouteHint loop_in_route_hints = 6;</code>
       */
      public java.util.List<looprpc.Common.RouteHint.Builder> 
           getLoopInRouteHintsBuilderList() {
        return getLoopInRouteHintsFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilderV3<
          looprpc.Common.RouteHint, looprpc.Common.RouteHint.Builder, looprpc.Common.RouteHintOrBuilder> 
          getLoopInRouteHintsFieldBuilder() {
        if (loopInRouteHintsBuilder_ == null) {
          loopInRouteHintsBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<
              looprpc.Common.RouteHint, looprpc.Common.RouteHint.Builder, looprpc.Common.RouteHintOrBuilder>(
                  loopInRouteHints_,
                  ((bitField0_ & 0x00000020) != 0),
                  getParentForChildren(),
                  isClean());
          loopInRouteHints_ = null;
        }
        return loopInRouteHintsBuilder_;
      }

      private boolean private_ ;
      /**
       * <pre>
       *
       *Private indicates whether the destination node should be considered
       *private. In which case, loop will generate hophints to assist with
       *probing and payment.
       * </pre>
       *
       * <code>bool private = 7;</code>
       * @return The private.
       */
      @java.lang.Override
      public boolean getPrivate() {
        return private_;
      }
      /**
       * <pre>
       *
       *Private indicates whether the destination node should be considered
       *private. In which case, loop will generate hophints to assist with
       *probing and payment.
       * </pre>
       *
       * <code>bool private = 7;</code>
       * @param value The private to set.
       * @return This builder for chaining.
       */
      public Builder setPrivate(boolean value) {

        private_ = value;
        bitField0_ |= 0x00000040;
        onChanged();
        return this;
      }
      /**
       * <pre>
       *
       *Private indicates whether the destination node should be considered
       *private. In which case, loop will generate hophints to assist with
       *probing and payment.
       * </pre>
       *
       * <code>bool private = 7;</code>
       * @return This builder for chaining.
       */
      public Builder clearPrivate() {
        bitField0_ = (bitField0_ & ~0x00000040);
        private_ = false;
        onChanged();
        return this;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:looprpc.QuoteRequest)
    }

    // @@protoc_insertion_point(class_scope:looprpc.QuoteRequest)
    private static final looprpc.Loop.QuoteRequest DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new looprpc.Loop.QuoteRequest();
    }

    public static looprpc.Loop.QuoteRequest getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<QuoteRequest>
        PARSER = new com.google.protobuf.AbstractParser<QuoteRequest>() {
      @java.lang.Override
      public QuoteRequest parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<QuoteRequest> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<QuoteRequest> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public looprpc.Loop.QuoteRequest getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface InQuoteResponseOrBuilder extends
      // @@protoc_insertion_point(interface_extends:looprpc.InQuoteResponse)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     *
     *The fee that the swap server is charging for the swap.
     * </pre>
     *
     * <code>int64 swap_fee_sat = 1 [jstype = JS_STRING];</code>
     * @return The swapFeeSat.
     */
    long getSwapFeeSat();

    /**
     * <pre>
     *
     *An estimate of the on-chain fee that needs to be paid to publish the HTLC
     *If a miner fee of 0 is returned, it means the external_htlc flag was set for
     *a loop in and the fee estimation was skipped. If a miner fee of -1 is
     *returned, it means lnd's wallet tried to estimate the fee but was unable to
     *create a sample estimation transaction because not enough funds are
     *available. An information message should be shown to the user in this case.
     * </pre>
     *
     * <code>int64 htlc_publish_fee_sat = 3 [jstype = JS_STRING];</code>
     * @return The htlcPublishFeeSat.
     */
    long getHtlcPublishFeeSat();

    /**
     * <pre>
     *
     *On-chain cltv expiry delta
     * </pre>
     *
     * <code>int32 cltv_delta = 5;</code>
     * @return The cltvDelta.
     */
    int getCltvDelta();

    /**
     * <pre>
     *
     *The confirmation target to be used to publish the on-chain HTLC.
     * </pre>
     *
     * <code>int32 conf_target = 6;</code>
     * @return The confTarget.
     */
    int getConfTarget();
  }
  /**
   * Protobuf type {@code looprpc.InQuoteResponse}
   */
  public static final class InQuoteResponse extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:looprpc.InQuoteResponse)
      InQuoteResponseOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use InQuoteResponse.newBuilder() to construct.
    private InQuoteResponse(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private InQuoteResponse() {
    }

    @java.lang.Override
    @SuppressWarnings({"unused"})
    protected java.lang.Object newInstance(
        UnusedPrivateParameter unused) {
      return new InQuoteResponse();
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return looprpc.Loop.internal_static_looprpc_InQuoteResponse_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return looprpc.Loop.internal_static_looprpc_InQuoteResponse_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              looprpc.Loop.InQuoteResponse.class, looprpc.Loop.InQuoteResponse.Builder.class);
    }

    public static final int SWAP_FEE_SAT_FIELD_NUMBER = 1;
    private long swapFeeSat_ = 0L;
    /**
     * <pre>
     *
     *The fee that the swap server is charging for the swap.
     * </pre>
     *
     * <code>int64 swap_fee_sat = 1 [jstype = JS_STRING];</code>
     * @return The swapFeeSat.
     */
    @java.lang.Override
    public long getSwapFeeSat() {
      return swapFeeSat_;
    }

    public static final int HTLC_PUBLISH_FEE_SAT_FIELD_NUMBER = 3;
    private long htlcPublishFeeSat_ = 0L;
    /**
     * <pre>
     *
     *An estimate of the on-chain fee that needs to be paid to publish the HTLC
     *If a miner fee of 0 is returned, it means the external_htlc flag was set for
     *a loop in and the fee estimation was skipped. If a miner fee of -1 is
     *returned, it means lnd's wallet tried to estimate the fee but was unable to
     *create a sample estimation transaction because not enough funds are
     *available. An information message should be shown to the user in this case.
     * </pre>
     *
     * <code>int64 htlc_publish_fee_sat = 3 [jstype = JS_STRING];</code>
     * @return The htlcPublishFeeSat.
     */
    @java.lang.Override
    public long getHtlcPublishFeeSat() {
      return htlcPublishFeeSat_;
    }

    public static final int CLTV_DELTA_FIELD_NUMBER = 5;
    private int cltvDelta_ = 0;
    /**
     * <pre>
     *
     *On-chain cltv expiry delta
     * </pre>
     *
     * <code>int32 cltv_delta = 5;</code>
     * @return The cltvDelta.
     */
    @java.lang.Override
    public int getCltvDelta() {
      return cltvDelta_;
    }

    public static final int CONF_TARGET_FIELD_NUMBER = 6;
    private int confTarget_ = 0;
    /**
     * <pre>
     *
     *The confirmation target to be used to publish the on-chain HTLC.
     * </pre>
     *
     * <code>int32 conf_target = 6;</code>
     * @return The confTarget.
     */
    @java.lang.Override
    public int getConfTarget() {
      return confTarget_;
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (swapFeeSat_ != 0L) {
        output.writeInt64(1, swapFeeSat_);
      }
      if (htlcPublishFeeSat_ != 0L) {
        output.writeInt64(3, htlcPublishFeeSat_);
      }
      if (cltvDelta_ != 0) {
        output.writeInt32(5, cltvDelta_);
      }
      if (confTarget_ != 0) {
        output.writeInt32(6, confTarget_);
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (swapFeeSat_ != 0L) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt64Size(1, swapFeeSat_);
      }
      if (htlcPublishFeeSat_ != 0L) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt64Size(3, htlcPublishFeeSat_);
      }
      if (cltvDelta_ != 0) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt32Size(5, cltvDelta_);
      }
      if (confTarget_ != 0) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt32Size(6, confTarget_);
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof looprpc.Loop.InQuoteResponse)) {
        return super.equals(obj);
      }
      looprpc.Loop.InQuoteResponse other = (looprpc.Loop.InQuoteResponse) obj;

      if (getSwapFeeSat()
          != other.getSwapFeeSat()) return false;
      if (getHtlcPublishFeeSat()
          != other.getHtlcPublishFeeSat()) return false;
      if (getCltvDelta()
          != other.getCltvDelta()) return false;
      if (getConfTarget()
          != other.getConfTarget()) return false;
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      hash = (37 * hash) + SWAP_FEE_SAT_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
          getSwapFeeSat());
      hash = (37 * hash) + HTLC_PUBLISH_FEE_SAT_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
          getHtlcPublishFeeSat());
      hash = (37 * hash) + CLTV_DELTA_FIELD_NUMBER;
      hash = (53 * hash) + getCltvDelta();
      hash = (37 * hash) + CONF_TARGET_FIELD_NUMBER;
      hash = (53 * hash) + getConfTarget();
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static looprpc.Loop.InQuoteResponse parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static looprpc.Loop.InQuoteResponse parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static looprpc.Loop.InQuoteResponse parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static looprpc.Loop.InQuoteResponse parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static looprpc.Loop.InQuoteResponse parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static looprpc.Loop.InQuoteResponse parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static looprpc.Loop.InQuoteResponse parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static looprpc.Loop.InQuoteResponse parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static looprpc.Loop.InQuoteResponse parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static looprpc.Loop.InQuoteResponse parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static looprpc.Loop.InQuoteResponse parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static looprpc.Loop.InQuoteResponse parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(looprpc.Loop.InQuoteResponse prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * Protobuf type {@code looprpc.InQuoteResponse}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:looprpc.InQuoteResponse)
        looprpc.Loop.InQuoteResponseOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return looprpc.Loop.internal_static_looprpc_InQuoteResponse_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return looprpc.Loop.internal_static_looprpc_InQuoteResponse_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                looprpc.Loop.InQuoteResponse.class, looprpc.Loop.InQuoteResponse.Builder.class);
      }

      // Construct using looprpc.Loop.InQuoteResponse.newBuilder()
      private Builder() {

      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);

      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        swapFeeSat_ = 0L;
        htlcPublishFeeSat_ = 0L;
        cltvDelta_ = 0;
        confTarget_ = 0;
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return looprpc.Loop.internal_static_looprpc_InQuoteResponse_descriptor;
      }

      @java.lang.Override
      public looprpc.Loop.InQuoteResponse getDefaultInstanceForType() {
        return looprpc.Loop.InQuoteResponse.getDefaultInstance();
      }

      @java.lang.Override
      public looprpc.Loop.InQuoteResponse build() {
        looprpc.Loop.InQuoteResponse result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public looprpc.Loop.InQuoteResponse buildPartial() {
        looprpc.Loop.InQuoteResponse result = new looprpc.Loop.InQuoteResponse(this);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartial0(looprpc.Loop.InQuoteResponse result) {
        int from_bitField0_ = bitField0_;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.swapFeeSat_ = swapFeeSat_;
        }
        if (((from_bitField0_ & 0x00000002) != 0)) {
          result.htlcPublishFeeSat_ = htlcPublishFeeSat_;
        }
        if (((from_bitField0_ & 0x00000004) != 0)) {
          result.cltvDelta_ = cltvDelta_;
        }
        if (((from_bitField0_ & 0x00000008) != 0)) {
          result.confTarget_ = confTarget_;
        }
      }

      @java.lang.Override
      public Builder clone() {
        return super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof looprpc.Loop.InQuoteResponse) {
          return mergeFrom((looprpc.Loop.InQuoteResponse)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(looprpc.Loop.InQuoteResponse other) {
        if (other == looprpc.Loop.InQuoteResponse.getDefaultInstance()) return this;
        if (other.getSwapFeeSat() != 0L) {
          setSwapFeeSat(other.getSwapFeeSat());
        }
        if (other.getHtlcPublishFeeSat() != 0L) {
          setHtlcPublishFeeSat(other.getHtlcPublishFeeSat());
        }
        if (other.getCltvDelta() != 0) {
          setCltvDelta(other.getCltvDelta());
        }
        if (other.getConfTarget() != 0) {
          setConfTarget(other.getConfTarget());
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 8: {
                swapFeeSat_ = input.readInt64();
                bitField0_ |= 0x00000001;
                break;
              } // case 8
              case 24: {
                htlcPublishFeeSat_ = input.readInt64();
                bitField0_ |= 0x00000002;
                break;
              } // case 24
              case 40: {
                cltvDelta_ = input.readInt32();
                bitField0_ |= 0x00000004;
                break;
              } // case 40
              case 48: {
                confTarget_ = input.readInt32();
                bitField0_ |= 0x00000008;
                break;
              } // case 48
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private long swapFeeSat_ ;
      /**
       * <pre>
       *
       *The fee that the swap server is charging for the swap.
       * </pre>
       *
       * <code>int64 swap_fee_sat = 1 [jstype = JS_STRING];</code>
       * @return The swapFeeSat.
       */
      @java.lang.Override
      public long getSwapFeeSat() {
        return swapFeeSat_;
      }
      /**
       * <pre>
       *
       *The fee that the swap server is charging for the swap.
       * </pre>
       *
       * <code>int64 swap_fee_sat = 1 [jstype = JS_STRING];</code>
       * @param value The swapFeeSat to set.
       * @return This builder for chaining.
       */
      public Builder setSwapFeeSat(long value) {

        swapFeeSat_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       *
       *The fee that the swap server is charging for the swap.
       * </pre>
       *
       * <code>int64 swap_fee_sat = 1 [jstype = JS_STRING];</code>
       * @return This builder for chaining.
       */
      public Builder clearSwapFeeSat() {
        bitField0_ = (bitField0_ & ~0x00000001);
        swapFeeSat_ = 0L;
        onChanged();
        return this;
      }

      private long htlcPublishFeeSat_ ;
      /**
       * <pre>
       *
       *An estimate of the on-chain fee that needs to be paid to publish the HTLC
       *If a miner fee of 0 is returned, it means the external_htlc flag was set for
       *a loop in and the fee estimation was skipped. If a miner fee of -1 is
       *returned, it means lnd's wallet tried to estimate the fee but was unable to
       *create a sample estimation transaction because not enough funds are
       *available. An information message should be shown to the user in this case.
       * </pre>
       *
       * <code>int64 htlc_publish_fee_sat = 3 [jstype = JS_STRING];</code>
       * @return The htlcPublishFeeSat.
       */
      @java.lang.Override
      public long getHtlcPublishFeeSat() {
        return htlcPublishFeeSat_;
      }
      /**
       * <pre>
       *
       *An estimate of the on-chain fee that needs to be paid to publish the HTLC
       *If a miner fee of 0 is returned, it means the external_htlc flag was set for
       *a loop in and the fee estimation was skipped. If a miner fee of -1 is
       *returned, it means lnd's wallet tried to estimate the fee but was unable to
       *create a sample estimation transaction because not enough funds are
       *available. An information message should be shown to the user in this case.
       * </pre>
       *
       * <code>int64 htlc_publish_fee_sat = 3 [jstype = JS_STRING];</code>
       * @param value The htlcPublishFeeSat to set.
       * @return This builder for chaining.
       */
      public Builder setHtlcPublishFeeSat(long value) {

        htlcPublishFeeSat_ = value;
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       *
       *An estimate of the on-chain fee that needs to be paid to publish the HTLC
       *If a miner fee of 0 is returned, it means the external_htlc flag was set for
       *a loop in and the fee estimation was skipped. If a miner fee of -1 is
       *returned, it means lnd's wallet tried to estimate the fee but was unable to
       *create a sample estimation transaction because not enough funds are
       *available. An information message should be shown to the user in this case.
       * </pre>
       *
       * <code>int64 htlc_publish_fee_sat = 3 [jstype = JS_STRING];</code>
       * @return This builder for chaining.
       */
      public Builder clearHtlcPublishFeeSat() {
        bitField0_ = (bitField0_ & ~0x00000002);
        htlcPublishFeeSat_ = 0L;
        onChanged();
        return this;
      }

      private int cltvDelta_ ;
      /**
       * <pre>
       *
       *On-chain cltv expiry delta
       * </pre>
       *
       * <code>int32 cltv_delta = 5;</code>
       * @return The cltvDelta.
       */
      @java.lang.Override
      public int getCltvDelta() {
        return cltvDelta_;
      }
      /**
       * <pre>
       *
       *On-chain cltv expiry delta
       * </pre>
       *
       * <code>int32 cltv_delta = 5;</code>
       * @param value The cltvDelta to set.
       * @return This builder for chaining.
       */
      public Builder setCltvDelta(int value) {

        cltvDelta_ = value;
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }
      /**
       * <pre>
       *
       *On-chain cltv expiry delta
       * </pre>
       *
       * <code>int32 cltv_delta = 5;</code>
       * @return This builder for chaining.
       */
      public Builder clearCltvDelta() {
        bitField0_ = (bitField0_ & ~0x00000004);
        cltvDelta_ = 0;
        onChanged();
        return this;
      }

      private int confTarget_ ;
      /**
       * <pre>
       *
       *The confirmation target to be used to publish the on-chain HTLC.
       * </pre>
       *
       * <code>int32 conf_target = 6;</code>
       * @return The confTarget.
       */
      @java.lang.Override
      public int getConfTarget() {
        return confTarget_;
      }
      /**
       * <pre>
       *
       *The confirmation target to be used to publish the on-chain HTLC.
       * </pre>
       *
       * <code>int32 conf_target = 6;</code>
       * @param value The confTarget to set.
       * @return This builder for chaining.
       */
      public Builder setConfTarget(int value) {

        confTarget_ = value;
        bitField0_ |= 0x00000008;
        onChanged();
        return this;
      }
      /**
       * <pre>
       *
       *The confirmation target to be used to publish the on-chain HTLC.
       * </pre>
       *
       * <code>int32 conf_target = 6;</code>
       * @return This builder for chaining.
       */
      public Builder clearConfTarget() {
        bitField0_ = (bitField0_ & ~0x00000008);
        confTarget_ = 0;
        onChanged();
        return this;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:looprpc.InQuoteResponse)
    }

    // @@protoc_insertion_point(class_scope:looprpc.InQuoteResponse)
    private static final looprpc.Loop.InQuoteResponse DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new looprpc.Loop.InQuoteResponse();
    }

    public static looprpc.Loop.InQuoteResponse getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<InQuoteResponse>
        PARSER = new com.google.protobuf.AbstractParser<InQuoteResponse>() {
      @java.lang.Override
      public InQuoteResponse parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<InQuoteResponse> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<InQuoteResponse> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public looprpc.Loop.InQuoteResponse getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface OutQuoteResponseOrBuilder extends
      // @@protoc_insertion_point(interface_extends:looprpc.OutQuoteResponse)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     *
     *The fee that the swap server is charging for the swap.
     * </pre>
     *
     * <code>int64 swap_fee_sat = 1 [jstype = JS_STRING];</code>
     * @return The swapFeeSat.
     */
    long getSwapFeeSat();

    /**
     * <pre>
     *
     *The part of the swap fee that is requested as a prepayment.
     * </pre>
     *
     * <code>int64 prepay_amt_sat = 2 [jstype = JS_STRING];</code>
     * @return The prepayAmtSat.
     */
    long getPrepayAmtSat();

    /**
     * <pre>
     *
     *An estimate of the on-chain fee that needs to be paid to sweep the HTLC for
     *a loop out.
     * </pre>
     *
     * <code>int64 htlc_sweep_fee_sat = 3 [jstype = JS_STRING];</code>
     * @return The htlcSweepFeeSat.
     */
    long getHtlcSweepFeeSat();

    /**
     * <pre>
     *
     *The node pubkey where the swap payment needs to be paid
     *to. This can be used to test connectivity before initiating the swap.
     * </pre>
     *
     * <code>bytes swap_payment_dest = 4;</code>
     * @return The swapPaymentDest.
     */
    com.google.protobuf.ByteString getSwapPaymentDest();

    /**
     * <pre>
     *
     *On-chain cltv expiry delta
     * </pre>
     *
     * <code>int32 cltv_delta = 5;</code>
     * @return The cltvDelta.
     */
    int getCltvDelta();

    /**
     * <pre>
     *
     *The confirmation target to be used for the sweep of the on-chain HTLC.
     * </pre>
     *
     * <code>int32 conf_target = 6;</code>
     * @return The confTarget.
     */
    int getConfTarget();
  }
  /**
   * Protobuf type {@code looprpc.OutQuoteResponse}
   */
  public static final class OutQuoteResponse extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:looprpc.OutQuoteResponse)
      OutQuoteResponseOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use OutQuoteResponse.newBuilder() to construct.
    private OutQuoteResponse(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private OutQuoteResponse() {
      swapPaymentDest_ = com.google.protobuf.ByteString.EMPTY;
    }

    @java.lang.Override
    @SuppressWarnings({"unused"})
    protected java.lang.Object newInstance(
        UnusedPrivateParameter unused) {
      return new OutQuoteResponse();
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return looprpc.Loop.internal_static_looprpc_OutQuoteResponse_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return looprpc.Loop.internal_static_looprpc_OutQuoteResponse_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              looprpc.Loop.OutQuoteResponse.class, looprpc.Loop.OutQuoteResponse.Builder.class);
    }

    public static final int SWAP_FEE_SAT_FIELD_NUMBER = 1;
    private long swapFeeSat_ = 0L;
    /**
     * <pre>
     *
     *The fee that the swap server is charging for the swap.
     * </pre>
     *
     * <code>int64 swap_fee_sat = 1 [jstype = JS_STRING];</code>
     * @return The swapFeeSat.
     */
    @java.lang.Override
    public long getSwapFeeSat() {
      return swapFeeSat_;
    }

    public static final int PREPAY_AMT_SAT_FIELD_NUMBER = 2;
    private long prepayAmtSat_ = 0L;
    /**
     * <pre>
     *
     *The part of the swap fee that is requested as a prepayment.
     * </pre>
     *
     * <code>int64 prepay_amt_sat = 2 [jstype = JS_STRING];</code>
     * @return The prepayAmtSat.
     */
    @java.lang.Override
    public long getPrepayAmtSat() {
      return prepayAmtSat_;
    }

    public static final int HTLC_SWEEP_FEE_SAT_FIELD_NUMBER = 3;
    private long htlcSweepFeeSat_ = 0L;
    /**
     * <pre>
     *
     *An estimate of the on-chain fee that needs to be paid to sweep the HTLC for
     *a loop out.
     * </pre>
     *
     * <code>int64 htlc_sweep_fee_sat = 3 [jstype = JS_STRING];</code>
     * @return The htlcSweepFeeSat.
     */
    @java.lang.Override
    public long getHtlcSweepFeeSat() {
      return htlcSweepFeeSat_;
    }

    public static final int SWAP_PAYMENT_DEST_FIELD_NUMBER = 4;
    private com.google.protobuf.ByteString swapPaymentDest_ = com.google.protobuf.ByteString.EMPTY;
    /**
     * <pre>
     *
     *The node pubkey where the swap payment needs to be paid
     *to. This can be used to test connectivity before initiating the swap.
     * </pre>
     *
     * <code>bytes swap_payment_dest = 4;</code>
     * @return The swapPaymentDest.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString getSwapPaymentDest() {
      return swapPaymentDest_;
    }

    public static final int CLTV_DELTA_FIELD_NUMBER = 5;
    private int cltvDelta_ = 0;
    /**
     * <pre>
     *
     *On-chain cltv expiry delta
     * </pre>
     *
     * <code>int32 cltv_delta = 5;</code>
     * @return The cltvDelta.
     */
    @java.lang.Override
    public int getCltvDelta() {
      return cltvDelta_;
    }

    public static final int CONF_TARGET_FIELD_NUMBER = 6;
    private int confTarget_ = 0;
    /**
     * <pre>
     *
     *The confirmation target to be used for the sweep of the on-chain HTLC.
     * </pre>
     *
     * <code>int32 conf_target = 6;</code>
     * @return The confTarget.
     */
    @java.lang.Override
    public int getConfTarget() {
      return confTarget_;
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (swapFeeSat_ != 0L) {
        output.writeInt64(1, swapFeeSat_);
      }
      if (prepayAmtSat_ != 0L) {
        output.writeInt64(2, prepayAmtSat_);
      }
      if (htlcSweepFeeSat_ != 0L) {
        output.writeInt64(3, htlcSweepFeeSat_);
      }
      if (!swapPaymentDest_.isEmpty()) {
        output.writeBytes(4, swapPaymentDest_);
      }
      if (cltvDelta_ != 0) {
        output.writeInt32(5, cltvDelta_);
      }
      if (confTarget_ != 0) {
        output.writeInt32(6, confTarget_);
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (swapFeeSat_ != 0L) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt64Size(1, swapFeeSat_);
      }
      if (prepayAmtSat_ != 0L) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt64Size(2, prepayAmtSat_);
      }
      if (htlcSweepFeeSat_ != 0L) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt64Size(3, htlcSweepFeeSat_);
      }
      if (!swapPaymentDest_.isEmpty()) {
        size += com.google.protobuf.CodedOutputStream
          .computeBytesSize(4, swapPaymentDest_);
      }
      if (cltvDelta_ != 0) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt32Size(5, cltvDelta_);
      }
      if (confTarget_ != 0) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt32Size(6, confTarget_);
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof looprpc.Loop.OutQuoteResponse)) {
        return super.equals(obj);
      }
      looprpc.Loop.OutQuoteResponse other = (looprpc.Loop.OutQuoteResponse) obj;

      if (getSwapFeeSat()
          != other.getSwapFeeSat()) return false;
      if (getPrepayAmtSat()
          != other.getPrepayAmtSat()) return false;
      if (getHtlcSweepFeeSat()
          != other.getHtlcSweepFeeSat()) return false;
      if (!getSwapPaymentDest()
          .equals(other.getSwapPaymentDest())) return false;
      if (getCltvDelta()
          != other.getCltvDelta()) return false;
      if (getConfTarget()
          != other.getConfTarget()) return false;
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      hash = (37 * hash) + SWAP_FEE_SAT_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
          getSwapFeeSat());
      hash = (37 * hash) + PREPAY_AMT_SAT_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
          getPrepayAmtSat());
      hash = (37 * hash) + HTLC_SWEEP_FEE_SAT_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
          getHtlcSweepFeeSat());
      hash = (37 * hash) + SWAP_PAYMENT_DEST_FIELD_NUMBER;
      hash = (53 * hash) + getSwapPaymentDest().hashCode();
      hash = (37 * hash) + CLTV_DELTA_FIELD_NUMBER;
      hash = (53 * hash) + getCltvDelta();
      hash = (37 * hash) + CONF_TARGET_FIELD_NUMBER;
      hash = (53 * hash) + getConfTarget();
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static looprpc.Loop.OutQuoteResponse parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static looprpc.Loop.OutQuoteResponse parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static looprpc.Loop.OutQuoteResponse parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static looprpc.Loop.OutQuoteResponse parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static looprpc.Loop.OutQuoteResponse parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static looprpc.Loop.OutQuoteResponse parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static looprpc.Loop.OutQuoteResponse parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static looprpc.Loop.OutQuoteResponse parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static looprpc.Loop.OutQuoteResponse parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static looprpc.Loop.OutQuoteResponse parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static looprpc.Loop.OutQuoteResponse parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static looprpc.Loop.OutQuoteResponse parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(looprpc.Loop.OutQuoteResponse prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * Protobuf type {@code looprpc.OutQuoteResponse}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:looprpc.OutQuoteResponse)
        looprpc.Loop.OutQuoteResponseOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return looprpc.Loop.internal_static_looprpc_OutQuoteResponse_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return looprpc.Loop.internal_static_looprpc_OutQuoteResponse_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                looprpc.Loop.OutQuoteResponse.class, looprpc.Loop.OutQuoteResponse.Builder.class);
      }

      // Construct using looprpc.Loop.OutQuoteResponse.newBuilder()
      private Builder() {

      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);

      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        swapFeeSat_ = 0L;
        prepayAmtSat_ = 0L;
        htlcSweepFeeSat_ = 0L;
        swapPaymentDest_ = com.google.protobuf.ByteString.EMPTY;
        cltvDelta_ = 0;
        confTarget_ = 0;
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return looprpc.Loop.internal_static_looprpc_OutQuoteResponse_descriptor;
      }

      @java.lang.Override
      public looprpc.Loop.OutQuoteResponse getDefaultInstanceForType() {
        return looprpc.Loop.OutQuoteResponse.getDefaultInstance();
      }

      @java.lang.Override
      public looprpc.Loop.OutQuoteResponse build() {
        looprpc.Loop.OutQuoteResponse result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public looprpc.Loop.OutQuoteResponse buildPartial() {
        looprpc.Loop.OutQuoteResponse result = new looprpc.Loop.OutQuoteResponse(this);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartial0(looprpc.Loop.OutQuoteResponse result) {
        int from_bitField0_ = bitField0_;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.swapFeeSat_ = swapFeeSat_;
        }
        if (((from_bitField0_ & 0x00000002) != 0)) {
          result.prepayAmtSat_ = prepayAmtSat_;
        }
        if (((from_bitField0_ & 0x00000004) != 0)) {
          result.htlcSweepFeeSat_ = htlcSweepFeeSat_;
        }
        if (((from_bitField0_ & 0x00000008) != 0)) {
          result.swapPaymentDest_ = swapPaymentDest_;
        }
        if (((from_bitField0_ & 0x00000010) != 0)) {
          result.cltvDelta_ = cltvDelta_;
        }
        if (((from_bitField0_ & 0x00000020) != 0)) {
          result.confTarget_ = confTarget_;
        }
      }

      @java.lang.Override
      public Builder clone() {
        return super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof looprpc.Loop.OutQuoteResponse) {
          return mergeFrom((looprpc.Loop.OutQuoteResponse)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(looprpc.Loop.OutQuoteResponse other) {
        if (other == looprpc.Loop.OutQuoteResponse.getDefaultInstance()) return this;
        if (other.getSwapFeeSat() != 0L) {
          setSwapFeeSat(other.getSwapFeeSat());
        }
        if (other.getPrepayAmtSat() != 0L) {
          setPrepayAmtSat(other.getPrepayAmtSat());
        }
        if (other.getHtlcSweepFeeSat() != 0L) {
          setHtlcSweepFeeSat(other.getHtlcSweepFeeSat());
        }
        if (other.getSwapPaymentDest() != com.google.protobuf.ByteString.EMPTY) {
          setSwapPaymentDest(other.getSwapPaymentDest());
        }
        if (other.getCltvDelta() != 0) {
          setCltvDelta(other.getCltvDelta());
        }
        if (other.getConfTarget() != 0) {
          setConfTarget(other.getConfTarget());
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 8: {
                swapFeeSat_ = input.readInt64();
                bitField0_ |= 0x00000001;
                break;
              } // case 8
              case 16: {
                prepayAmtSat_ = input.readInt64();
                bitField0_ |= 0x00000002;
                break;
              } // case 16
              case 24: {
                htlcSweepFeeSat_ = input.readInt64();
                bitField0_ |= 0x00000004;
                break;
              } // case 24
              case 34: {
                swapPaymentDest_ = input.readBytes();
                bitField0_ |= 0x00000008;
                break;
              } // case 34
              case 40: {
                cltvDelta_ = input.readInt32();
                bitField0_ |= 0x00000010;
                break;
              } // case 40
              case 48: {
                confTarget_ = input.readInt32();
                bitField0_ |= 0x00000020;
                break;
              } // case 48
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private long swapFeeSat_ ;
      /**
       * <pre>
       *
       *The fee that the swap server is charging for the swap.
       * </pre>
       *
       * <code>int64 swap_fee_sat = 1 [jstype = JS_STRING];</code>
       * @return The swapFeeSat.
       */
      @java.lang.Override
      public long getSwapFeeSat() {
        return swapFeeSat_;
      }
      /**
       * <pre>
       *
       *The fee that the swap server is charging for the swap.
       * </pre>
       *
       * <code>int64 swap_fee_sat = 1 [jstype = JS_STRING];</code>
       * @param value The swapFeeSat to set.
       * @return This builder for chaining.
       */
      public Builder setSwapFeeSat(long value) {

        swapFeeSat_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       *
       *The fee that the swap server is charging for the swap.
       * </pre>
       *
       * <code>int64 swap_fee_sat = 1 [jstype = JS_STRING];</code>
       * @return This builder for chaining.
       */
      public Builder clearSwapFeeSat() {
        bitField0_ = (bitField0_ & ~0x00000001);
        swapFeeSat_ = 0L;
        onChanged();
        return this;
      }

      private long prepayAmtSat_ ;
      /**
       * <pre>
       *
       *The part of the swap fee that is requested as a prepayment.
       * </pre>
       *
       * <code>int64 prepay_amt_sat = 2 [jstype = JS_STRING];</code>
       * @return The prepayAmtSat.
       */
      @java.lang.Override
      public long getPrepayAmtSat() {
        return prepayAmtSat_;
      }
      /**
       * <pre>
       *
       *The part of the swap fee that is requested as a prepayment.
       * </pre>
       *
       * <code>int64 prepay_amt_sat = 2 [jstype = JS_STRING];</code>
       * @param value The prepayAmtSat to set.
       * @return This builder for chaining.
       */
      public Builder setPrepayAmtSat(long value) {

        prepayAmtSat_ = value;
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       *
       *The part of the swap fee that is requested as a prepayment.
       * </pre>
       *
       * <code>int64 prepay_amt_sat = 2 [jstype = JS_STRING];</code>
       * @return This builder for chaining.
       */
      public Builder clearPrepayAmtSat() {
        bitField0_ = (bitField0_ & ~0x00000002);
        prepayAmtSat_ = 0L;
        onChanged();
        return this;
      }

      private long htlcSweepFeeSat_ ;
      /**
       * <pre>
       *
       *An estimate of the on-chain fee that needs to be paid to sweep the HTLC for
       *a loop out.
       * </pre>
       *
       * <code>int64 htlc_sweep_fee_sat = 3 [jstype = JS_STRING];</code>
       * @return The htlcSweepFeeSat.
       */
      @java.lang.Override
      public long getHtlcSweepFeeSat() {
        return htlcSweepFeeSat_;
      }
      /**
       * <pre>
       *
       *An estimate of the on-chain fee that needs to be paid to sweep the HTLC for
       *a loop out.
       * </pre>
       *
       * <code>int64 htlc_sweep_fee_sat = 3 [jstype = JS_STRING];</code>
       * @param value The htlcSweepFeeSat to set.
       * @return This builder for chaining.
       */
      public Builder setHtlcSweepFeeSat(long value) {

        htlcSweepFeeSat_ = value;
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }
      /**
       * <pre>
       *
       *An estimate of the on-chain fee that needs to be paid to sweep the HTLC for
       *a loop out.
       * </pre>
       *
       * <code>int64 htlc_sweep_fee_sat = 3 [jstype = JS_STRING];</code>
       * @return This builder for chaining.
       */
      public Builder clearHtlcSweepFeeSat() {
        bitField0_ = (bitField0_ & ~0x00000004);
        htlcSweepFeeSat_ = 0L;
        onChanged();
        return this;
      }

      private com.google.protobuf.ByteString swapPaymentDest_ = com.google.protobuf.ByteString.EMPTY;
      /**
       * <pre>
       *
       *The node pubkey where the swap payment needs to be paid
       *to. This can be used to test connectivity before initiating the swap.
       * </pre>
       *
       * <code>bytes swap_payment_dest = 4;</code>
       * @return The swapPaymentDest.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString getSwapPaymentDest() {
        return swapPaymentDest_;
      }
      /**
       * <pre>
       *
       *The node pubkey where the swap payment needs to be paid
       *to. This can be used to test connectivity before initiating the swap.
       * </pre>
       *
       * <code>bytes swap_payment_dest = 4;</code>
       * @param value The swapPaymentDest to set.
       * @return This builder for chaining.
       */
      public Builder setSwapPaymentDest(com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        swapPaymentDest_ = value;
        bitField0_ |= 0x00000008;
        onChanged();
        return this;
      }
      /**
       * <pre>
       *
       *The node pubkey where the swap payment needs to be paid
       *to. This can be used to test connectivity before initiating the swap.
       * </pre>
       *
       * <code>bytes swap_payment_dest = 4;</code>
       * @return This builder for chaining.
       */
      public Builder clearSwapPaymentDest() {
        bitField0_ = (bitField0_ & ~0x00000008);
        swapPaymentDest_ = getDefaultInstance().getSwapPaymentDest();
        onChanged();
        return this;
      }

      private int cltvDelta_ ;
      /**
       * <pre>
       *
       *On-chain cltv expiry delta
       * </pre>
       *
       * <code>int32 cltv_delta = 5;</code>
       * @return The cltvDelta.
       */
      @java.lang.Override
      public int getCltvDelta() {
        return cltvDelta_;
      }
      /**
       * <pre>
       *
       *On-chain cltv expiry delta
       * </pre>
       *
       * <code>int32 cltv_delta = 5;</code>
       * @param value The cltvDelta to set.
       * @return This builder for chaining.
       */
      public Builder setCltvDelta(int value) {

        cltvDelta_ = value;
        bitField0_ |= 0x00000010;
        onChanged();
        return this;
      }
      /**
       * <pre>
       *
       *On-chain cltv expiry delta
       * </pre>
       *
       * <code>int32 cltv_delta = 5;</code>
       * @return This builder for chaining.
       */
      public Builder clearCltvDelta() {
        bitField0_ = (bitField0_ & ~0x00000010);
        cltvDelta_ = 0;
        onChanged();
        return this;
      }

      private int confTarget_ ;
      /**
       * <pre>
       *
       *The confirmation target to be used for the sweep of the on-chain HTLC.
       * </pre>
       *
       * <code>int32 conf_target = 6;</code>
       * @return The confTarget.
       */
      @java.lang.Override
      public int getConfTarget() {
        return confTarget_;
      }
      /**
       * <pre>
       *
       *The confirmation target to be used for the sweep of the on-chain HTLC.
       * </pre>
       *
       * <code>int32 conf_target = 6;</code>
       * @param value The confTarget to set.
       * @return This builder for chaining.
       */
      public Builder setConfTarget(int value) {

        confTarget_ = value;
        bitField0_ |= 0x00000020;
        onChanged();
        return this;
      }
      /**
       * <pre>
       *
       *The confirmation target to be used for the sweep of the on-chain HTLC.
       * </pre>
       *
       * <code>int32 conf_target = 6;</code>
       * @return This builder for chaining.
       */
      public Builder clearConfTarget() {
        bitField0_ = (bitField0_ & ~0x00000020);
        confTarget_ = 0;
        onChanged();
        return this;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:looprpc.OutQuoteResponse)
    }

    // @@protoc_insertion_point(class_scope:looprpc.OutQuoteResponse)
    private static final looprpc.Loop.OutQuoteResponse DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new looprpc.Loop.OutQuoteResponse();
    }

    public static looprpc.Loop.OutQuoteResponse getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<OutQuoteResponse>
        PARSER = new com.google.protobuf.AbstractParser<OutQuoteResponse>() {
      @java.lang.Override
      public OutQuoteResponse parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<OutQuoteResponse> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<OutQuoteResponse> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public looprpc.Loop.OutQuoteResponse getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface ProbeRequestOrBuilder extends
      // @@protoc_insertion_point(interface_extends:looprpc.ProbeRequest)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     *
     *The amount to probe.
     * </pre>
     *
     * <code>int64 amt = 1 [jstype = JS_STRING];</code>
     * @return The amt.
     */
    long getAmt();

    /**
     * <pre>
     *
     *Optional last hop of the route to probe.
     * </pre>
     *
     * <code>bytes last_hop = 2;</code>
     * @return The lastHop.
     */
    com.google.protobuf.ByteString getLastHop();

    /**
     * <pre>
     *
     *Optional route hints to reach the destination through private channels.
     * </pre>
     *
     * <code>repeated .looprpc.RouteHint route_hints = 3;</code>
     */
    java.util.List<looprpc.Common.RouteHint> 
        getRouteHintsList();
    /**
     * <pre>
     *
     *Optional route hints to reach the destination through private channels.
     * </pre>
     *
     * <code>repeated .looprpc.RouteHint route_hints = 3;</code>
     */
    looprpc.Common.RouteHint getRouteHints(int index);
    /**
     * <pre>
     *
     *Optional route hints to reach the destination through private channels.
     * </pre>
     *
     * <code>repeated .looprpc.RouteHint route_hints = 3;</code>
     */
    int getRouteHintsCount();
    /**
     * <pre>
     *
     *Optional route hints to reach the destination through private channels.
     * </pre>
     *
     * <code>repeated .looprpc.RouteHint route_hints = 3;</code>
     */
    java.util.List<? extends looprpc.Common.RouteHintOrBuilder> 
        getRouteHintsOrBuilderList();
    /**
     * <pre>
     *
     *Optional route hints to reach the destination through private channels.
     * </pre>
     *
     * <code>repeated .looprpc.RouteHint route_hints = 3;</code>
     */
    looprpc.Common.RouteHintOrBuilder getRouteHintsOrBuilder(
        int index);
  }
  /**
   * Protobuf type {@code looprpc.ProbeRequest}
   */
  public static final class ProbeRequest extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:looprpc.ProbeRequest)
      ProbeRequestOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use ProbeRequest.newBuilder() to construct.
    private ProbeRequest(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private ProbeRequest() {
      lastHop_ = com.google.protobuf.ByteString.EMPTY;
      routeHints_ = java.util.Collections.emptyList();
    }

    @java.lang.Override
    @SuppressWarnings({"unused"})
    protected java.lang.Object newInstance(
        UnusedPrivateParameter unused) {
      return new ProbeRequest();
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return looprpc.Loop.internal_static_looprpc_ProbeRequest_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return looprpc.Loop.internal_static_looprpc_ProbeRequest_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              looprpc.Loop.ProbeRequest.class, looprpc.Loop.ProbeRequest.Builder.class);
    }

    public static final int AMT_FIELD_NUMBER = 1;
    private long amt_ = 0L;
    /**
     * <pre>
     *
     *The amount to probe.
     * </pre>
     *
     * <code>int64 amt = 1 [jstype = JS_STRING];</code>
     * @return The amt.
     */
    @java.lang.Override
    public long getAmt() {
      return amt_;
    }

    public static final int LAST_HOP_FIELD_NUMBER = 2;
    private com.google.protobuf.ByteString lastHop_ = com.google.protobuf.ByteString.EMPTY;
    /**
     * <pre>
     *
     *Optional last hop of the route to probe.
     * </pre>
     *
     * <code>bytes last_hop = 2;</code>
     * @return The lastHop.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString getLastHop() {
      return lastHop_;
    }

    public static final int ROUTE_HINTS_FIELD_NUMBER = 3;
    @SuppressWarnings("serial")
    private java.util.List<looprpc.Common.RouteHint> routeHints_;
    /**
     * <pre>
     *
     *Optional route hints to reach the destination through private channels.
     * </pre>
     *
     * <code>repeated .looprpc.RouteHint route_hints = 3;</code>
     */
    @java.lang.Override
    public java.util.List<looprpc.Common.RouteHint> getRouteHintsList() {
      return routeHints_;
    }
    /**
     * <pre>
     *
     *Optional route hints to reach the destination through private channels.
     * </pre>
     *
     * <code>repeated .looprpc.RouteHint route_hints = 3;</code>
     */
    @java.lang.Override
    public java.util.List<? extends looprpc.Common.RouteHintOrBuilder> 
        getRouteHintsOrBuilderList() {
      return routeHints_;
    }
    /**
     * <pre>
     *
     *Optional route hints to reach the destination through private channels.
     * </pre>
     *
     * <code>repeated .looprpc.RouteHint route_hints = 3;</code>
     */
    @java.lang.Override
    public int getRouteHintsCount() {
      return routeHints_.size();
    }
    /**
     * <pre>
     *
     *Optional route hints to reach the destination through private channels.
     * </pre>
     *
     * <code>repeated .looprpc.RouteHint route_hints = 3;</code>
     */
    @java.lang.Override
    public looprpc.Common.RouteHint getRouteHints(int index) {
      return routeHints_.get(index);
    }
    /**
     * <pre>
     *
     *Optional route hints to reach the destination through private channels.
     * </pre>
     *
     * <code>repeated .looprpc.RouteHint route_hints = 3;</code>
     */
    @java.lang.Override
    public looprpc.Common.RouteHintOrBuilder getRouteHintsOrBuilder(
        int index) {
      return routeHints_.get(index);
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (amt_ != 0L) {
        output.writeInt64(1, amt_);
      }
      if (!lastHop_.isEmpty()) {
        output.writeBytes(2, lastHop_);
      }
      for (int i = 0; i < routeHints_.size(); i++) {
        output.writeMessage(3, routeHints_.get(i));
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (amt_ != 0L) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt64Size(1, amt_);
      }
      if (!lastHop_.isEmpty()) {
        size += com.google.protobuf.CodedOutputStream
          .computeBytesSize(2, lastHop_);
      }
      for (int i = 0; i < routeHints_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(3, routeHints_.get(i));
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof looprpc.Loop.ProbeRequest)) {
        return super.equals(obj);
      }
      looprpc.Loop.ProbeRequest other = (looprpc.Loop.ProbeRequest) obj;

      if (getAmt()
          != other.getAmt()) return false;
      if (!getLastHop()
          .equals(other.getLastHop())) return false;
      if (!getRouteHintsList()
          .equals(other.getRouteHintsList())) return false;
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      hash = (37 * hash) + AMT_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
          getAmt());
      hash = (37 * hash) + LAST_HOP_FIELD_NUMBER;
      hash = (53 * hash) + getLastHop().hashCode();
      if (getRouteHintsCount() > 0) {
        hash = (37 * hash) + ROUTE_HINTS_FIELD_NUMBER;
        hash = (53 * hash) + getRouteHintsList().hashCode();
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static looprpc.Loop.ProbeRequest parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static looprpc.Loop.ProbeRequest parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static looprpc.Loop.ProbeRequest parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static looprpc.Loop.ProbeRequest parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static looprpc.Loop.ProbeRequest parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static looprpc.Loop.ProbeRequest parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static looprpc.Loop.ProbeRequest parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static looprpc.Loop.ProbeRequest parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static looprpc.Loop.ProbeRequest parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static looprpc.Loop.ProbeRequest parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static looprpc.Loop.ProbeRequest parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static looprpc.Loop.ProbeRequest parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(looprpc.Loop.ProbeRequest prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * Protobuf type {@code looprpc.ProbeRequest}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:looprpc.ProbeRequest)
        looprpc.Loop.ProbeRequestOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return looprpc.Loop.internal_static_looprpc_ProbeRequest_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return looprpc.Loop.internal_static_looprpc_ProbeRequest_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                looprpc.Loop.ProbeRequest.class, looprpc.Loop.ProbeRequest.Builder.class);
      }

      // Construct using looprpc.Loop.ProbeRequest.newBuilder()
      private Builder() {

      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);

      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        amt_ = 0L;
        lastHop_ = com.google.protobuf.ByteString.EMPTY;
        if (routeHintsBuilder_ == null) {
          routeHints_ = java.util.Collections.emptyList();
        } else {
          routeHints_ = null;
          routeHintsBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000004);
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return looprpc.Loop.internal_static_looprpc_ProbeRequest_descriptor;
      }

      @java.lang.Override
      public looprpc.Loop.ProbeRequest getDefaultInstanceForType() {
        return looprpc.Loop.ProbeRequest.getDefaultInstance();
      }

      @java.lang.Override
      public looprpc.Loop.ProbeRequest build() {
        looprpc.Loop.ProbeRequest result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public looprpc.Loop.ProbeRequest buildPartial() {
        looprpc.Loop.ProbeRequest result = new looprpc.Loop.ProbeRequest(this);
        buildPartialRepeatedFields(result);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartialRepeatedFields(looprpc.Loop.ProbeRequest result) {
        if (routeHintsBuilder_ == null) {
          if (((bitField0_ & 0x00000004) != 0)) {
            routeHints_ = java.util.Collections.unmodifiableList(routeHints_);
            bitField0_ = (bitField0_ & ~0x00000004);
          }
          result.routeHints_ = routeHints_;
        } else {
          result.routeHints_ = routeHintsBuilder_.build();
        }
      }

      private void buildPartial0(looprpc.Loop.ProbeRequest result) {
        int from_bitField0_ = bitField0_;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.amt_ = amt_;
        }
        if (((from_bitField0_ & 0x00000002) != 0)) {
          result.lastHop_ = lastHop_;
        }
      }

      @java.lang.Override
      public Builder clone() {
        return super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof looprpc.Loop.ProbeRequest) {
          return mergeFrom((looprpc.Loop.ProbeRequest)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(looprpc.Loop.ProbeRequest other) {
        if (other == looprpc.Loop.ProbeRequest.getDefaultInstance()) return this;
        if (other.getAmt() != 0L) {
          setAmt(other.getAmt());
        }
        if (other.getLastHop() != com.google.protobuf.ByteString.EMPTY) {
          setLastHop(other.getLastHop());
        }
        if (routeHintsBuilder_ == null) {
          if (!other.routeHints_.isEmpty()) {
            if (routeHints_.isEmpty()) {
              routeHints_ = other.routeHints_;
              bitField0_ = (bitField0_ & ~0x00000004);
            } else {
              ensureRouteHintsIsMutable();
              routeHints_.addAll(other.routeHints_);
            }
            onChanged();
          }
        } else {
          if (!other.routeHints_.isEmpty()) {
            if (routeHintsBuilder_.isEmpty()) {
              routeHintsBuilder_.dispose();
              routeHintsBuilder_ = null;
              routeHints_ = other.routeHints_;
              bitField0_ = (bitField0_ & ~0x00000004);
              routeHintsBuilder_ = 
                com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
                   getRouteHintsFieldBuilder() : null;
            } else {
              routeHintsBuilder_.addAllMessages(other.routeHints_);
            }
          }
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 8: {
                amt_ = input.readInt64();
                bitField0_ |= 0x00000001;
                break;
              } // case 8
              case 18: {
                lastHop_ = input.readBytes();
                bitField0_ |= 0x00000002;
                break;
              } // case 18
              case 26: {
                looprpc.Common.RouteHint m =
                    input.readMessage(
                        looprpc.Common.RouteHint.parser(),
                        extensionRegistry);
                if (routeHintsBuilder_ == null) {
                  ensureRouteHintsIsMutable();
                  routeHints_.add(m);
                } else {
                  routeHintsBuilder_.addMessage(m);
                }
                break;
              } // case 26
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private long amt_ ;
      /**
       * <pre>
       *
       *The amount to probe.
       * </pre>
       *
       * <code>int64 amt = 1 [jstype = JS_STRING];</code>
       * @return The amt.
       */
      @java.lang.Override
      public long getAmt() {
        return amt_;
      }
      /**
       * <pre>
       *
       *The amount to probe.
       * </pre>
       *
       * <code>int64 amt = 1 [jstype = JS_STRING];</code>
       * @param value The amt to set.
       * @return This builder for chaining.
       */
      public Builder setAmt(long value) {

        amt_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       *
       *The amount to probe.
       * </pre>
       *
       * <code>int64 amt = 1 [jstype = JS_STRING];</code>
       * @return This builder for chaining.
       */
      public Builder clearAmt() {
        bitField0_ = (bitField0_ & ~0x00000001);
        amt_ = 0L;
        onChanged();
        return this;
      }

      private com.google.protobuf.ByteString lastHop_ = com.google.protobuf.ByteString.EMPTY;
      /**
       * <pre>
       *
       *Optional last hop of the route to probe.
       * </pre>
       *
       * <code>bytes last_hop = 2;</code>
       * @return The lastHop.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString getLastHop() {
        return lastHop_;
      }
      /**
       * <pre>
       *
       *Optional last hop of the route to probe.
       * </pre>
       *
       * <code>bytes last_hop = 2;</code>
       * @param value The lastHop to set.
       * @return This builder for chaining.
       */
      public Builder setLastHop(com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        lastHop_ = value;
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       *
       *Optional last hop of the route to probe.
       * </pre>
       *
       * <code>bytes last_hop = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearLastHop() {
        bitField0_ = (bitField0_ & ~0x00000002);
        lastHop_ = getDefaultInstance().getLastHop();
        onChanged();
        return this;
      }

      private java.util.List<looprpc.Common.RouteHint> routeHints_ =
        java.util.Collections.emptyList();
      private void ensureRouteHintsIsMutable() {
        if (!((bitField0_ & 0x00000004) != 0)) {
          routeHints_ = new java.util.ArrayList<looprpc.Common.RouteHint>(routeHints_);
          bitField0_ |= 0x00000004;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
          looprpc.Common.RouteHint, looprpc.Common.RouteHint.Builder, looprpc.Common.RouteHintOrBuilder> routeHintsBuilder_;

      /**
       * <pre>
       *
       *Optional route hints to reach the destination through private channels.
       * </pre>
       *
       * <code>repeated .looprpc.RouteHint route_hints = 3;</code>
       */
      public java.util.List<looprpc.Common.RouteHint> getRouteHintsList() {
        if (routeHintsBuilder_ == null) {
          return java.util.Collections.unmodifiableList(routeHints_);
        } else {
          return routeHintsBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       *
       *Optional route hints to reach the destination through private channels.
       * </pre>
       *
       * <code>repeated .looprpc.RouteHint route_hints = 3;</code>
       */
      public int getRouteHintsCount() {
        if (routeHintsBuilder_ == null) {
          return routeHints_.size();
        } else {
          return routeHintsBuilder_.getCount();
        }
      }
      /**
       * <pre>
       *
       *Optional route hints to reach the destination through private channels.
       * </pre>
       *
       * <code>repeated .looprpc.RouteHint route_hints = 3;</code>
       */
      public looprpc.Common.RouteHint getRouteHints(int index) {
        if (routeHintsBuilder_ == null) {
          return routeHints_.get(index);
        } else {
          return routeHintsBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       *
       *Optional route hints to reach the destination through private channels.
       * </pre>
       *
       * <code>repeated .looprpc.RouteHint route_hints = 3;</code>
       */
      public Builder setRouteHints(
          int index, looprpc.Common.RouteHint value) {
        if (routeHintsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureRouteHintsIsMutable();
          routeHints_.set(index, value);
          onChanged();
        } else {
          routeHintsBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       *
       *Optional route hints to reach the destination through private channels.
       * </pre>
       *
       * <code>repeated .looprpc.RouteHint route_hints = 3;</code>
       */
      public Builder setRouteHints(
          int index, looprpc.Common.RouteHint.Builder builderForValue) {
        if (routeHintsBuilder_ == null) {
          ensureRouteHintsIsMutable();
          routeHints_.set(index, builderForValue.build());
          onChanged();
        } else {
          routeHintsBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       *
       *Optional route hints to reach the destination through private channels.
       * </pre>
       *
       * <code>repeated .looprpc.RouteHint route_hints = 3;</code>
       */
      public Builder addRouteHints(looprpc.Common.RouteHint value) {
        if (routeHintsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureRouteHintsIsMutable();
          routeHints_.add(value);
          onChanged();
        } else {
          routeHintsBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       *
       *Optional route hints to reach the destination through private channels.
       * </pre>
       *
       * <code>repeated .looprpc.RouteHint route_hints = 3;</code>
       */
      public Builder addRouteHints(
          int index, looprpc.Common.RouteHint value) {
        if (routeHintsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureRouteHintsIsMutable();
          routeHints_.add(index, value);
          onChanged();
        } else {
          routeHintsBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       *
       *Optional route hints to reach the destination through private channels.
       * </pre>
       *
       * <code>repeated .looprpc.RouteHint route_hints = 3;</code>
       */
      public Builder addRouteHints(
          looprpc.Common.RouteHint.Builder builderForValue) {
        if (routeHintsBuilder_ == null) {
          ensureRouteHintsIsMutable();
          routeHints_.add(builderForValue.build());
          onChanged();
        } else {
          routeHintsBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       *
       *Optional route hints to reach the destination through private channels.
       * </pre>
       *
       * <code>repeated .looprpc.RouteHint route_hints = 3;</code>
       */
      public Builder addRouteHints(
          int index, looprpc.Common.RouteHint.Builder builderForValue) {
        if (routeHintsBuilder_ == null) {
          ensureRouteHintsIsMutable();
          routeHints_.add(index, builderForValue.build());
          onChanged();
        } else {
          routeHintsBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       *
       *Optional route hints to reach the destination through private channels.
       * </pre>
       *
       * <code>repeated .looprpc.RouteHint route_hints = 3;</code>
       */
      public Builder addAllRouteHints(
          java.lang.Iterable<? extends looprpc.Common.RouteHint> values) {
        if (routeHintsBuilder_ == null) {
          ensureRouteHintsIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, routeHints_);
          onChanged();
        } else {
          routeHintsBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       *
       *Optional route hints to reach the destination through private channels.
       * </pre>
       *
       * <code>repeated .looprpc.RouteHint route_hints = 3;</code>
       */
      public Builder clearRouteHints() {
        if (routeHintsBuilder_ == null) {
          routeHints_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000004);
          onChanged();
        } else {
          routeHintsBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       *
       *Optional route hints to reach the destination through private channels.
       * </pre>
       *
       * <code>repeated .looprpc.RouteHint route_hints = 3;</code>
       */
      public Builder removeRouteHints(int index) {
        if (routeHintsBuilder_ == null) {
          ensureRouteHintsIsMutable();
          routeHints_.remove(index);
          onChanged();
        } else {
          routeHintsBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       *
       *Optional route hints to reach the destination through private channels.
       * </pre>
       *
       * <code>repeated .looprpc.RouteHint route_hints = 3;</code>
       */
      public looprpc.Common.RouteHint.Builder getRouteHintsBuilder(
          int index) {
        return getRouteHintsFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       *
       *Optional route hints to reach the destination through private channels.
       * </pre>
       *
       * <code>repeated .looprpc.RouteHint route_hints = 3;</code>
       */
      public looprpc.Common.RouteHintOrBuilder getRouteHintsOrBuilder(
          int index) {
        if (routeHintsBuilder_ == null) {
          return routeHints_.get(index);  } else {
          return routeHintsBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       *
       *Optional route hints to reach the destination through private channels.
       * </pre>
       *
       * <code>repeated .looprpc.RouteHint route_hints = 3;</code>
       */
      public java.util.List<? extends looprpc.Common.RouteHintOrBuilder> 
           getRouteHintsOrBuilderList() {
        if (routeHintsBuilder_ != null) {
          return routeHintsBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(routeHints_);
        }
      }
      /**
       * <pre>
       *
       *Optional route hints to reach the destination through private channels.
       * </pre>
       *
       * <code>repeated .looprpc.RouteHint route_hints = 3;</code>
       */
      public looprpc.Common.RouteHint.Builder addRouteHintsBuilder() {
        return getRouteHintsFieldBuilder().addBuilder(
            looprpc.Common.RouteHint.getDefaultInstance());
      }
      /**
       * <pre>
       *
       *Optional route hints to reach the destination through private channels.
       * </pre>
       *
       * <code>repeated .looprpc.RouteHint route_hints = 3;</code>
       */
      public looprpc.Common.RouteHint.Builder addRouteHintsBuilder(
          int index) {
        return getRouteHintsFieldBuilder().addBuilder(
            index, looprpc.Common.RouteHint.getDefaultInstance());
      }
      /**
       * <pre>
       *
       *Optional route hints to reach the destination through private channels.
       * </pre>
       *
       * <code>repeated .looprpc.RouteHint route_hints = 3;</code>
       */
      public java.util.List<looprpc.Common.RouteHint.Builder> 
           getRouteHintsBuilderList() {
        return getRouteHintsFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilderV3<
          looprpc.Common.RouteHint, looprpc.Common.RouteHint.Builder, looprpc.Common.RouteHintOrBuilder> 
          getRouteHintsFieldBuilder() {
        if (routeHintsBuilder_ == null) {
          routeHintsBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<
              looprpc.Common.RouteHint, looprpc.Common.RouteHint.Builder, looprpc.Common.RouteHintOrBuilder>(
                  routeHints_,
                  ((bitField0_ & 0x00000004) != 0),
                  getParentForChildren(),
                  isClean());
          routeHints_ = null;
        }
        return routeHintsBuilder_;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:looprpc.ProbeRequest)
    }

    // @@protoc_insertion_point(class_scope:looprpc.ProbeRequest)
    private static final looprpc.Loop.ProbeRequest DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new looprpc.Loop.ProbeRequest();
    }

    public static looprpc.Loop.ProbeRequest getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<ProbeRequest>
        PARSER = new com.google.protobuf.AbstractParser<ProbeRequest>() {
      @java.lang.Override
      public ProbeRequest parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<ProbeRequest> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<ProbeRequest> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public looprpc.Loop.ProbeRequest getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface ProbeResponseOrBuilder extends
      // @@protoc_insertion_point(interface_extends:looprpc.ProbeResponse)
      com.google.protobuf.MessageOrBuilder {
  }
  /**
   * Protobuf type {@code looprpc.ProbeResponse}
   */
  public static final class ProbeResponse extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:looprpc.ProbeResponse)
      ProbeResponseOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use ProbeResponse.newBuilder() to construct.
    private ProbeResponse(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private ProbeResponse() {
    }

    @java.lang.Override
    @SuppressWarnings({"unused"})
    protected java.lang.Object newInstance(
        UnusedPrivateParameter unused) {
      return new ProbeResponse();
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return looprpc.Loop.internal_static_looprpc_ProbeResponse_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return looprpc.Loop.internal_static_looprpc_ProbeResponse_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              looprpc.Loop.ProbeResponse.class, looprpc.Loop.ProbeResponse.Builder.class);
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof looprpc.Loop.ProbeResponse)) {
        return super.equals(obj);
      }
      looprpc.Loop.ProbeResponse other = (looprpc.Loop.ProbeResponse) obj;

      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static looprpc.Loop.ProbeResponse parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static looprpc.Loop.ProbeResponse parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static looprpc.Loop.ProbeResponse parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static looprpc.Loop.ProbeResponse parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static looprpc.Loop.ProbeResponse parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static looprpc.Loop.ProbeResponse parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static looprpc.Loop.ProbeResponse parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static looprpc.Loop.ProbeResponse parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static looprpc.Loop.ProbeResponse parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static looprpc.Loop.ProbeResponse parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static looprpc.Loop.ProbeResponse parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static looprpc.Loop.ProbeResponse parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(looprpc.Loop.ProbeResponse prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * Protobuf type {@code looprpc.ProbeResponse}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:looprpc.ProbeResponse)
        looprpc.Loop.ProbeResponseOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return looprpc.Loop.internal_static_looprpc_ProbeResponse_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return looprpc.Loop.internal_static_looprpc_ProbeResponse_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                looprpc.Loop.ProbeResponse.class, looprpc.Loop.ProbeResponse.Builder.class);
      }

      // Construct using looprpc.Loop.ProbeResponse.newBuilder()
      private Builder() {

      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);

      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return looprpc.Loop.internal_static_looprpc_ProbeResponse_descriptor;
      }

      @java.lang.Override
      public looprpc.Loop.ProbeResponse getDefaultInstanceForType() {
        return looprpc.Loop.ProbeResponse.getDefaultInstance();
      }

      @java.lang.Override
      public looprpc.Loop.ProbeResponse build() {
        looprpc.Loop.ProbeResponse result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public looprpc.Loop.ProbeResponse buildPartial() {
        looprpc.Loop.ProbeResponse result = new looprpc.Loop.ProbeResponse(this);
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof looprpc.Loop.ProbeResponse) {
          return mergeFrom((looprpc.Loop.ProbeResponse)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(looprpc.Loop.ProbeResponse other) {
        if (other == looprpc.Loop.ProbeResponse.getDefaultInstance()) return this;
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:looprpc.ProbeResponse)
    }

    // @@protoc_insertion_point(class_scope:looprpc.ProbeResponse)
    private static final looprpc.Loop.ProbeResponse DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new looprpc.Loop.ProbeResponse();
    }

    public static looprpc.Loop.ProbeResponse getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<ProbeResponse>
        PARSER = new com.google.protobuf.AbstractParser<ProbeResponse>() {
      @java.lang.Override
      public ProbeResponse parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<ProbeResponse> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<ProbeResponse> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public looprpc.Loop.ProbeResponse getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface TokensRequestOrBuilder extends
      // @@protoc_insertion_point(interface_extends:looprpc.TokensRequest)
      com.google.protobuf.MessageOrBuilder {
  }
  /**
   * Protobuf type {@code looprpc.TokensRequest}
   */
  public static final class TokensRequest extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:looprpc.TokensRequest)
      TokensRequestOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use TokensRequest.newBuilder() to construct.
    private TokensRequest(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private TokensRequest() {
    }

    @java.lang.Override
    @SuppressWarnings({"unused"})
    protected java.lang.Object newInstance(
        UnusedPrivateParameter unused) {
      return new TokensRequest();
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return looprpc.Loop.internal_static_looprpc_TokensRequest_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return looprpc.Loop.internal_static_looprpc_TokensRequest_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              looprpc.Loop.TokensRequest.class, looprpc.Loop.TokensRequest.Builder.class);
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof looprpc.Loop.TokensRequest)) {
        return super.equals(obj);
      }
      looprpc.Loop.TokensRequest other = (looprpc.Loop.TokensRequest) obj;

      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static looprpc.Loop.TokensRequest parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static looprpc.Loop.TokensRequest parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static looprpc.Loop.TokensRequest parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static looprpc.Loop.TokensRequest parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static looprpc.Loop.TokensRequest parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static looprpc.Loop.TokensRequest parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static looprpc.Loop.TokensRequest parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static looprpc.Loop.TokensRequest parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static looprpc.Loop.TokensRequest parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static looprpc.Loop.TokensRequest parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static looprpc.Loop.TokensRequest parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static looprpc.Loop.TokensRequest parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(looprpc.Loop.TokensRequest prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * Protobuf type {@code looprpc.TokensRequest}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:looprpc.TokensRequest)
        looprpc.Loop.TokensRequestOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return looprpc.Loop.internal_static_looprpc_TokensRequest_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return looprpc.Loop.internal_static_looprpc_TokensRequest_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                looprpc.Loop.TokensRequest.class, looprpc.Loop.TokensRequest.Builder.class);
      }

      // Construct using looprpc.Loop.TokensRequest.newBuilder()
      private Builder() {

      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);

      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return looprpc.Loop.internal_static_looprpc_TokensRequest_descriptor;
      }

      @java.lang.Override
      public looprpc.Loop.TokensRequest getDefaultInstanceForType() {
        return looprpc.Loop.TokensRequest.getDefaultInstance();
      }

      @java.lang.Override
      public looprpc.Loop.TokensRequest build() {
        looprpc.Loop.TokensRequest result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public looprpc.Loop.TokensRequest buildPartial() {
        looprpc.Loop.TokensRequest result = new looprpc.Loop.TokensRequest(this);
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof looprpc.Loop.TokensRequest) {
          return mergeFrom((looprpc.Loop.TokensRequest)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(looprpc.Loop.TokensRequest other) {
        if (other == looprpc.Loop.TokensRequest.getDefaultInstance()) return this;
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:looprpc.TokensRequest)
    }

    // @@protoc_insertion_point(class_scope:looprpc.TokensRequest)
    private static final looprpc.Loop.TokensRequest DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new looprpc.Loop.TokensRequest();
    }

    public static looprpc.Loop.TokensRequest getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<TokensRequest>
        PARSER = new com.google.protobuf.AbstractParser<TokensRequest>() {
      @java.lang.Override
      public TokensRequest parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<TokensRequest> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<TokensRequest> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public looprpc.Loop.TokensRequest getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface TokensResponseOrBuilder extends
      // @@protoc_insertion_point(interface_extends:looprpc.TokensResponse)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     *
     *List of all tokens the daemon knows of, including old/expired tokens.
     * </pre>
     *
     * <code>repeated .looprpc.LsatToken tokens = 1;</code>
     */
    java.util.List<looprpc.Loop.LsatToken> 
        getTokensList();
    /**
     * <pre>
     *
     *List of all tokens the daemon knows of, including old/expired tokens.
     * </pre>
     *
     * <code>repeated .looprpc.LsatToken tokens = 1;</code>
     */
    looprpc.Loop.LsatToken getTokens(int index);
    /**
     * <pre>
     *
     *List of all tokens the daemon knows of, including old/expired tokens.
     * </pre>
     *
     * <code>repeated .looprpc.LsatToken tokens = 1;</code>
     */
    int getTokensCount();
    /**
     * <pre>
     *
     *List of all tokens the daemon knows of, including old/expired tokens.
     * </pre>
     *
     * <code>repeated .looprpc.LsatToken tokens = 1;</code>
     */
    java.util.List<? extends looprpc.Loop.LsatTokenOrBuilder> 
        getTokensOrBuilderList();
    /**
     * <pre>
     *
     *List of all tokens the daemon knows of, including old/expired tokens.
     * </pre>
     *
     * <code>repeated .looprpc.LsatToken tokens = 1;</code>
     */
    looprpc.Loop.LsatTokenOrBuilder getTokensOrBuilder(
        int index);
  }
  /**
   * Protobuf type {@code looprpc.TokensResponse}
   */
  public static final class TokensResponse extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:looprpc.TokensResponse)
      TokensResponseOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use TokensResponse.newBuilder() to construct.
    private TokensResponse(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private TokensResponse() {
      tokens_ = java.util.Collections.emptyList();
    }

    @java.lang.Override
    @SuppressWarnings({"unused"})
    protected java.lang.Object newInstance(
        UnusedPrivateParameter unused) {
      return new TokensResponse();
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return looprpc.Loop.internal_static_looprpc_TokensResponse_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return looprpc.Loop.internal_static_looprpc_TokensResponse_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              looprpc.Loop.TokensResponse.class, looprpc.Loop.TokensResponse.Builder.class);
    }

    public static final int TOKENS_FIELD_NUMBER = 1;
    @SuppressWarnings("serial")
    private java.util.List<looprpc.Loop.LsatToken> tokens_;
    /**
     * <pre>
     *
     *List of all tokens the daemon knows of, including old/expired tokens.
     * </pre>
     *
     * <code>repeated .looprpc.LsatToken tokens = 1;</code>
     */
    @java.lang.Override
    public java.util.List<looprpc.Loop.LsatToken> getTokensList() {
      return tokens_;
    }
    /**
     * <pre>
     *
     *List of all tokens the daemon knows of, including old/expired tokens.
     * </pre>
     *
     * <code>repeated .looprpc.LsatToken tokens = 1;</code>
     */
    @java.lang.Override
    public java.util.List<? extends looprpc.Loop.LsatTokenOrBuilder> 
        getTokensOrBuilderList() {
      return tokens_;
    }
    /**
     * <pre>
     *
     *List of all tokens the daemon knows of, including old/expired tokens.
     * </pre>
     *
     * <code>repeated .looprpc.LsatToken tokens = 1;</code>
     */
    @java.lang.Override
    public int getTokensCount() {
      return tokens_.size();
    }
    /**
     * <pre>
     *
     *List of all tokens the daemon knows of, including old/expired tokens.
     * </pre>
     *
     * <code>repeated .looprpc.LsatToken tokens = 1;</code>
     */
    @java.lang.Override
    public looprpc.Loop.LsatToken getTokens(int index) {
      return tokens_.get(index);
    }
    /**
     * <pre>
     *
     *List of all tokens the daemon knows of, including old/expired tokens.
     * </pre>
     *
     * <code>repeated .looprpc.LsatToken tokens = 1;</code>
     */
    @java.lang.Override
    public looprpc.Loop.LsatTokenOrBuilder getTokensOrBuilder(
        int index) {
      return tokens_.get(index);
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      for (int i = 0; i < tokens_.size(); i++) {
        output.writeMessage(1, tokens_.get(i));
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      for (int i = 0; i < tokens_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(1, tokens_.get(i));
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof looprpc.Loop.TokensResponse)) {
        return super.equals(obj);
      }
      looprpc.Loop.TokensResponse other = (looprpc.Loop.TokensResponse) obj;

      if (!getTokensList()
          .equals(other.getTokensList())) return false;
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (getTokensCount() > 0) {
        hash = (37 * hash) + TOKENS_FIELD_NUMBER;
        hash = (53 * hash) + getTokensList().hashCode();
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static looprpc.Loop.TokensResponse parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static looprpc.Loop.TokensResponse parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static looprpc.Loop.TokensResponse parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static looprpc.Loop.TokensResponse parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static looprpc.Loop.TokensResponse parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static looprpc.Loop.TokensResponse parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static looprpc.Loop.TokensResponse parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static looprpc.Loop.TokensResponse parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static looprpc.Loop.TokensResponse parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static looprpc.Loop.TokensResponse parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static looprpc.Loop.TokensResponse parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static looprpc.Loop.TokensResponse parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(looprpc.Loop.TokensResponse prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * Protobuf type {@code looprpc.TokensResponse}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:looprpc.TokensResponse)
        looprpc.Loop.TokensResponseOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return looprpc.Loop.internal_static_looprpc_TokensResponse_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return looprpc.Loop.internal_static_looprpc_TokensResponse_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                looprpc.Loop.TokensResponse.class, looprpc.Loop.TokensResponse.Builder.class);
      }

      // Construct using looprpc.Loop.TokensResponse.newBuilder()
      private Builder() {

      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);

      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        if (tokensBuilder_ == null) {
          tokens_ = java.util.Collections.emptyList();
        } else {
          tokens_ = null;
          tokensBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000001);
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return looprpc.Loop.internal_static_looprpc_TokensResponse_descriptor;
      }

      @java.lang.Override
      public looprpc.Loop.TokensResponse getDefaultInstanceForType() {
        return looprpc.Loop.TokensResponse.getDefaultInstance();
      }

      @java.lang.Override
      public looprpc.Loop.TokensResponse build() {
        looprpc.Loop.TokensResponse result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public looprpc.Loop.TokensResponse buildPartial() {
        looprpc.Loop.TokensResponse result = new looprpc.Loop.TokensResponse(this);
        buildPartialRepeatedFields(result);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartialRepeatedFields(looprpc.Loop.TokensResponse result) {
        if (tokensBuilder_ == null) {
          if (((bitField0_ & 0x00000001) != 0)) {
            tokens_ = java.util.Collections.unmodifiableList(tokens_);
            bitField0_ = (bitField0_ & ~0x00000001);
          }
          result.tokens_ = tokens_;
        } else {
          result.tokens_ = tokensBuilder_.build();
        }
      }

      private void buildPartial0(looprpc.Loop.TokensResponse result) {
        int from_bitField0_ = bitField0_;
      }

      @java.lang.Override
      public Builder clone() {
        return super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof looprpc.Loop.TokensResponse) {
          return mergeFrom((looprpc.Loop.TokensResponse)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(looprpc.Loop.TokensResponse other) {
        if (other == looprpc.Loop.TokensResponse.getDefaultInstance()) return this;
        if (tokensBuilder_ == null) {
          if (!other.tokens_.isEmpty()) {
            if (tokens_.isEmpty()) {
              tokens_ = other.tokens_;
              bitField0_ = (bitField0_ & ~0x00000001);
            } else {
              ensureTokensIsMutable();
              tokens_.addAll(other.tokens_);
            }
            onChanged();
          }
        } else {
          if (!other.tokens_.isEmpty()) {
            if (tokensBuilder_.isEmpty()) {
              tokensBuilder_.dispose();
              tokensBuilder_ = null;
              tokens_ = other.tokens_;
              bitField0_ = (bitField0_ & ~0x00000001);
              tokensBuilder_ = 
                com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
                   getTokensFieldBuilder() : null;
            } else {
              tokensBuilder_.addAllMessages(other.tokens_);
            }
          }
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10: {
                looprpc.Loop.LsatToken m =
                    input.readMessage(
                        looprpc.Loop.LsatToken.parser(),
                        extensionRegistry);
                if (tokensBuilder_ == null) {
                  ensureTokensIsMutable();
                  tokens_.add(m);
                } else {
                  tokensBuilder_.addMessage(m);
                }
                break;
              } // case 10
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private java.util.List<looprpc.Loop.LsatToken> tokens_ =
        java.util.Collections.emptyList();
      private void ensureTokensIsMutable() {
        if (!((bitField0_ & 0x00000001) != 0)) {
          tokens_ = new java.util.ArrayList<looprpc.Loop.LsatToken>(tokens_);
          bitField0_ |= 0x00000001;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
          looprpc.Loop.LsatToken, looprpc.Loop.LsatToken.Builder, looprpc.Loop.LsatTokenOrBuilder> tokensBuilder_;

      /**
       * <pre>
       *
       *List of all tokens the daemon knows of, including old/expired tokens.
       * </pre>
       *
       * <code>repeated .looprpc.LsatToken tokens = 1;</code>
       */
      public java.util.List<looprpc.Loop.LsatToken> getTokensList() {
        if (tokensBuilder_ == null) {
          return java.util.Collections.unmodifiableList(tokens_);
        } else {
          return tokensBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       *
       *List of all tokens the daemon knows of, including old/expired tokens.
       * </pre>
       *
       * <code>repeated .looprpc.LsatToken tokens = 1;</code>
       */
      public int getTokensCount() {
        if (tokensBuilder_ == null) {
          return tokens_.size();
        } else {
          return tokensBuilder_.getCount();
        }
      }
      /**
       * <pre>
       *
       *List of all tokens the daemon knows of, including old/expired tokens.
       * </pre>
       *
       * <code>repeated .looprpc.LsatToken tokens = 1;</code>
       */
      public looprpc.Loop.LsatToken getTokens(int index) {
        if (tokensBuilder_ == null) {
          return tokens_.get(index);
        } else {
          return tokensBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       *
       *List of all tokens the daemon knows of, including old/expired tokens.
       * </pre>
       *
       * <code>repeated .looprpc.LsatToken tokens = 1;</code>
       */
      public Builder setTokens(
          int index, looprpc.Loop.LsatToken value) {
        if (tokensBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureTokensIsMutable();
          tokens_.set(index, value);
          onChanged();
        } else {
          tokensBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       *
       *List of all tokens the daemon knows of, including old/expired tokens.
       * </pre>
       *
       * <code>repeated .looprpc.LsatToken tokens = 1;</code>
       */
      public Builder setTokens(
          int index, looprpc.Loop.LsatToken.Builder builderForValue) {
        if (tokensBuilder_ == null) {
          ensureTokensIsMutable();
          tokens_.set(index, builderForValue.build());
          onChanged();
        } else {
          tokensBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       *
       *List of all tokens the daemon knows of, including old/expired tokens.
       * </pre>
       *
       * <code>repeated .looprpc.LsatToken tokens = 1;</code>
       */
      public Builder addTokens(looprpc.Loop.LsatToken value) {
        if (tokensBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureTokensIsMutable();
          tokens_.add(value);
          onChanged();
        } else {
          tokensBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       *
       *List of all tokens the daemon knows of, including old/expired tokens.
       * </pre>
       *
       * <code>repeated .looprpc.LsatToken tokens = 1;</code>
       */
      public Builder addTokens(
          int index, looprpc.Loop.LsatToken value) {
        if (tokensBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureTokensIsMutable();
          tokens_.add(index, value);
          onChanged();
        } else {
          tokensBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       *
       *List of all tokens the daemon knows of, including old/expired tokens.
       * </pre>
       *
       * <code>repeated .looprpc.LsatToken tokens = 1;</code>
       */
      public Builder addTokens(
          looprpc.Loop.LsatToken.Builder builderForValue) {
        if (tokensBuilder_ == null) {
          ensureTokensIsMutable();
          tokens_.add(builderForValue.build());
          onChanged();
        } else {
          tokensBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       *
       *List of all tokens the daemon knows of, including old/expired tokens.
       * </pre>
       *
       * <code>repeated .looprpc.LsatToken tokens = 1;</code>
       */
      public Builder addTokens(
          int index, looprpc.Loop.LsatToken.Builder builderForValue) {
        if (tokensBuilder_ == null) {
          ensureTokensIsMutable();
          tokens_.add(index, builderForValue.build());
          onChanged();
        } else {
          tokensBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       *
       *List of all tokens the daemon knows of, including old/expired tokens.
       * </pre>
       *
       * <code>repeated .looprpc.LsatToken tokens = 1;</code>
       */
      public Builder addAllTokens(
          java.lang.Iterable<? extends looprpc.Loop.LsatToken> values) {
        if (tokensBuilder_ == null) {
          ensureTokensIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, tokens_);
          onChanged();
        } else {
          tokensBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       *
       *List of all tokens the daemon knows of, including old/expired tokens.
       * </pre>
       *
       * <code>repeated .looprpc.LsatToken tokens = 1;</code>
       */
      public Builder clearTokens() {
        if (tokensBuilder_ == null) {
          tokens_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000001);
          onChanged();
        } else {
          tokensBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       *
       *List of all tokens the daemon knows of, including old/expired tokens.
       * </pre>
       *
       * <code>repeated .looprpc.LsatToken tokens = 1;</code>
       */
      public Builder removeTokens(int index) {
        if (tokensBuilder_ == null) {
          ensureTokensIsMutable();
          tokens_.remove(index);
          onChanged();
        } else {
          tokensBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       *
       *List of all tokens the daemon knows of, including old/expired tokens.
       * </pre>
       *
       * <code>repeated .looprpc.LsatToken tokens = 1;</code>
       */
      public looprpc.Loop.LsatToken.Builder getTokensBuilder(
          int index) {
        return getTokensFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       *
       *List of all tokens the daemon knows of, including old/expired tokens.
       * </pre>
       *
       * <code>repeated .looprpc.LsatToken tokens = 1;</code>
       */
      public looprpc.Loop.LsatTokenOrBuilder getTokensOrBuilder(
          int index) {
        if (tokensBuilder_ == null) {
          return tokens_.get(index);  } else {
          return tokensBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       *
       *List of all tokens the daemon knows of, including old/expired tokens.
       * </pre>
       *
       * <code>repeated .looprpc.LsatToken tokens = 1;</code>
       */
      public java.util.List<? extends looprpc.Loop.LsatTokenOrBuilder> 
           getTokensOrBuilderList() {
        if (tokensBuilder_ != null) {
          return tokensBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(tokens_);
        }
      }
      /**
       * <pre>
       *
       *List of all tokens the daemon knows of, including old/expired tokens.
       * </pre>
       *
       * <code>repeated .looprpc.LsatToken tokens = 1;</code>
       */
      public looprpc.Loop.LsatToken.Builder addTokensBuilder() {
        return getTokensFieldBuilder().addBuilder(
            looprpc.Loop.LsatToken.getDefaultInstance());
      }
      /**
       * <pre>
       *
       *List of all tokens the daemon knows of, including old/expired tokens.
       * </pre>
       *
       * <code>repeated .looprpc.LsatToken tokens = 1;</code>
       */
      public looprpc.Loop.LsatToken.Builder addTokensBuilder(
          int index) {
        return getTokensFieldBuilder().addBuilder(
            index, looprpc.Loop.LsatToken.getDefaultInstance());
      }
      /**
       * <pre>
       *
       *List of all tokens the daemon knows of, including old/expired tokens.
       * </pre>
       *
       * <code>repeated .looprpc.LsatToken tokens = 1;</code>
       */
      public java.util.List<looprpc.Loop.LsatToken.Builder> 
           getTokensBuilderList() {
        return getTokensFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilderV3<
          looprpc.Loop.LsatToken, looprpc.Loop.LsatToken.Builder, looprpc.Loop.LsatTokenOrBuilder> 
          getTokensFieldBuilder() {
        if (tokensBuilder_ == null) {
          tokensBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<
              looprpc.Loop.LsatToken, looprpc.Loop.LsatToken.Builder, looprpc.Loop.LsatTokenOrBuilder>(
                  tokens_,
                  ((bitField0_ & 0x00000001) != 0),
                  getParentForChildren(),
                  isClean());
          tokens_ = null;
        }
        return tokensBuilder_;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:looprpc.TokensResponse)
    }

    // @@protoc_insertion_point(class_scope:looprpc.TokensResponse)
    private static final looprpc.Loop.TokensResponse DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new looprpc.Loop.TokensResponse();
    }

    public static looprpc.Loop.TokensResponse getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<TokensResponse>
        PARSER = new com.google.protobuf.AbstractParser<TokensResponse>() {
      @java.lang.Override
      public TokensResponse parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<TokensResponse> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<TokensResponse> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public looprpc.Loop.TokensResponse getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface LsatTokenOrBuilder extends
      // @@protoc_insertion_point(interface_extends:looprpc.LsatToken)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     *
     *The base macaroon that was baked by the auth server.
     * </pre>
     *
     * <code>bytes base_macaroon = 1;</code>
     * @return The baseMacaroon.
     */
    com.google.protobuf.ByteString getBaseMacaroon();

    /**
     * <pre>
     *
     *The payment hash of the payment that was paid to obtain the token.
     * </pre>
     *
     * <code>bytes payment_hash = 2;</code>
     * @return The paymentHash.
     */
    com.google.protobuf.ByteString getPaymentHash();

    /**
     * <pre>
     *
     *The preimage of the payment hash, knowledge of this is proof that the
     *payment has been paid. If the preimage is set to all zeros, this means the
     *payment is still pending and the token is not yet fully valid.
     * </pre>
     *
     * <code>bytes payment_preimage = 3;</code>
     * @return The paymentPreimage.
     */
    com.google.protobuf.ByteString getPaymentPreimage();

    /**
     * <pre>
     *
     *The amount of millisatoshis that was paid to get the token.
     * </pre>
     *
     * <code>int64 amount_paid_msat = 4 [jstype = JS_STRING];</code>
     * @return The amountPaidMsat.
     */
    long getAmountPaidMsat();

    /**
     * <pre>
     *
     *The amount of millisatoshis paid in routing fee to pay for the token.
     * </pre>
     *
     * <code>int64 routing_fee_paid_msat = 5 [jstype = JS_STRING];</code>
     * @return The routingFeePaidMsat.
     */
    long getRoutingFeePaidMsat();

    /**
     * <pre>
     *
     *The creation time of the token as UNIX timestamp in seconds.
     * </pre>
     *
     * <code>int64 time_created = 6 [jstype = JS_STRING];</code>
     * @return The timeCreated.
     */
    long getTimeCreated();

    /**
     * <pre>
     *
     *Indicates whether the token is expired or still valid.
     * </pre>
     *
     * <code>bool expired = 7;</code>
     * @return The expired.
     */
    boolean getExpired();

    /**
     * <pre>
     *
     *Identifying attribute of this token in the store. Currently represents the
     *file name of the token where it's stored on the file system.
     * </pre>
     *
     * <code>string storage_name = 8;</code>
     * @return The storageName.
     */
    java.lang.String getStorageName();
    /**
     * <pre>
     *
     *Identifying attribute of this token in the store. Currently represents the
     *file name of the token where it's stored on the file system.
     * </pre>
     *
     * <code>string storage_name = 8;</code>
     * @return The bytes for storageName.
     */
    com.google.protobuf.ByteString
        getStorageNameBytes();

    /**
     * <pre>
     *
     *The l402 ID of the token.
     * </pre>
     *
     * <code>string id = 9;</code>
     * @return The id.
     */
    java.lang.String getId();
    /**
     * <pre>
     *
     *The l402 ID of the token.
     * </pre>
     *
     * <code>string id = 9;</code>
     * @return The bytes for id.
     */
    com.google.protobuf.ByteString
        getIdBytes();
  }
  /**
   * Protobuf type {@code looprpc.LsatToken}
   */
  public static final class LsatToken extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:looprpc.LsatToken)
      LsatTokenOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use LsatToken.newBuilder() to construct.
    private LsatToken(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private LsatToken() {
      baseMacaroon_ = com.google.protobuf.ByteString.EMPTY;
      paymentHash_ = com.google.protobuf.ByteString.EMPTY;
      paymentPreimage_ = com.google.protobuf.ByteString.EMPTY;
      storageName_ = "";
      id_ = "";
    }

    @java.lang.Override
    @SuppressWarnings({"unused"})
    protected java.lang.Object newInstance(
        UnusedPrivateParameter unused) {
      return new LsatToken();
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return looprpc.Loop.internal_static_looprpc_LsatToken_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return looprpc.Loop.internal_static_looprpc_LsatToken_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              looprpc.Loop.LsatToken.class, looprpc.Loop.LsatToken.Builder.class);
    }

    public static final int BASE_MACAROON_FIELD_NUMBER = 1;
    private com.google.protobuf.ByteString baseMacaroon_ = com.google.protobuf.ByteString.EMPTY;
    /**
     * <pre>
     *
     *The base macaroon that was baked by the auth server.
     * </pre>
     *
     * <code>bytes base_macaroon = 1;</code>
     * @return The baseMacaroon.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString getBaseMacaroon() {
      return baseMacaroon_;
    }

    public static final int PAYMENT_HASH_FIELD_NUMBER = 2;
    private com.google.protobuf.ByteString paymentHash_ = com.google.protobuf.ByteString.EMPTY;
    /**
     * <pre>
     *
     *The payment hash of the payment that was paid to obtain the token.
     * </pre>
     *
     * <code>bytes payment_hash = 2;</code>
     * @return The paymentHash.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString getPaymentHash() {
      return paymentHash_;
    }

    public static final int PAYMENT_PREIMAGE_FIELD_NUMBER = 3;
    private com.google.protobuf.ByteString paymentPreimage_ = com.google.protobuf.ByteString.EMPTY;
    /**
     * <pre>
     *
     *The preimage of the payment hash, knowledge of this is proof that the
     *payment has been paid. If the preimage is set to all zeros, this means the
     *payment is still pending and the token is not yet fully valid.
     * </pre>
     *
     * <code>bytes payment_preimage = 3;</code>
     * @return The paymentPreimage.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString getPaymentPreimage() {
      return paymentPreimage_;
    }

    public static final int AMOUNT_PAID_MSAT_FIELD_NUMBER = 4;
    private long amountPaidMsat_ = 0L;
    /**
     * <pre>
     *
     *The amount of millisatoshis that was paid to get the token.
     * </pre>
     *
     * <code>int64 amount_paid_msat = 4 [jstype = JS_STRING];</code>
     * @return The amountPaidMsat.
     */
    @java.lang.Override
    public long getAmountPaidMsat() {
      return amountPaidMsat_;
    }

    public static final int ROUTING_FEE_PAID_MSAT_FIELD_NUMBER = 5;
    private long routingFeePaidMsat_ = 0L;
    /**
     * <pre>
     *
     *The amount of millisatoshis paid in routing fee to pay for the token.
     * </pre>
     *
     * <code>int64 routing_fee_paid_msat = 5 [jstype = JS_STRING];</code>
     * @return The routingFeePaidMsat.
     */
    @java.lang.Override
    public long getRoutingFeePaidMsat() {
      return routingFeePaidMsat_;
    }

    public static final int TIME_CREATED_FIELD_NUMBER = 6;
    private long timeCreated_ = 0L;
    /**
     * <pre>
     *
     *The creation time of the token as UNIX timestamp in seconds.
     * </pre>
     *
     * <code>int64 time_created = 6 [jstype = JS_STRING];</code>
     * @return The timeCreated.
     */
    @java.lang.Override
    public long getTimeCreated() {
      return timeCreated_;
    }

    public static final int EXPIRED_FIELD_NUMBER = 7;
    private boolean expired_ = false;
    /**
     * <pre>
     *
     *Indicates whether the token is expired or still valid.
     * </pre>
     *
     * <code>bool expired = 7;</code>
     * @return The expired.
     */
    @java.lang.Override
    public boolean getExpired() {
      return expired_;
    }

    public static final int STORAGE_NAME_FIELD_NUMBER = 8;
    @SuppressWarnings("serial")
    private volatile java.lang.Object storageName_ = "";
    /**
     * <pre>
     *
     *Identifying attribute of this token in the store. Currently represents the
     *file name of the token where it's stored on the file system.
     * </pre>
     *
     * <code>string storage_name = 8;</code>
     * @return The storageName.
     */
    @java.lang.Override
    public java.lang.String getStorageName() {
      java.lang.Object ref = storageName_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        storageName_ = s;
        return s;
      }
    }
    /**
     * <pre>
     *
     *Identifying attribute of this token in the store. Currently represents the
     *file name of the token where it's stored on the file system.
     * </pre>
     *
     * <code>string storage_name = 8;</code>
     * @return The bytes for storageName.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getStorageNameBytes() {
      java.lang.Object ref = storageName_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        storageName_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int ID_FIELD_NUMBER = 9;
    @SuppressWarnings("serial")
    private volatile java.lang.Object id_ = "";
    /**
     * <pre>
     *
     *The l402 ID of the token.
     * </pre>
     *
     * <code>string id = 9;</code>
     * @return The id.
     */
    @java.lang.Override
    public java.lang.String getId() {
      java.lang.Object ref = id_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        id_ = s;
        return s;
      }
    }
    /**
     * <pre>
     *
     *The l402 ID of the token.
     * </pre>
     *
     * <code>string id = 9;</code>
     * @return The bytes for id.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getIdBytes() {
      java.lang.Object ref = id_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        id_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (!baseMacaroon_.isEmpty()) {
        output.writeBytes(1, baseMacaroon_);
      }
      if (!paymentHash_.isEmpty()) {
        output.writeBytes(2, paymentHash_);
      }
      if (!paymentPreimage_.isEmpty()) {
        output.writeBytes(3, paymentPreimage_);
      }
      if (amountPaidMsat_ != 0L) {
        output.writeInt64(4, amountPaidMsat_);
      }
      if (routingFeePaidMsat_ != 0L) {
        output.writeInt64(5, routingFeePaidMsat_);
      }
      if (timeCreated_ != 0L) {
        output.writeInt64(6, timeCreated_);
      }
      if (expired_ != false) {
        output.writeBool(7, expired_);
      }
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(storageName_)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 8, storageName_);
      }
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(id_)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 9, id_);
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (!baseMacaroon_.isEmpty()) {
        size += com.google.protobuf.CodedOutputStream
          .computeBytesSize(1, baseMacaroon_);
      }
      if (!paymentHash_.isEmpty()) {
        size += com.google.protobuf.CodedOutputStream
          .computeBytesSize(2, paymentHash_);
      }
      if (!paymentPreimage_.isEmpty()) {
        size += com.google.protobuf.CodedOutputStream
          .computeBytesSize(3, paymentPreimage_);
      }
      if (amountPaidMsat_ != 0L) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt64Size(4, amountPaidMsat_);
      }
      if (routingFeePaidMsat_ != 0L) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt64Size(5, routingFeePaidMsat_);
      }
      if (timeCreated_ != 0L) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt64Size(6, timeCreated_);
      }
      if (expired_ != false) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(7, expired_);
      }
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(storageName_)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(8, storageName_);
      }
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(id_)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(9, id_);
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof looprpc.Loop.LsatToken)) {
        return super.equals(obj);
      }
      looprpc.Loop.LsatToken other = (looprpc.Loop.LsatToken) obj;

      if (!getBaseMacaroon()
          .equals(other.getBaseMacaroon())) return false;
      if (!getPaymentHash()
          .equals(other.getPaymentHash())) return false;
      if (!getPaymentPreimage()
          .equals(other.getPaymentPreimage())) return false;
      if (getAmountPaidMsat()
          != other.getAmountPaidMsat()) return false;
      if (getRoutingFeePaidMsat()
          != other.getRoutingFeePaidMsat()) return false;
      if (getTimeCreated()
          != other.getTimeCreated()) return false;
      if (getExpired()
          != other.getExpired()) return false;
      if (!getStorageName()
          .equals(other.getStorageName())) return false;
      if (!getId()
          .equals(other.getId())) return false;
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      hash = (37 * hash) + BASE_MACAROON_FIELD_NUMBER;
      hash = (53 * hash) + getBaseMacaroon().hashCode();
      hash = (37 * hash) + PAYMENT_HASH_FIELD_NUMBER;
      hash = (53 * hash) + getPaymentHash().hashCode();
      hash = (37 * hash) + PAYMENT_PREIMAGE_FIELD_NUMBER;
      hash = (53 * hash) + getPaymentPreimage().hashCode();
      hash = (37 * hash) + AMOUNT_PAID_MSAT_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
          getAmountPaidMsat());
      hash = (37 * hash) + ROUTING_FEE_PAID_MSAT_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
          getRoutingFeePaidMsat());
      hash = (37 * hash) + TIME_CREATED_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
          getTimeCreated());
      hash = (37 * hash) + EXPIRED_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
          getExpired());
      hash = (37 * hash) + STORAGE_NAME_FIELD_NUMBER;
      hash = (53 * hash) + getStorageName().hashCode();
      hash = (37 * hash) + ID_FIELD_NUMBER;
      hash = (53 * hash) + getId().hashCode();
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static looprpc.Loop.LsatToken parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static looprpc.Loop.LsatToken parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static looprpc.Loop.LsatToken parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static looprpc.Loop.LsatToken parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static looprpc.Loop.LsatToken parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static looprpc.Loop.LsatToken parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static looprpc.Loop.LsatToken parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static looprpc.Loop.LsatToken parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static looprpc.Loop.LsatToken parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static looprpc.Loop.LsatToken parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static looprpc.Loop.LsatToken parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static looprpc.Loop.LsatToken parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(looprpc.Loop.LsatToken prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * Protobuf type {@code looprpc.LsatToken}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:looprpc.LsatToken)
        looprpc.Loop.LsatTokenOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return looprpc.Loop.internal_static_looprpc_LsatToken_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return looprpc.Loop.internal_static_looprpc_LsatToken_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                looprpc.Loop.LsatToken.class, looprpc.Loop.LsatToken.Builder.class);
      }

      // Construct using looprpc.Loop.LsatToken.newBuilder()
      private Builder() {

      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);

      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        baseMacaroon_ = com.google.protobuf.ByteString.EMPTY;
        paymentHash_ = com.google.protobuf.ByteString.EMPTY;
        paymentPreimage_ = com.google.protobuf.ByteString.EMPTY;
        amountPaidMsat_ = 0L;
        routingFeePaidMsat_ = 0L;
        timeCreated_ = 0L;
        expired_ = false;
        storageName_ = "";
        id_ = "";
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return looprpc.Loop.internal_static_looprpc_LsatToken_descriptor;
      }

      @java.lang.Override
      public looprpc.Loop.LsatToken getDefaultInstanceForType() {
        return looprpc.Loop.LsatToken.getDefaultInstance();
      }

      @java.lang.Override
      public looprpc.Loop.LsatToken build() {
        looprpc.Loop.LsatToken result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public looprpc.Loop.LsatToken buildPartial() {
        looprpc.Loop.LsatToken result = new looprpc.Loop.LsatToken(this);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartial0(looprpc.Loop.LsatToken result) {
        int from_bitField0_ = bitField0_;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.baseMacaroon_ = baseMacaroon_;
        }
        if (((from_bitField0_ & 0x00000002) != 0)) {
          result.paymentHash_ = paymentHash_;
        }
        if (((from_bitField0_ & 0x00000004) != 0)) {
          result.paymentPreimage_ = paymentPreimage_;
        }
        if (((from_bitField0_ & 0x00000008) != 0)) {
          result.amountPaidMsat_ = amountPaidMsat_;
        }
        if (((from_bitField0_ & 0x00000010) != 0)) {
          result.routingFeePaidMsat_ = routingFeePaidMsat_;
        }
        if (((from_bitField0_ & 0x00000020) != 0)) {
          result.timeCreated_ = timeCreated_;
        }
        if (((from_bitField0_ & 0x00000040) != 0)) {
          result.expired_ = expired_;
        }
        if (((from_bitField0_ & 0x00000080) != 0)) {
          result.storageName_ = storageName_;
        }
        if (((from_bitField0_ & 0x00000100) != 0)) {
          result.id_ = id_;
        }
      }

      @java.lang.Override
      public Builder clone() {
        return super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof looprpc.Loop.LsatToken) {
          return mergeFrom((looprpc.Loop.LsatToken)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(looprpc.Loop.LsatToken other) {
        if (other == looprpc.Loop.LsatToken.getDefaultInstance()) return this;
        if (other.getBaseMacaroon() != com.google.protobuf.ByteString.EMPTY) {
          setBaseMacaroon(other.getBaseMacaroon());
        }
        if (other.getPaymentHash() != com.google.protobuf.ByteString.EMPTY) {
          setPaymentHash(other.getPaymentHash());
        }
        if (other.getPaymentPreimage() != com.google.protobuf.ByteString.EMPTY) {
          setPaymentPreimage(other.getPaymentPreimage());
        }
        if (other.getAmountPaidMsat() != 0L) {
          setAmountPaidMsat(other.getAmountPaidMsat());
        }
        if (other.getRoutingFeePaidMsat() != 0L) {
          setRoutingFeePaidMsat(other.getRoutingFeePaidMsat());
        }
        if (other.getTimeCreated() != 0L) {
          setTimeCreated(other.getTimeCreated());
        }
        if (other.getExpired() != false) {
          setExpired(other.getExpired());
        }
        if (!other.getStorageName().isEmpty()) {
          storageName_ = other.storageName_;
          bitField0_ |= 0x00000080;
          onChanged();
        }
        if (!other.getId().isEmpty()) {
          id_ = other.id_;
          bitField0_ |= 0x00000100;
          onChanged();
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10: {
                baseMacaroon_ = input.readBytes();
                bitField0_ |= 0x00000001;
                break;
              } // case 10
              case 18: {
                paymentHash_ = input.readBytes();
                bitField0_ |= 0x00000002;
                break;
              } // case 18
              case 26: {
                paymentPreimage_ = input.readBytes();
                bitField0_ |= 0x00000004;
                break;
              } // case 26
              case 32: {
                amountPaidMsat_ = input.readInt64();
                bitField0_ |= 0x00000008;
                break;
              } // case 32
              case 40: {
                routingFeePaidMsat_ = input.readInt64();
                bitField0_ |= 0x00000010;
                break;
              } // case 40
              case 48: {
                timeCreated_ = input.readInt64();
                bitField0_ |= 0x00000020;
                break;
              } // case 48
              case 56: {
                expired_ = input.readBool();
                bitField0_ |= 0x00000040;
                break;
              } // case 56
              case 66: {
                storageName_ = input.readStringRequireUtf8();
                bitField0_ |= 0x00000080;
                break;
              } // case 66
              case 74: {
                id_ = input.readStringRequireUtf8();
                bitField0_ |= 0x00000100;
                break;
              } // case 74
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private com.google.protobuf.ByteString baseMacaroon_ = com.google.protobuf.ByteString.EMPTY;
      /**
       * <pre>
       *
       *The base macaroon that was baked by the auth server.
       * </pre>
       *
       * <code>bytes base_macaroon = 1;</code>
       * @return The baseMacaroon.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString getBaseMacaroon() {
        return baseMacaroon_;
      }
      /**
       * <pre>
       *
       *The base macaroon that was baked by the auth server.
       * </pre>
       *
       * <code>bytes base_macaroon = 1;</code>
       * @param value The baseMacaroon to set.
       * @return This builder for chaining.
       */
      public Builder setBaseMacaroon(com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        baseMacaroon_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       *
       *The base macaroon that was baked by the auth server.
       * </pre>
       *
       * <code>bytes base_macaroon = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearBaseMacaroon() {
        bitField0_ = (bitField0_ & ~0x00000001);
        baseMacaroon_ = getDefaultInstance().getBaseMacaroon();
        onChanged();
        return this;
      }

      private com.google.protobuf.ByteString paymentHash_ = com.google.protobuf.ByteString.EMPTY;
      /**
       * <pre>
       *
       *The payment hash of the payment that was paid to obtain the token.
       * </pre>
       *
       * <code>bytes payment_hash = 2;</code>
       * @return The paymentHash.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString getPaymentHash() {
        return paymentHash_;
      }
      /**
       * <pre>
       *
       *The payment hash of the payment that was paid to obtain the token.
       * </pre>
       *
       * <code>bytes payment_hash = 2;</code>
       * @param value The paymentHash to set.
       * @return This builder for chaining.
       */
      public Builder setPaymentHash(com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        paymentHash_ = value;
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       *
       *The payment hash of the payment that was paid to obtain the token.
       * </pre>
       *
       * <code>bytes payment_hash = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearPaymentHash() {
        bitField0_ = (bitField0_ & ~0x00000002);
        paymentHash_ = getDefaultInstance().getPaymentHash();
        onChanged();
        return this;
      }

      private com.google.protobuf.ByteString paymentPreimage_ = com.google.protobuf.ByteString.EMPTY;
      /**
       * <pre>
       *
       *The preimage of the payment hash, knowledge of this is proof that the
       *payment has been paid. If the preimage is set to all zeros, this means the
       *payment is still pending and the token is not yet fully valid.
       * </pre>
       *
       * <code>bytes payment_preimage = 3;</code>
       * @return The paymentPreimage.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString getPaymentPreimage() {
        return paymentPreimage_;
      }
      /**
       * <pre>
       *
       *The preimage of the payment hash, knowledge of this is proof that the
       *payment has been paid. If the preimage is set to all zeros, this means the
       *payment is still pending and the token is not yet fully valid.
       * </pre>
       *
       * <code>bytes payment_preimage = 3;</code>
       * @param value The paymentPreimage to set.
       * @return This builder for chaining.
       */
      public Builder setPaymentPreimage(com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        paymentPreimage_ = value;
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }
      /**
       * <pre>
       *
       *The preimage of the payment hash, knowledge of this is proof that the
       *payment has been paid. If the preimage is set to all zeros, this means the
       *payment is still pending and the token is not yet fully valid.
       * </pre>
       *
       * <code>bytes payment_preimage = 3;</code>
       * @return This builder for chaining.
       */
      public Builder clearPaymentPreimage() {
        bitField0_ = (bitField0_ & ~0x00000004);
        paymentPreimage_ = getDefaultInstance().getPaymentPreimage();
        onChanged();
        return this;
      }

      private long amountPaidMsat_ ;
      /**
       * <pre>
       *
       *The amount of millisatoshis that was paid to get the token.
       * </pre>
       *
       * <code>int64 amount_paid_msat = 4 [jstype = JS_STRING];</code>
       * @return The amountPaidMsat.
       */
      @java.lang.Override
      public long getAmountPaidMsat() {
        return amountPaidMsat_;
      }
      /**
       * <pre>
       *
       *The amount of millisatoshis that was paid to get the token.
       * </pre>
       *
       * <code>int64 amount_paid_msat = 4 [jstype = JS_STRING];</code>
       * @param value The amountPaidMsat to set.
       * @return This builder for chaining.
       */
      public Builder setAmountPaidMsat(long value) {

        amountPaidMsat_ = value;
        bitField0_ |= 0x00000008;
        onChanged();
        return this;
      }
      /**
       * <pre>
       *
       *The amount of millisatoshis that was paid to get the token.
       * </pre>
       *
       * <code>int64 amount_paid_msat = 4 [jstype = JS_STRING];</code>
       * @return This builder for chaining.
       */
      public Builder clearAmountPaidMsat() {
        bitField0_ = (bitField0_ & ~0x00000008);
        amountPaidMsat_ = 0L;
        onChanged();
        return this;
      }

      private long routingFeePaidMsat_ ;
      /**
       * <pre>
       *
       *The amount of millisatoshis paid in routing fee to pay for the token.
       * </pre>
       *
       * <code>int64 routing_fee_paid_msat = 5 [jstype = JS_STRING];</code>
       * @return The routingFeePaidMsat.
       */
      @java.lang.Override
      public long getRoutingFeePaidMsat() {
        return routingFeePaidMsat_;
      }
      /**
       * <pre>
       *
       *The amount of millisatoshis paid in routing fee to pay for the token.
       * </pre>
       *
       * <code>int64 routing_fee_paid_msat = 5 [jstype = JS_STRING];</code>
       * @param value The routingFeePaidMsat to set.
       * @return This builder for chaining.
       */
      public Builder setRoutingFeePaidMsat(long value) {

        routingFeePaidMsat_ = value;
        bitField0_ |= 0x00000010;
        onChanged();
        return this;
      }
      /**
       * <pre>
       *
       *The amount of millisatoshis paid in routing fee to pay for the token.
       * </pre>
       *
       * <code>int64 routing_fee_paid_msat = 5 [jstype = JS_STRING];</code>
       * @return This builder for chaining.
       */
      public Builder clearRoutingFeePaidMsat() {
        bitField0_ = (bitField0_ & ~0x00000010);
        routingFeePaidMsat_ = 0L;
        onChanged();
        return this;
      }

      private long timeCreated_ ;
      /**
       * <pre>
       *
       *The creation time of the token as UNIX timestamp in seconds.
       * </pre>
       *
       * <code>int64 time_created = 6 [jstype = JS_STRING];</code>
       * @return The timeCreated.
       */
      @java.lang.Override
      public long getTimeCreated() {
        return timeCreated_;
      }
      /**
       * <pre>
       *
       *The creation time of the token as UNIX timestamp in seconds.
       * </pre>
       *
       * <code>int64 time_created = 6 [jstype = JS_STRING];</code>
       * @param value The timeCreated to set.
       * @return This builder for chaining.
       */
      public Builder setTimeCreated(long value) {

        timeCreated_ = value;
        bitField0_ |= 0x00000020;
        onChanged();
        return this;
      }
      /**
       * <pre>
       *
       *The creation time of the token as UNIX timestamp in seconds.
       * </pre>
       *
       * <code>int64 time_created = 6 [jstype = JS_STRING];</code>
       * @return This builder for chaining.
       */
      public Builder clearTimeCreated() {
        bitField0_ = (bitField0_ & ~0x00000020);
        timeCreated_ = 0L;
        onChanged();
        return this;
      }

      private boolean expired_ ;
      /**
       * <pre>
       *
       *Indicates whether the token is expired or still valid.
       * </pre>
       *
       * <code>bool expired = 7;</code>
       * @return The expired.
       */
      @java.lang.Override
      public boolean getExpired() {
        return expired_;
      }
      /**
       * <pre>
       *
       *Indicates whether the token is expired or still valid.
       * </pre>
       *
       * <code>bool expired = 7;</code>
       * @param value The expired to set.
       * @return This builder for chaining.
       */
      public Builder setExpired(boolean value) {

        expired_ = value;
        bitField0_ |= 0x00000040;
        onChanged();
        return this;
      }
      /**
       * <pre>
       *
       *Indicates whether the token is expired or still valid.
       * </pre>
       *
       * <code>bool expired = 7;</code>
       * @return This builder for chaining.
       */
      public Builder clearExpired() {
        bitField0_ = (bitField0_ & ~0x00000040);
        expired_ = false;
        onChanged();
        return this;
      }

      private java.lang.Object storageName_ = "";
      /**
       * <pre>
       *
       *Identifying attribute of this token in the store. Currently represents the
       *file name of the token where it's stored on the file system.
       * </pre>
       *
       * <code>string storage_name = 8;</code>
       * @return The storageName.
       */
      public java.lang.String getStorageName() {
        java.lang.Object ref = storageName_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          storageName_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       *
       *Identifying attribute of this token in the store. Currently represents the
       *file name of the token where it's stored on the file system.
       * </pre>
       *
       * <code>string storage_name = 8;</code>
       * @return The bytes for storageName.
       */
      public com.google.protobuf.ByteString
          getStorageNameBytes() {
        java.lang.Object ref = storageName_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          storageName_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       *
       *Identifying attribute of this token in the store. Currently represents the
       *file name of the token where it's stored on the file system.
       * </pre>
       *
       * <code>string storage_name = 8;</code>
       * @param value The storageName to set.
       * @return This builder for chaining.
       */
      public Builder setStorageName(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        storageName_ = value;
        bitField0_ |= 0x00000080;
        onChanged();
        return this;
      }
      /**
       * <pre>
       *
       *Identifying attribute of this token in the store. Currently represents the
       *file name of the token where it's stored on the file system.
       * </pre>
       *
       * <code>string storage_name = 8;</code>
       * @return This builder for chaining.
       */
      public Builder clearStorageName() {
        storageName_ = getDefaultInstance().getStorageName();
        bitField0_ = (bitField0_ & ~0x00000080);
        onChanged();
        return this;
      }
      /**
       * <pre>
       *
       *Identifying attribute of this token in the store. Currently represents the
       *file name of the token where it's stored on the file system.
       * </pre>
       *
       * <code>string storage_name = 8;</code>
       * @param value The bytes for storageName to set.
       * @return This builder for chaining.
       */
      public Builder setStorageNameBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        checkByteStringIsUtf8(value);
        storageName_ = value;
        bitField0_ |= 0x00000080;
        onChanged();
        return this;
      }

      private java.lang.Object id_ = "";
      /**
       * <pre>
       *
       *The l402 ID of the token.
       * </pre>
       *
       * <code>string id = 9;</code>
       * @return The id.
       */
      public java.lang.String getId() {
        java.lang.Object ref = id_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          id_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       *
       *The l402 ID of the token.
       * </pre>
       *
       * <code>string id = 9;</code>
       * @return The bytes for id.
       */
      public com.google.protobuf.ByteString
          getIdBytes() {
        java.lang.Object ref = id_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          id_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       *
       *The l402 ID of the token.
       * </pre>
       *
       * <code>string id = 9;</code>
       * @param value The id to set.
       * @return This builder for chaining.
       */
      public Builder setId(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        id_ = value;
        bitField0_ |= 0x00000100;
        onChanged();
        return this;
      }
      /**
       * <pre>
       *
       *The l402 ID of the token.
       * </pre>
       *
       * <code>string id = 9;</code>
       * @return This builder for chaining.
       */
      public Builder clearId() {
        id_ = getDefaultInstance().getId();
        bitField0_ = (bitField0_ & ~0x00000100);
        onChanged();
        return this;
      }
      /**
       * <pre>
       *
       *The l402 ID of the token.
       * </pre>
       *
       * <code>string id = 9;</code>
       * @param value The bytes for id to set.
       * @return This builder for chaining.
       */
      public Builder setIdBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        checkByteStringIsUtf8(value);
        id_ = value;
        bitField0_ |= 0x00000100;
        onChanged();
        return this;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:looprpc.LsatToken)
    }

    // @@protoc_insertion_point(class_scope:looprpc.LsatToken)
    private static final looprpc.Loop.LsatToken DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new looprpc.Loop.LsatToken();
    }

    public static looprpc.Loop.LsatToken getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<LsatToken>
        PARSER = new com.google.protobuf.AbstractParser<LsatToken>() {
      @java.lang.Override
      public LsatToken parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<LsatToken> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<LsatToken> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public looprpc.Loop.LsatToken getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface LoopStatsOrBuilder extends
      // @@protoc_insertion_point(interface_extends:looprpc.LoopStats)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     *
     *Number of currently pending swaps.
     * </pre>
     *
     * <code>uint64 pending_count = 1 [jstype = JS_STRING];</code>
     * @return The pendingCount.
     */
    long getPendingCount();

    /**
     * <pre>
     *
     *Number of succeeded swaps.
     * </pre>
     *
     * <code>uint64 success_count = 2 [jstype = JS_STRING];</code>
     * @return The successCount.
     */
    long getSuccessCount();

    /**
     * <pre>
     *
     *Number failed swaps.
     * </pre>
     *
     * <code>uint64 fail_count = 3 [jstype = JS_STRING];</code>
     * @return The failCount.
     */
    long getFailCount();

    /**
     * <pre>
     *
     *The sum of all pending swap amounts.
     * </pre>
     *
     * <code>int64 sum_pending_amt = 4 [jstype = JS_STRING];</code>
     * @return The sumPendingAmt.
     */
    long getSumPendingAmt();

    /**
     * <pre>
     *
     *The sum of all succeeded swap amounts.
     * </pre>
     *
     * <code>int64 sum_succeeded_amt = 5 [jstype = JS_STRING];</code>
     * @return The sumSucceededAmt.
     */
    long getSumSucceededAmt();
  }
  /**
   * Protobuf type {@code looprpc.LoopStats}
   */
  public static final class LoopStats extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:looprpc.LoopStats)
      LoopStatsOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use LoopStats.newBuilder() to construct.
    private LoopStats(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private LoopStats() {
    }

    @java.lang.Override
    @SuppressWarnings({"unused"})
    protected java.lang.Object newInstance(
        UnusedPrivateParameter unused) {
      return new LoopStats();
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return looprpc.Loop.internal_static_looprpc_LoopStats_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return looprpc.Loop.internal_static_looprpc_LoopStats_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              looprpc.Loop.LoopStats.class, looprpc.Loop.LoopStats.Builder.class);
    }

    public static final int PENDING_COUNT_FIELD_NUMBER = 1;
    private long pendingCount_ = 0L;
    /**
     * <pre>
     *
     *Number of currently pending swaps.
     * </pre>
     *
     * <code>uint64 pending_count = 1 [jstype = JS_STRING];</code>
     * @return The pendingCount.
     */
    @java.lang.Override
    public long getPendingCount() {
      return pendingCount_;
    }

    public static final int SUCCESS_COUNT_FIELD_NUMBER = 2;
    private long successCount_ = 0L;
    /**
     * <pre>
     *
     *Number of succeeded swaps.
     * </pre>
     *
     * <code>uint64 success_count = 2 [jstype = JS_STRING];</code>
     * @return The successCount.
     */
    @java.lang.Override
    public long getSuccessCount() {
      return successCount_;
    }

    public static final int FAIL_COUNT_FIELD_NUMBER = 3;
    private long failCount_ = 0L;
    /**
     * <pre>
     *
     *Number failed swaps.
     * </pre>
     *
     * <code>uint64 fail_count = 3 [jstype = JS_STRING];</code>
     * @return The failCount.
     */
    @java.lang.Override
    public long getFailCount() {
      return failCount_;
    }

    public static final int SUM_PENDING_AMT_FIELD_NUMBER = 4;
    private long sumPendingAmt_ = 0L;
    /**
     * <pre>
     *
     *The sum of all pending swap amounts.
     * </pre>
     *
     * <code>int64 sum_pending_amt = 4 [jstype = JS_STRING];</code>
     * @return The sumPendingAmt.
     */
    @java.lang.Override
    public long getSumPendingAmt() {
      return sumPendingAmt_;
    }

    public static final int SUM_SUCCEEDED_AMT_FIELD_NUMBER = 5;
    private long sumSucceededAmt_ = 0L;
    /**
     * <pre>
     *
     *The sum of all succeeded swap amounts.
     * </pre>
     *
     * <code>int64 sum_succeeded_amt = 5 [jstype = JS_STRING];</code>
     * @return The sumSucceededAmt.
     */
    @java.lang.Override
    public long getSumSucceededAmt() {
      return sumSucceededAmt_;
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (pendingCount_ != 0L) {
        output.writeUInt64(1, pendingCount_);
      }
      if (successCount_ != 0L) {
        output.writeUInt64(2, successCount_);
      }
      if (failCount_ != 0L) {
        output.writeUInt64(3, failCount_);
      }
      if (sumPendingAmt_ != 0L) {
        output.writeInt64(4, sumPendingAmt_);
      }
      if (sumSucceededAmt_ != 0L) {
        output.writeInt64(5, sumSucceededAmt_);
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (pendingCount_ != 0L) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt64Size(1, pendingCount_);
      }
      if (successCount_ != 0L) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt64Size(2, successCount_);
      }
      if (failCount_ != 0L) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt64Size(3, failCount_);
      }
      if (sumPendingAmt_ != 0L) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt64Size(4, sumPendingAmt_);
      }
      if (sumSucceededAmt_ != 0L) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt64Size(5, sumSucceededAmt_);
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof looprpc.Loop.LoopStats)) {
        return super.equals(obj);
      }
      looprpc.Loop.LoopStats other = (looprpc.Loop.LoopStats) obj;

      if (getPendingCount()
          != other.getPendingCount()) return false;
      if (getSuccessCount()
          != other.getSuccessCount()) return false;
      if (getFailCount()
          != other.getFailCount()) return false;
      if (getSumPendingAmt()
          != other.getSumPendingAmt()) return false;
      if (getSumSucceededAmt()
          != other.getSumSucceededAmt()) return false;
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      hash = (37 * hash) + PENDING_COUNT_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
          getPendingCount());
      hash = (37 * hash) + SUCCESS_COUNT_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
          getSuccessCount());
      hash = (37 * hash) + FAIL_COUNT_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
          getFailCount());
      hash = (37 * hash) + SUM_PENDING_AMT_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
          getSumPendingAmt());
      hash = (37 * hash) + SUM_SUCCEEDED_AMT_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
          getSumSucceededAmt());
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static looprpc.Loop.LoopStats parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static looprpc.Loop.LoopStats parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static looprpc.Loop.LoopStats parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static looprpc.Loop.LoopStats parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static looprpc.Loop.LoopStats parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static looprpc.Loop.LoopStats parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static looprpc.Loop.LoopStats parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static looprpc.Loop.LoopStats parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static looprpc.Loop.LoopStats parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static looprpc.Loop.LoopStats parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static looprpc.Loop.LoopStats parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static looprpc.Loop.LoopStats parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(looprpc.Loop.LoopStats prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * Protobuf type {@code looprpc.LoopStats}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:looprpc.LoopStats)
        looprpc.Loop.LoopStatsOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return looprpc.Loop.internal_static_looprpc_LoopStats_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return looprpc.Loop.internal_static_looprpc_LoopStats_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                looprpc.Loop.LoopStats.class, looprpc.Loop.LoopStats.Builder.class);
      }

      // Construct using looprpc.Loop.LoopStats.newBuilder()
      private Builder() {

      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);

      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        pendingCount_ = 0L;
        successCount_ = 0L;
        failCount_ = 0L;
        sumPendingAmt_ = 0L;
        sumSucceededAmt_ = 0L;
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return looprpc.Loop.internal_static_looprpc_LoopStats_descriptor;
      }

      @java.lang.Override
      public looprpc.Loop.LoopStats getDefaultInstanceForType() {
        return looprpc.Loop.LoopStats.getDefaultInstance();
      }

      @java.lang.Override
      public looprpc.Loop.LoopStats build() {
        looprpc.Loop.LoopStats result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public looprpc.Loop.LoopStats buildPartial() {
        looprpc.Loop.LoopStats result = new looprpc.Loop.LoopStats(this);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartial0(looprpc.Loop.LoopStats result) {
        int from_bitField0_ = bitField0_;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.pendingCount_ = pendingCount_;
        }
        if (((from_bitField0_ & 0x00000002) != 0)) {
          result.successCount_ = successCount_;
        }
        if (((from_bitField0_ & 0x00000004) != 0)) {
          result.failCount_ = failCount_;
        }
        if (((from_bitField0_ & 0x00000008) != 0)) {
          result.sumPendingAmt_ = sumPendingAmt_;
        }
        if (((from_bitField0_ & 0x00000010) != 0)) {
          result.sumSucceededAmt_ = sumSucceededAmt_;
        }
      }

      @java.lang.Override
      public Builder clone() {
        return super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof looprpc.Loop.LoopStats) {
          return mergeFrom((looprpc.Loop.LoopStats)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(looprpc.Loop.LoopStats other) {
        if (other == looprpc.Loop.LoopStats.getDefaultInstance()) return this;
        if (other.getPendingCount() != 0L) {
          setPendingCount(other.getPendingCount());
        }
        if (other.getSuccessCount() != 0L) {
          setSuccessCount(other.getSuccessCount());
        }
        if (other.getFailCount() != 0L) {
          setFailCount(other.getFailCount());
        }
        if (other.getSumPendingAmt() != 0L) {
          setSumPendingAmt(other.getSumPendingAmt());
        }
        if (other.getSumSucceededAmt() != 0L) {
          setSumSucceededAmt(other.getSumSucceededAmt());
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 8: {
                pendingCount_ = input.readUInt64();
                bitField0_ |= 0x00000001;
                break;
              } // case 8
              case 16: {
                successCount_ = input.readUInt64();
                bitField0_ |= 0x00000002;
                break;
              } // case 16
              case 24: {
                failCount_ = input.readUInt64();
                bitField0_ |= 0x00000004;
                break;
              } // case 24
              case 32: {
                sumPendingAmt_ = input.readInt64();
                bitField0_ |= 0x00000008;
                break;
              } // case 32
              case 40: {
                sumSucceededAmt_ = input.readInt64();
                bitField0_ |= 0x00000010;
                break;
              } // case 40
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private long pendingCount_ ;
      /**
       * <pre>
       *
       *Number of currently pending swaps.
       * </pre>
       *
       * <code>uint64 pending_count = 1 [jstype = JS_STRING];</code>
       * @return The pendingCount.
       */
      @java.lang.Override
      public long getPendingCount() {
        return pendingCount_;
      }
      /**
       * <pre>
       *
       *Number of currently pending swaps.
       * </pre>
       *
       * <code>uint64 pending_count = 1 [jstype = JS_STRING];</code>
       * @param value The pendingCount to set.
       * @return This builder for chaining.
       */
      public Builder setPendingCount(long value) {

        pendingCount_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       *
       *Number of currently pending swaps.
       * </pre>
       *
       * <code>uint64 pending_count = 1 [jstype = JS_STRING];</code>
       * @return This builder for chaining.
       */
      public Builder clearPendingCount() {
        bitField0_ = (bitField0_ & ~0x00000001);
        pendingCount_ = 0L;
        onChanged();
        return this;
      }

      private long successCount_ ;
      /**
       * <pre>
       *
       *Number of succeeded swaps.
       * </pre>
       *
       * <code>uint64 success_count = 2 [jstype = JS_STRING];</code>
       * @return The successCount.
       */
      @java.lang.Override
      public long getSuccessCount() {
        return successCount_;
      }
      /**
       * <pre>
       *
       *Number of succeeded swaps.
       * </pre>
       *
       * <code>uint64 success_count = 2 [jstype = JS_STRING];</code>
       * @param value The successCount to set.
       * @return This builder for chaining.
       */
      public Builder setSuccessCount(long value) {

        successCount_ = value;
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       *
       *Number of succeeded swaps.
       * </pre>
       *
       * <code>uint64 success_count = 2 [jstype = JS_STRING];</code>
       * @return This builder for chaining.
       */
      public Builder clearSuccessCount() {
        bitField0_ = (bitField0_ & ~0x00000002);
        successCount_ = 0L;
        onChanged();
        return this;
      }

      private long failCount_ ;
      /**
       * <pre>
       *
       *Number failed swaps.
       * </pre>
       *
       * <code>uint64 fail_count = 3 [jstype = JS_STRING];</code>
       * @return The failCount.
       */
      @java.lang.Override
      public long getFailCount() {
        return failCount_;
      }
      /**
       * <pre>
       *
       *Number failed swaps.
       * </pre>
       *
       * <code>uint64 fail_count = 3 [jstype = JS_STRING];</code>
       * @param value The failCount to set.
       * @return This builder for chaining.
       */
      public Builder setFailCount(long value) {

        failCount_ = value;
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }
      /**
       * <pre>
       *
       *Number failed swaps.
       * </pre>
       *
       * <code>uint64 fail_count = 3 [jstype = JS_STRING];</code>
       * @return This builder for chaining.
       */
      public Builder clearFailCount() {
        bitField0_ = (bitField0_ & ~0x00000004);
        failCount_ = 0L;
        onChanged();
        return this;
      }

      private long sumPendingAmt_ ;
      /**
       * <pre>
       *
       *The sum of all pending swap amounts.
       * </pre>
       *
       * <code>int64 sum_pending_amt = 4 [jstype = JS_STRING];</code>
       * @return The sumPendingAmt.
       */
      @java.lang.Override
      public long getSumPendingAmt() {
        return sumPendingAmt_;
      }
      /**
       * <pre>
       *
       *The sum of all pending swap amounts.
       * </pre>
       *
       * <code>int64 sum_pending_amt = 4 [jstype = JS_STRING];</code>
       * @param value The sumPendingAmt to set.
       * @return This builder for chaining.
       */
      public Builder setSumPendingAmt(long value) {

        sumPendingAmt_ = value;
        bitField0_ |= 0x00000008;
        onChanged();
        return this;
      }
      /**
       * <pre>
       *
       *The sum of all pending swap amounts.
       * </pre>
       *
       * <code>int64 sum_pending_amt = 4 [jstype = JS_STRING];</code>
       * @return This builder for chaining.
       */
      public Builder clearSumPendingAmt() {
        bitField0_ = (bitField0_ & ~0x00000008);
        sumPendingAmt_ = 0L;
        onChanged();
        return this;
      }

      private long sumSucceededAmt_ ;
      /**
       * <pre>
       *
       *The sum of all succeeded swap amounts.
       * </pre>
       *
       * <code>int64 sum_succeeded_amt = 5 [jstype = JS_STRING];</code>
       * @return The sumSucceededAmt.
       */
      @java.lang.Override
      public long getSumSucceededAmt() {
        return sumSucceededAmt_;
      }
      /**
       * <pre>
       *
       *The sum of all succeeded swap amounts.
       * </pre>
       *
       * <code>int64 sum_succeeded_amt = 5 [jstype = JS_STRING];</code>
       * @param value The sumSucceededAmt to set.
       * @return This builder for chaining.
       */
      public Builder setSumSucceededAmt(long value) {

        sumSucceededAmt_ = value;
        bitField0_ |= 0x00000010;
        onChanged();
        return this;
      }
      /**
       * <pre>
       *
       *The sum of all succeeded swap amounts.
       * </pre>
       *
       * <code>int64 sum_succeeded_amt = 5 [jstype = JS_STRING];</code>
       * @return This builder for chaining.
       */
      public Builder clearSumSucceededAmt() {
        bitField0_ = (bitField0_ & ~0x00000010);
        sumSucceededAmt_ = 0L;
        onChanged();
        return this;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:looprpc.LoopStats)
    }

    // @@protoc_insertion_point(class_scope:looprpc.LoopStats)
    private static final looprpc.Loop.LoopStats DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new looprpc.Loop.LoopStats();
    }

    public static looprpc.Loop.LoopStats getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<LoopStats>
        PARSER = new com.google.protobuf.AbstractParser<LoopStats>() {
      @java.lang.Override
      public LoopStats parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<LoopStats> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<LoopStats> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public looprpc.Loop.LoopStats getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface GetInfoRequestOrBuilder extends
      // @@protoc_insertion_point(interface_extends:looprpc.GetInfoRequest)
      com.google.protobuf.MessageOrBuilder {
  }
  /**
   * Protobuf type {@code looprpc.GetInfoRequest}
   */
  public static final class GetInfoRequest extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:looprpc.GetInfoRequest)
      GetInfoRequestOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use GetInfoRequest.newBuilder() to construct.
    private GetInfoRequest(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private GetInfoRequest() {
    }

    @java.lang.Override
    @SuppressWarnings({"unused"})
    protected java.lang.Object newInstance(
        UnusedPrivateParameter unused) {
      return new GetInfoRequest();
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return looprpc.Loop.internal_static_looprpc_GetInfoRequest_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return looprpc.Loop.internal_static_looprpc_GetInfoRequest_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              looprpc.Loop.GetInfoRequest.class, looprpc.Loop.GetInfoRequest.Builder.class);
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof looprpc.Loop.GetInfoRequest)) {
        return super.equals(obj);
      }
      looprpc.Loop.GetInfoRequest other = (looprpc.Loop.GetInfoRequest) obj;

      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static looprpc.Loop.GetInfoRequest parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static looprpc.Loop.GetInfoRequest parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static looprpc.Loop.GetInfoRequest parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static looprpc.Loop.GetInfoRequest parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static looprpc.Loop.GetInfoRequest parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static looprpc.Loop.GetInfoRequest parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static looprpc.Loop.GetInfoRequest parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static looprpc.Loop.GetInfoRequest parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static looprpc.Loop.GetInfoRequest parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static looprpc.Loop.GetInfoRequest parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static looprpc.Loop.GetInfoRequest parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static looprpc.Loop.GetInfoRequest parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(looprpc.Loop.GetInfoRequest prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * Protobuf type {@code looprpc.GetInfoRequest}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:looprpc.GetInfoRequest)
        looprpc.Loop.GetInfoRequestOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return looprpc.Loop.internal_static_looprpc_GetInfoRequest_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return looprpc.Loop.internal_static_looprpc_GetInfoRequest_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                looprpc.Loop.GetInfoRequest.class, looprpc.Loop.GetInfoRequest.Builder.class);
      }

      // Construct using looprpc.Loop.GetInfoRequest.newBuilder()
      private Builder() {

      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);

      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return looprpc.Loop.internal_static_looprpc_GetInfoRequest_descriptor;
      }

      @java.lang.Override
      public looprpc.Loop.GetInfoRequest getDefaultInstanceForType() {
        return looprpc.Loop.GetInfoRequest.getDefaultInstance();
      }

      @java.lang.Override
      public looprpc.Loop.GetInfoRequest build() {
        looprpc.Loop.GetInfoRequest result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public looprpc.Loop.GetInfoRequest buildPartial() {
        looprpc.Loop.GetInfoRequest result = new looprpc.Loop.GetInfoRequest(this);
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof looprpc.Loop.GetInfoRequest) {
          return mergeFrom((looprpc.Loop.GetInfoRequest)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(looprpc.Loop.GetInfoRequest other) {
        if (other == looprpc.Loop.GetInfoRequest.getDefaultInstance()) return this;
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:looprpc.GetInfoRequest)
    }

    // @@protoc_insertion_point(class_scope:looprpc.GetInfoRequest)
    private static final looprpc.Loop.GetInfoRequest DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new looprpc.Loop.GetInfoRequest();
    }

    public static looprpc.Loop.GetInfoRequest getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<GetInfoRequest>
        PARSER = new com.google.protobuf.AbstractParser<GetInfoRequest>() {
      @java.lang.Override
      public GetInfoRequest parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<GetInfoRequest> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<GetInfoRequest> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public looprpc.Loop.GetInfoRequest getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface GetInfoResponseOrBuilder extends
      // @@protoc_insertion_point(interface_extends:looprpc.GetInfoResponse)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     *
     *The current daemon version.
     * </pre>
     *
     * <code>string version = 1;</code>
     * @return The version.
     */
    java.lang.String getVersion();
    /**
     * <pre>
     *
     *The current daemon version.
     * </pre>
     *
     * <code>string version = 1;</code>
     * @return The bytes for version.
     */
    com.google.protobuf.ByteString
        getVersionBytes();

    /**
     * <pre>
     *
     *The network the daemon is running on.
     * </pre>
     *
     * <code>string network = 2;</code>
     * @return The network.
     */
    java.lang.String getNetwork();
    /**
     * <pre>
     *
     *The network the daemon is running on.
     * </pre>
     *
     * <code>string network = 2;</code>
     * @return The bytes for network.
     */
    com.google.protobuf.ByteString
        getNetworkBytes();

    /**
     * <pre>
     *
     *Host and port of the loopd grpc server.
     * </pre>
     *
     * <code>string rpc_listen = 3;</code>
     * @return The rpcListen.
     */
    java.lang.String getRpcListen();
    /**
     * <pre>
     *
     *Host and port of the loopd grpc server.
     * </pre>
     *
     * <code>string rpc_listen = 3;</code>
     * @return The bytes for rpcListen.
     */
    com.google.protobuf.ByteString
        getRpcListenBytes();

    /**
     * <pre>
     *
     *Host and port of the loopd rest server.
     * </pre>
     *
     * <code>string rest_listen = 4;</code>
     * @return The restListen.
     */
    java.lang.String getRestListen();
    /**
     * <pre>
     *
     *Host and port of the loopd rest server.
     * </pre>
     *
     * <code>string rest_listen = 4;</code>
     * @return The bytes for restListen.
     */
    com.google.protobuf.ByteString
        getRestListenBytes();

    /**
     * <pre>
     *
     *Loop's macaroon path that clients use to talk to the daemon.
     * </pre>
     *
     * <code>string macaroon_path = 5;</code>
     * @return The macaroonPath.
     */
    java.lang.String getMacaroonPath();
    /**
     * <pre>
     *
     *Loop's macaroon path that clients use to talk to the daemon.
     * </pre>
     *
     * <code>string macaroon_path = 5;</code>
     * @return The bytes for macaroonPath.
     */
    com.google.protobuf.ByteString
        getMacaroonPathBytes();

    /**
     * <pre>
     *
     *Loop's tls cert path
     * </pre>
     *
     * <code>string tls_cert_path = 6;</code>
     * @return The tlsCertPath.
     */
    java.lang.String getTlsCertPath();
    /**
     * <pre>
     *
     *Loop's tls cert path
     * </pre>
     *
     * <code>string tls_cert_path = 6;</code>
     * @return The bytes for tlsCertPath.
     */
    com.google.protobuf.ByteString
        getTlsCertPathBytes();

    /**
     * <pre>
     *
     *Statistics about loop outs.
     * </pre>
     *
     * <code>.looprpc.LoopStats loop_out_stats = 7;</code>
     * @return Whether the loopOutStats field is set.
     */
    boolean hasLoopOutStats();
    /**
     * <pre>
     *
     *Statistics about loop outs.
     * </pre>
     *
     * <code>.looprpc.LoopStats loop_out_stats = 7;</code>
     * @return The loopOutStats.
     */
    looprpc.Loop.LoopStats getLoopOutStats();
    /**
     * <pre>
     *
     *Statistics about loop outs.
     * </pre>
     *
     * <code>.looprpc.LoopStats loop_out_stats = 7;</code>
     */
    looprpc.Loop.LoopStatsOrBuilder getLoopOutStatsOrBuilder();

    /**
     * <pre>
     *
     *Statistics about loop ins.
     * </pre>
     *
     * <code>.looprpc.LoopStats loop_in_stats = 8;</code>
     * @return Whether the loopInStats field is set.
     */
    boolean hasLoopInStats();
    /**
     * <pre>
     *
     *Statistics about loop ins.
     * </pre>
     *
     * <code>.looprpc.LoopStats loop_in_stats = 8;</code>
     * @return The loopInStats.
     */
    looprpc.Loop.LoopStats getLoopInStats();
    /**
     * <pre>
     *
     *Statistics about loop ins.
     * </pre>
     *
     * <code>.looprpc.LoopStats loop_in_stats = 8;</code>
     */
    looprpc.Loop.LoopStatsOrBuilder getLoopInStatsOrBuilder();
  }
  /**
   * Protobuf type {@code looprpc.GetInfoResponse}
   */
  public static final class GetInfoResponse extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:looprpc.GetInfoResponse)
      GetInfoResponseOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use GetInfoResponse.newBuilder() to construct.
    private GetInfoResponse(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private GetInfoResponse() {
      version_ = "";
      network_ = "";
      rpcListen_ = "";
      restListen_ = "";
      macaroonPath_ = "";
      tlsCertPath_ = "";
    }

    @java.lang.Override
    @SuppressWarnings({"unused"})
    protected java.lang.Object newInstance(
        UnusedPrivateParameter unused) {
      return new GetInfoResponse();
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return looprpc.Loop.internal_static_looprpc_GetInfoResponse_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return looprpc.Loop.internal_static_looprpc_GetInfoResponse_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              looprpc.Loop.GetInfoResponse.class, looprpc.Loop.GetInfoResponse.Builder.class);
    }

    private int bitField0_;
    public static final int VERSION_FIELD_NUMBER = 1;
    @SuppressWarnings("serial")
    private volatile java.lang.Object version_ = "";
    /**
     * <pre>
     *
     *The current daemon version.
     * </pre>
     *
     * <code>string version = 1;</code>
     * @return The version.
     */
    @java.lang.Override
    public java.lang.String getVersion() {
      java.lang.Object ref = version_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        version_ = s;
        return s;
      }
    }
    /**
     * <pre>
     *
     *The current daemon version.
     * </pre>
     *
     * <code>string version = 1;</code>
     * @return The bytes for version.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getVersionBytes() {
      java.lang.Object ref = version_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        version_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int NETWORK_FIELD_NUMBER = 2;
    @SuppressWarnings("serial")
    private volatile java.lang.Object network_ = "";
    /**
     * <pre>
     *
     *The network the daemon is running on.
     * </pre>
     *
     * <code>string network = 2;</code>
     * @return The network.
     */
    @java.lang.Override
    public java.lang.String getNetwork() {
      java.lang.Object ref = network_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        network_ = s;
        return s;
      }
    }
    /**
     * <pre>
     *
     *The network the daemon is running on.
     * </pre>
     *
     * <code>string network = 2;</code>
     * @return The bytes for network.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getNetworkBytes() {
      java.lang.Object ref = network_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        network_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int RPC_LISTEN_FIELD_NUMBER = 3;
    @SuppressWarnings("serial")
    private volatile java.lang.Object rpcListen_ = "";
    /**
     * <pre>
     *
     *Host and port of the loopd grpc server.
     * </pre>
     *
     * <code>string rpc_listen = 3;</code>
     * @return The rpcListen.
     */
    @java.lang.Override
    public java.lang.String getRpcListen() {
      java.lang.Object ref = rpcListen_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        rpcListen_ = s;
        return s;
      }
    }
    /**
     * <pre>
     *
     *Host and port of the loopd grpc server.
     * </pre>
     *
     * <code>string rpc_listen = 3;</code>
     * @return The bytes for rpcListen.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getRpcListenBytes() {
      java.lang.Object ref = rpcListen_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        rpcListen_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int REST_LISTEN_FIELD_NUMBER = 4;
    @SuppressWarnings("serial")
    private volatile java.lang.Object restListen_ = "";
    /**
     * <pre>
     *
     *Host and port of the loopd rest server.
     * </pre>
     *
     * <code>string rest_listen = 4;</code>
     * @return The restListen.
     */
    @java.lang.Override
    public java.lang.String getRestListen() {
      java.lang.Object ref = restListen_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        restListen_ = s;
        return s;
      }
    }
    /**
     * <pre>
     *
     *Host and port of the loopd rest server.
     * </pre>
     *
     * <code>string rest_listen = 4;</code>
     * @return The bytes for restListen.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getRestListenBytes() {
      java.lang.Object ref = restListen_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        restListen_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int MACAROON_PATH_FIELD_NUMBER = 5;
    @SuppressWarnings("serial")
    private volatile java.lang.Object macaroonPath_ = "";
    /**
     * <pre>
     *
     *Loop's macaroon path that clients use to talk to the daemon.
     * </pre>
     *
     * <code>string macaroon_path = 5;</code>
     * @return The macaroonPath.
     */
    @java.lang.Override
    public java.lang.String getMacaroonPath() {
      java.lang.Object ref = macaroonPath_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        macaroonPath_ = s;
        return s;
      }
    }
    /**
     * <pre>
     *
     *Loop's macaroon path that clients use to talk to the daemon.
     * </pre>
     *
     * <code>string macaroon_path = 5;</code>
     * @return The bytes for macaroonPath.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getMacaroonPathBytes() {
      java.lang.Object ref = macaroonPath_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        macaroonPath_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int TLS_CERT_PATH_FIELD_NUMBER = 6;
    @SuppressWarnings("serial")
    private volatile java.lang.Object tlsCertPath_ = "";
    /**
     * <pre>
     *
     *Loop's tls cert path
     * </pre>
     *
     * <code>string tls_cert_path = 6;</code>
     * @return The tlsCertPath.
     */
    @java.lang.Override
    public java.lang.String getTlsCertPath() {
      java.lang.Object ref = tlsCertPath_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        tlsCertPath_ = s;
        return s;
      }
    }
    /**
     * <pre>
     *
     *Loop's tls cert path
     * </pre>
     *
     * <code>string tls_cert_path = 6;</code>
     * @return The bytes for tlsCertPath.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getTlsCertPathBytes() {
      java.lang.Object ref = tlsCertPath_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        tlsCertPath_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int LOOP_OUT_STATS_FIELD_NUMBER = 7;
    private looprpc.Loop.LoopStats loopOutStats_;
    /**
     * <pre>
     *
     *Statistics about loop outs.
     * </pre>
     *
     * <code>.looprpc.LoopStats loop_out_stats = 7;</code>
     * @return Whether the loopOutStats field is set.
     */
    @java.lang.Override
    public boolean hasLoopOutStats() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     *
     *Statistics about loop outs.
     * </pre>
     *
     * <code>.looprpc.LoopStats loop_out_stats = 7;</code>
     * @return The loopOutStats.
     */
    @java.lang.Override
    public looprpc.Loop.LoopStats getLoopOutStats() {
      return loopOutStats_ == null ? looprpc.Loop.LoopStats.getDefaultInstance() : loopOutStats_;
    }
    /**
     * <pre>
     *
     *Statistics about loop outs.
     * </pre>
     *
     * <code>.looprpc.LoopStats loop_out_stats = 7;</code>
     */
    @java.lang.Override
    public looprpc.Loop.LoopStatsOrBuilder getLoopOutStatsOrBuilder() {
      return loopOutStats_ == null ? looprpc.Loop.LoopStats.getDefaultInstance() : loopOutStats_;
    }

    public static final int LOOP_IN_STATS_FIELD_NUMBER = 8;
    private looprpc.Loop.LoopStats loopInStats_;
    /**
     * <pre>
     *
     *Statistics about loop ins.
     * </pre>
     *
     * <code>.looprpc.LoopStats loop_in_stats = 8;</code>
     * @return Whether the loopInStats field is set.
     */
    @java.lang.Override
    public boolean hasLoopInStats() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <pre>
     *
     *Statistics about loop ins.
     * </pre>
     *
     * <code>.looprpc.LoopStats loop_in_stats = 8;</code>
     * @return The loopInStats.
     */
    @java.lang.Override
    public looprpc.Loop.LoopStats getLoopInStats() {
      return loopInStats_ == null ? looprpc.Loop.LoopStats.getDefaultInstance() : loopInStats_;
    }
    /**
     * <pre>
     *
     *Statistics about loop ins.
     * </pre>
     *
     * <code>.looprpc.LoopStats loop_in_stats = 8;</code>
     */
    @java.lang.Override
    public looprpc.Loop.LoopStatsOrBuilder getLoopInStatsOrBuilder() {
      return loopInStats_ == null ? looprpc.Loop.LoopStats.getDefaultInstance() : loopInStats_;
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(version_)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 1, version_);
      }
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(network_)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 2, network_);
      }
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(rpcListen_)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 3, rpcListen_);
      }
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(restListen_)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 4, restListen_);
      }
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(macaroonPath_)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 5, macaroonPath_);
      }
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(tlsCertPath_)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 6, tlsCertPath_);
      }
      if (((bitField0_ & 0x00000001) != 0)) {
        output.writeMessage(7, getLoopOutStats());
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        output.writeMessage(8, getLoopInStats());
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(version_)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(1, version_);
      }
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(network_)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(2, network_);
      }
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(rpcListen_)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(3, rpcListen_);
      }
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(restListen_)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(4, restListen_);
      }
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(macaroonPath_)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(5, macaroonPath_);
      }
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(tlsCertPath_)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(6, tlsCertPath_);
      }
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(7, getLoopOutStats());
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(8, getLoopInStats());
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof looprpc.Loop.GetInfoResponse)) {
        return super.equals(obj);
      }
      looprpc.Loop.GetInfoResponse other = (looprpc.Loop.GetInfoResponse) obj;

      if (!getVersion()
          .equals(other.getVersion())) return false;
      if (!getNetwork()
          .equals(other.getNetwork())) return false;
      if (!getRpcListen()
          .equals(other.getRpcListen())) return false;
      if (!getRestListen()
          .equals(other.getRestListen())) return false;
      if (!getMacaroonPath()
          .equals(other.getMacaroonPath())) return false;
      if (!getTlsCertPath()
          .equals(other.getTlsCertPath())) return false;
      if (hasLoopOutStats() != other.hasLoopOutStats()) return false;
      if (hasLoopOutStats()) {
        if (!getLoopOutStats()
            .equals(other.getLoopOutStats())) return false;
      }
      if (hasLoopInStats() != other.hasLoopInStats()) return false;
      if (hasLoopInStats()) {
        if (!getLoopInStats()
            .equals(other.getLoopInStats())) return false;
      }
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      hash = (37 * hash) + VERSION_FIELD_NUMBER;
      hash = (53 * hash) + getVersion().hashCode();
      hash = (37 * hash) + NETWORK_FIELD_NUMBER;
      hash = (53 * hash) + getNetwork().hashCode();
      hash = (37 * hash) + RPC_LISTEN_FIELD_NUMBER;
      hash = (53 * hash) + getRpcListen().hashCode();
      hash = (37 * hash) + REST_LISTEN_FIELD_NUMBER;
      hash = (53 * hash) + getRestListen().hashCode();
      hash = (37 * hash) + MACAROON_PATH_FIELD_NUMBER;
      hash = (53 * hash) + getMacaroonPath().hashCode();
      hash = (37 * hash) + TLS_CERT_PATH_FIELD_NUMBER;
      hash = (53 * hash) + getTlsCertPath().hashCode();
      if (hasLoopOutStats()) {
        hash = (37 * hash) + LOOP_OUT_STATS_FIELD_NUMBER;
        hash = (53 * hash) + getLoopOutStats().hashCode();
      }
      if (hasLoopInStats()) {
        hash = (37 * hash) + LOOP_IN_STATS_FIELD_NUMBER;
        hash = (53 * hash) + getLoopInStats().hashCode();
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static looprpc.Loop.GetInfoResponse parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static looprpc.Loop.GetInfoResponse parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static looprpc.Loop.GetInfoResponse parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static looprpc.Loop.GetInfoResponse parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static looprpc.Loop.GetInfoResponse parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static looprpc.Loop.GetInfoResponse parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static looprpc.Loop.GetInfoResponse parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static looprpc.Loop.GetInfoResponse parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static looprpc.Loop.GetInfoResponse parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static looprpc.Loop.GetInfoResponse parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static looprpc.Loop.GetInfoResponse parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static looprpc.Loop.GetInfoResponse parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(looprpc.Loop.GetInfoResponse prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * Protobuf type {@code looprpc.GetInfoResponse}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:looprpc.GetInfoResponse)
        looprpc.Loop.GetInfoResponseOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return looprpc.Loop.internal_static_looprpc_GetInfoResponse_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return looprpc.Loop.internal_static_looprpc_GetInfoResponse_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                looprpc.Loop.GetInfoResponse.class, looprpc.Loop.GetInfoResponse.Builder.class);
      }

      // Construct using looprpc.Loop.GetInfoResponse.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
          getLoopOutStatsFieldBuilder();
          getLoopInStatsFieldBuilder();
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        version_ = "";
        network_ = "";
        rpcListen_ = "";
        restListen_ = "";
        macaroonPath_ = "";
        tlsCertPath_ = "";
        loopOutStats_ = null;
        if (loopOutStatsBuilder_ != null) {
          loopOutStatsBuilder_.dispose();
          loopOutStatsBuilder_ = null;
        }
        loopInStats_ = null;
        if (loopInStatsBuilder_ != null) {
          loopInStatsBuilder_.dispose();
          loopInStatsBuilder_ = null;
        }
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return looprpc.Loop.internal_static_looprpc_GetInfoResponse_descriptor;
      }

      @java.lang.Override
      public looprpc.Loop.GetInfoResponse getDefaultInstanceForType() {
        return looprpc.Loop.GetInfoResponse.getDefaultInstance();
      }

      @java.lang.Override
      public looprpc.Loop.GetInfoResponse build() {
        looprpc.Loop.GetInfoResponse result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public looprpc.Loop.GetInfoResponse buildPartial() {
        looprpc.Loop.GetInfoResponse result = new looprpc.Loop.GetInfoResponse(this);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartial0(looprpc.Loop.GetInfoResponse result) {
        int from_bitField0_ = bitField0_;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.version_ = version_;
        }
        if (((from_bitField0_ & 0x00000002) != 0)) {
          result.network_ = network_;
        }
        if (((from_bitField0_ & 0x00000004) != 0)) {
          result.rpcListen_ = rpcListen_;
        }
        if (((from_bitField0_ & 0x00000008) != 0)) {
          result.restListen_ = restListen_;
        }
        if (((from_bitField0_ & 0x00000010) != 0)) {
          result.macaroonPath_ = macaroonPath_;
        }
        if (((from_bitField0_ & 0x00000020) != 0)) {
          result.tlsCertPath_ = tlsCertPath_;
        }
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000040) != 0)) {
          result.loopOutStats_ = loopOutStatsBuilder_ == null
              ? loopOutStats_
              : loopOutStatsBuilder_.build();
          to_bitField0_ |= 0x00000001;
        }
        if (((from_bitField0_ & 0x00000080) != 0)) {
          result.loopInStats_ = loopInStatsBuilder_ == null
              ? loopInStats_
              : loopInStatsBuilder_.build();
          to_bitField0_ |= 0x00000002;
        }
        result.bitField0_ |= to_bitField0_;
      }

      @java.lang.Override
      public Builder clone() {
        return super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof looprpc.Loop.GetInfoResponse) {
          return mergeFrom((looprpc.Loop.GetInfoResponse)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(looprpc.Loop.GetInfoResponse other) {
        if (other == looprpc.Loop.GetInfoResponse.getDefaultInstance()) return this;
        if (!other.getVersion().isEmpty()) {
          version_ = other.version_;
          bitField0_ |= 0x00000001;
          onChanged();
        }
        if (!other.getNetwork().isEmpty()) {
          network_ = other.network_;
          bitField0_ |= 0x00000002;
          onChanged();
        }
        if (!other.getRpcListen().isEmpty()) {
          rpcListen_ = other.rpcListen_;
          bitField0_ |= 0x00000004;
          onChanged();
        }
        if (!other.getRestListen().isEmpty()) {
          restListen_ = other.restListen_;
          bitField0_ |= 0x00000008;
          onChanged();
        }
        if (!other.getMacaroonPath().isEmpty()) {
          macaroonPath_ = other.macaroonPath_;
          bitField0_ |= 0x00000010;
          onChanged();
        }
        if (!other.getTlsCertPath().isEmpty()) {
          tlsCertPath_ = other.tlsCertPath_;
          bitField0_ |= 0x00000020;
          onChanged();
        }
        if (other.hasLoopOutStats()) {
          mergeLoopOutStats(other.getLoopOutStats());
        }
        if (other.hasLoopInStats()) {
          mergeLoopInStats(other.getLoopInStats());
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10: {
                version_ = input.readStringRequireUtf8();
                bitField0_ |= 0x00000001;
                break;
              } // case 10
              case 18: {
                network_ = input.readStringRequireUtf8();
                bitField0_ |= 0x00000002;
                break;
              } // case 18
              case 26: {
                rpcListen_ = input.readStringRequireUtf8();
                bitField0_ |= 0x00000004;
                break;
              } // case 26
              case 34: {
                restListen_ = input.readStringRequireUtf8();
                bitField0_ |= 0x00000008;
                break;
              } // case 34
              case 42: {
                macaroonPath_ = input.readStringRequireUtf8();
                bitField0_ |= 0x00000010;
                break;
              } // case 42
              case 50: {
                tlsCertPath_ = input.readStringRequireUtf8();
                bitField0_ |= 0x00000020;
                break;
              } // case 50
              case 58: {
                input.readMessage(
                    getLoopOutStatsFieldBuilder().getBuilder(),
                    extensionRegistry);
                bitField0_ |= 0x00000040;
                break;
              } // case 58
              case 66: {
                input.readMessage(
                    getLoopInStatsFieldBuilder().getBuilder(),
                    extensionRegistry);
                bitField0_ |= 0x00000080;
                break;
              } // case 66
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private java.lang.Object version_ = "";
      /**
       * <pre>
       *
       *The current daemon version.
       * </pre>
       *
       * <code>string version = 1;</code>
       * @return The version.
       */
      public java.lang.String getVersion() {
        java.lang.Object ref = version_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          version_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       *
       *The current daemon version.
       * </pre>
       *
       * <code>string version = 1;</code>
       * @return The bytes for version.
       */
      public com.google.protobuf.ByteString
          getVersionBytes() {
        java.lang.Object ref = version_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          version_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       *
       *The current daemon version.
       * </pre>
       *
       * <code>string version = 1;</code>
       * @param value The version to set.
       * @return This builder for chaining.
       */
      public Builder setVersion(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        version_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       *
       *The current daemon version.
       * </pre>
       *
       * <code>string version = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearVersion() {
        version_ = getDefaultInstance().getVersion();
        bitField0_ = (bitField0_ & ~0x00000001);
        onChanged();
        return this;
      }
      /**
       * <pre>
       *
       *The current daemon version.
       * </pre>
       *
       * <code>string version = 1;</code>
       * @param value The bytes for version to set.
       * @return This builder for chaining.
       */
      public Builder setVersionBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        checkByteStringIsUtf8(value);
        version_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }

      private java.lang.Object network_ = "";
      /**
       * <pre>
       *
       *The network the daemon is running on.
       * </pre>
       *
       * <code>string network = 2;</code>
       * @return The network.
       */
      public java.lang.String getNetwork() {
        java.lang.Object ref = network_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          network_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       *
       *The network the daemon is running on.
       * </pre>
       *
       * <code>string network = 2;</code>
       * @return The bytes for network.
       */
      public com.google.protobuf.ByteString
          getNetworkBytes() {
        java.lang.Object ref = network_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          network_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       *
       *The network the daemon is running on.
       * </pre>
       *
       * <code>string network = 2;</code>
       * @param value The network to set.
       * @return This builder for chaining.
       */
      public Builder setNetwork(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        network_ = value;
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       *
       *The network the daemon is running on.
       * </pre>
       *
       * <code>string network = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearNetwork() {
        network_ = getDefaultInstance().getNetwork();
        bitField0_ = (bitField0_ & ~0x00000002);
        onChanged();
        return this;
      }
      /**
       * <pre>
       *
       *The network the daemon is running on.
       * </pre>
       *
       * <code>string network = 2;</code>
       * @param value The bytes for network to set.
       * @return This builder for chaining.
       */
      public Builder setNetworkBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        checkByteStringIsUtf8(value);
        network_ = value;
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }

      private java.lang.Object rpcListen_ = "";
      /**
       * <pre>
       *
       *Host and port of the loopd grpc server.
       * </pre>
       *
       * <code>string rpc_listen = 3;</code>
       * @return The rpcListen.
       */
      public java.lang.String getRpcListen() {
        java.lang.Object ref = rpcListen_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          rpcListen_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       *
       *Host and port of the loopd grpc server.
       * </pre>
       *
       * <code>string rpc_listen = 3;</code>
       * @return The bytes for rpcListen.
       */
      public com.google.protobuf.ByteString
          getRpcListenBytes() {
        java.lang.Object ref = rpcListen_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          rpcListen_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       *
       *Host and port of the loopd grpc server.
       * </pre>
       *
       * <code>string rpc_listen = 3;</code>
       * @param value The rpcListen to set.
       * @return This builder for chaining.
       */
      public Builder setRpcListen(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        rpcListen_ = value;
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }
      /**
       * <pre>
       *
       *Host and port of the loopd grpc server.
       * </pre>
       *
       * <code>string rpc_listen = 3;</code>
       * @return This builder for chaining.
       */
      public Builder clearRpcListen() {
        rpcListen_ = getDefaultInstance().getRpcListen();
        bitField0_ = (bitField0_ & ~0x00000004);
        onChanged();
        return this;
      }
      /**
       * <pre>
       *
       *Host and port of the loopd grpc server.
       * </pre>
       *
       * <code>string rpc_listen = 3;</code>
       * @param value The bytes for rpcListen to set.
       * @return This builder for chaining.
       */
      public Builder setRpcListenBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        checkByteStringIsUtf8(value);
        rpcListen_ = value;
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }

      private java.lang.Object restListen_ = "";
      /**
       * <pre>
       *
       *Host and port of the loopd rest server.
       * </pre>
       *
       * <code>string rest_listen = 4;</code>
       * @return The restListen.
       */
      public java.lang.String getRestListen() {
        java.lang.Object ref = restListen_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          restListen_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       *
       *Host and port of the loopd rest server.
       * </pre>
       *
       * <code>string rest_listen = 4;</code>
       * @return The bytes for restListen.
       */
      public com.google.protobuf.ByteString
          getRestListenBytes() {
        java.lang.Object ref = restListen_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          restListen_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       *
       *Host and port of the loopd rest server.
       * </pre>
       *
       * <code>string rest_listen = 4;</code>
       * @param value The restListen to set.
       * @return This builder for chaining.
       */
      public Builder setRestListen(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        restListen_ = value;
        bitField0_ |= 0x00000008;
        onChanged();
        return this;
      }
      /**
       * <pre>
       *
       *Host and port of the loopd rest server.
       * </pre>
       *
       * <code>string rest_listen = 4;</code>
       * @return This builder for chaining.
       */
      public Builder clearRestListen() {
        restListen_ = getDefaultInstance().getRestListen();
        bitField0_ = (bitField0_ & ~0x00000008);
        onChanged();
        return this;
      }
      /**
       * <pre>
       *
       *Host and port of the loopd rest server.
       * </pre>
       *
       * <code>string rest_listen = 4;</code>
       * @param value The bytes for restListen to set.
       * @return This builder for chaining.
       */
      public Builder setRestListenBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        checkByteStringIsUtf8(value);
        restListen_ = value;
        bitField0_ |= 0x00000008;
        onChanged();
        return this;
      }

      private java.lang.Object macaroonPath_ = "";
      /**
       * <pre>
       *
       *Loop's macaroon path that clients use to talk to the daemon.
       * </pre>
       *
       * <code>string macaroon_path = 5;</code>
       * @return The macaroonPath.
       */
      public java.lang.String getMacaroonPath() {
        java.lang.Object ref = macaroonPath_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          macaroonPath_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       *
       *Loop's macaroon path that clients use to talk to the daemon.
       * </pre>
       *
       * <code>string macaroon_path = 5;</code>
       * @return The bytes for macaroonPath.
       */
      public com.google.protobuf.ByteString
          getMacaroonPathBytes() {
        java.lang.Object ref = macaroonPath_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          macaroonPath_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       *
       *Loop's macaroon path that clients use to talk to the daemon.
       * </pre>
       *
       * <code>string macaroon_path = 5;</code>
       * @param value The macaroonPath to set.
       * @return This builder for chaining.
       */
      public Builder setMacaroonPath(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        macaroonPath_ = value;
        bitField0_ |= 0x00000010;
        onChanged();
        return this;
      }
      /**
       * <pre>
       *
       *Loop's macaroon path that clients use to talk to the daemon.
       * </pre>
       *
       * <code>string macaroon_path = 5;</code>
       * @return This builder for chaining.
       */
      public Builder clearMacaroonPath() {
        macaroonPath_ = getDefaultInstance().getMacaroonPath();
        bitField0_ = (bitField0_ & ~0x00000010);
        onChanged();
        return this;
      }
      /**
       * <pre>
       *
       *Loop's macaroon path that clients use to talk to the daemon.
       * </pre>
       *
       * <code>string macaroon_path = 5;</code>
       * @param value The bytes for macaroonPath to set.
       * @return This builder for chaining.
       */
      public Builder setMacaroonPathBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        checkByteStringIsUtf8(value);
        macaroonPath_ = value;
        bitField0_ |= 0x00000010;
        onChanged();
        return this;
      }

      private java.lang.Object tlsCertPath_ = "";
      /**
       * <pre>
       *
       *Loop's tls cert path
       * </pre>
       *
       * <code>string tls_cert_path = 6;</code>
       * @return The tlsCertPath.
       */
      public java.lang.String getTlsCertPath() {
        java.lang.Object ref = tlsCertPath_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          tlsCertPath_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       *
       *Loop's tls cert path
       * </pre>
       *
       * <code>string tls_cert_path = 6;</code>
       * @return The bytes for tlsCertPath.
       */
      public com.google.protobuf.ByteString
          getTlsCertPathBytes() {
        java.lang.Object ref = tlsCertPath_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          tlsCertPath_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       *
       *Loop's tls cert path
       * </pre>
       *
       * <code>string tls_cert_path = 6;</code>
       * @param value The tlsCertPath to set.
       * @return This builder for chaining.
       */
      public Builder setTlsCertPath(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        tlsCertPath_ = value;
        bitField0_ |= 0x00000020;
        onChanged();
        return this;
      }
      /**
       * <pre>
       *
       *Loop's tls cert path
       * </pre>
       *
       * <code>string tls_cert_path = 6;</code>
       * @return This builder for chaining.
       */
      public Builder clearTlsCertPath() {
        tlsCertPath_ = getDefaultInstance().getTlsCertPath();
        bitField0_ = (bitField0_ & ~0x00000020);
        onChanged();
        return this;
      }
      /**
       * <pre>
       *
       *Loop's tls cert path
       * </pre>
       *
       * <code>string tls_cert_path = 6;</code>
       * @param value The bytes for tlsCertPath to set.
       * @return This builder for chaining.
       */
      public Builder setTlsCertPathBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        checkByteStringIsUtf8(value);
        tlsCertPath_ = value;
        bitField0_ |= 0x00000020;
        onChanged();
        return this;
      }

      private looprpc.Loop.LoopStats loopOutStats_;
      private com.google.protobuf.SingleFieldBuilderV3<
          looprpc.Loop.LoopStats, looprpc.Loop.LoopStats.Builder, looprpc.Loop.LoopStatsOrBuilder> loopOutStatsBuilder_;
      /**
       * <pre>
       *
       *Statistics about loop outs.
       * </pre>
       *
       * <code>.looprpc.LoopStats loop_out_stats = 7;</code>
       * @return Whether the loopOutStats field is set.
       */
      public boolean hasLoopOutStats() {
        return ((bitField0_ & 0x00000040) != 0);
      }
      /**
       * <pre>
       *
       *Statistics about loop outs.
       * </pre>
       *
       * <code>.looprpc.LoopStats loop_out_stats = 7;</code>
       * @return The loopOutStats.
       */
      public looprpc.Loop.LoopStats getLoopOutStats() {
        if (loopOutStatsBuilder_ == null) {
          return loopOutStats_ == null ? looprpc.Loop.LoopStats.getDefaultInstance() : loopOutStats_;
        } else {
          return loopOutStatsBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       *
       *Statistics about loop outs.
       * </pre>
       *
       * <code>.looprpc.LoopStats loop_out_stats = 7;</code>
       */
      public Builder setLoopOutStats(looprpc.Loop.LoopStats value) {
        if (loopOutStatsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          loopOutStats_ = value;
        } else {
          loopOutStatsBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000040;
        onChanged();
        return this;
      }
      /**
       * <pre>
       *
       *Statistics about loop outs.
       * </pre>
       *
       * <code>.looprpc.LoopStats loop_out_stats = 7;</code>
       */
      public Builder setLoopOutStats(
          looprpc.Loop.LoopStats.Builder builderForValue) {
        if (loopOutStatsBuilder_ == null) {
          loopOutStats_ = builderForValue.build();
        } else {
          loopOutStatsBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000040;
        onChanged();
        return this;
      }
      /**
       * <pre>
       *
       *Statistics about loop outs.
       * </pre>
       *
       * <code>.looprpc.LoopStats loop_out_stats = 7;</code>
       */
      public Builder mergeLoopOutStats(looprpc.Loop.LoopStats value) {
        if (loopOutStatsBuilder_ == null) {
          if (((bitField0_ & 0x00000040) != 0) &&
            loopOutStats_ != null &&
            loopOutStats_ != looprpc.Loop.LoopStats.getDefaultInstance()) {
            getLoopOutStatsBuilder().mergeFrom(value);
          } else {
            loopOutStats_ = value;
          }
        } else {
          loopOutStatsBuilder_.mergeFrom(value);
        }
        if (loopOutStats_ != null) {
          bitField0_ |= 0x00000040;
          onChanged();
        }
        return this;
      }
      /**
       * <pre>
       *
       *Statistics about loop outs.
       * </pre>
       *
       * <code>.looprpc.LoopStats loop_out_stats = 7;</code>
       */
      public Builder clearLoopOutStats() {
        bitField0_ = (bitField0_ & ~0x00000040);
        loopOutStats_ = null;
        if (loopOutStatsBuilder_ != null) {
          loopOutStatsBuilder_.dispose();
          loopOutStatsBuilder_ = null;
        }
        onChanged();
        return this;
      }
      /**
       * <pre>
       *
       *Statistics about loop outs.
       * </pre>
       *
       * <code>.looprpc.LoopStats loop_out_stats = 7;</code>
       */
      public looprpc.Loop.LoopStats.Builder getLoopOutStatsBuilder() {
        bitField0_ |= 0x00000040;
        onChanged();
        return getLoopOutStatsFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       *
       *Statistics about loop outs.
       * </pre>
       *
       * <code>.looprpc.LoopStats loop_out_stats = 7;</code>
       */
      public looprpc.Loop.LoopStatsOrBuilder getLoopOutStatsOrBuilder() {
        if (loopOutStatsBuilder_ != null) {
          return loopOutStatsBuilder_.getMessageOrBuilder();
        } else {
          return loopOutStats_ == null ?
              looprpc.Loop.LoopStats.getDefaultInstance() : loopOutStats_;
        }
      }
      /**
       * <pre>
       *
       *Statistics about loop outs.
       * </pre>
       *
       * <code>.looprpc.LoopStats loop_out_stats = 7;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          looprpc.Loop.LoopStats, looprpc.Loop.LoopStats.Builder, looprpc.Loop.LoopStatsOrBuilder> 
          getLoopOutStatsFieldBuilder() {
        if (loopOutStatsBuilder_ == null) {
          loopOutStatsBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              looprpc.Loop.LoopStats, looprpc.Loop.LoopStats.Builder, looprpc.Loop.LoopStatsOrBuilder>(
                  getLoopOutStats(),
                  getParentForChildren(),
                  isClean());
          loopOutStats_ = null;
        }
        return loopOutStatsBuilder_;
      }

      private looprpc.Loop.LoopStats loopInStats_;
      private com.google.protobuf.SingleFieldBuilderV3<
          looprpc.Loop.LoopStats, looprpc.Loop.LoopStats.Builder, looprpc.Loop.LoopStatsOrBuilder> loopInStatsBuilder_;
      /**
       * <pre>
       *
       *Statistics about loop ins.
       * </pre>
       *
       * <code>.looprpc.LoopStats loop_in_stats = 8;</code>
       * @return Whether the loopInStats field is set.
       */
      public boolean hasLoopInStats() {
        return ((bitField0_ & 0x00000080) != 0);
      }
      /**
       * <pre>
       *
       *Statistics about loop ins.
       * </pre>
       *
       * <code>.looprpc.LoopStats loop_in_stats = 8;</code>
       * @return The loopInStats.
       */
      public looprpc.Loop.LoopStats getLoopInStats() {
        if (loopInStatsBuilder_ == null) {
          return loopInStats_ == null ? looprpc.Loop.LoopStats.getDefaultInstance() : loopInStats_;
        } else {
          return loopInStatsBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       *
       *Statistics about loop ins.
       * </pre>
       *
       * <code>.looprpc.LoopStats loop_in_stats = 8;</code>
       */
      public Builder setLoopInStats(looprpc.Loop.LoopStats value) {
        if (loopInStatsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          loopInStats_ = value;
        } else {
          loopInStatsBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000080;
        onChanged();
        return this;
      }
      /**
       * <pre>
       *
       *Statistics about loop ins.
       * </pre>
       *
       * <code>.looprpc.LoopStats loop_in_stats = 8;</code>
       */
      public Builder setLoopInStats(
          looprpc.Loop.LoopStats.Builder builderForValue) {
        if (loopInStatsBuilder_ == null) {
          loopInStats_ = builderForValue.build();
        } else {
          loopInStatsBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000080;
        onChanged();
        return this;
      }
      /**
       * <pre>
       *
       *Statistics about loop ins.
       * </pre>
       *
       * <code>.looprpc.LoopStats loop_in_stats = 8;</code>
       */
      public Builder mergeLoopInStats(looprpc.Loop.LoopStats value) {
        if (loopInStatsBuilder_ == null) {
          if (((bitField0_ & 0x00000080) != 0) &&
            loopInStats_ != null &&
            loopInStats_ != looprpc.Loop.LoopStats.getDefaultInstance()) {
            getLoopInStatsBuilder().mergeFrom(value);
          } else {
            loopInStats_ = value;
          }
        } else {
          loopInStatsBuilder_.mergeFrom(value);
        }
        if (loopInStats_ != null) {
          bitField0_ |= 0x00000080;
          onChanged();
        }
        return this;
      }
      /**
       * <pre>
       *
       *Statistics about loop ins.
       * </pre>
       *
       * <code>.looprpc.LoopStats loop_in_stats = 8;</code>
       */
      public Builder clearLoopInStats() {
        bitField0_ = (bitField0_ & ~0x00000080);
        loopInStats_ = null;
        if (loopInStatsBuilder_ != null) {
          loopInStatsBuilder_.dispose();
          loopInStatsBuilder_ = null;
        }
        onChanged();
        return this;
      }
      /**
       * <pre>
       *
       *Statistics about loop ins.
       * </pre>
       *
       * <code>.looprpc.LoopStats loop_in_stats = 8;</code>
       */
      public looprpc.Loop.LoopStats.Builder getLoopInStatsBuilder() {
        bitField0_ |= 0x00000080;
        onChanged();
        return getLoopInStatsFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       *
       *Statistics about loop ins.
       * </pre>
       *
       * <code>.looprpc.LoopStats loop_in_stats = 8;</code>
       */
      public looprpc.Loop.LoopStatsOrBuilder getLoopInStatsOrBuilder() {
        if (loopInStatsBuilder_ != null) {
          return loopInStatsBuilder_.getMessageOrBuilder();
        } else {
          return loopInStats_ == null ?
              looprpc.Loop.LoopStats.getDefaultInstance() : loopInStats_;
        }
      }
      /**
       * <pre>
       *
       *Statistics about loop ins.
       * </pre>
       *
       * <code>.looprpc.LoopStats loop_in_stats = 8;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          looprpc.Loop.LoopStats, looprpc.Loop.LoopStats.Builder, looprpc.Loop.LoopStatsOrBuilder> 
          getLoopInStatsFieldBuilder() {
        if (loopInStatsBuilder_ == null) {
          loopInStatsBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              looprpc.Loop.LoopStats, looprpc.Loop.LoopStats.Builder, looprpc.Loop.LoopStatsOrBuilder>(
                  getLoopInStats(),
                  getParentForChildren(),
                  isClean());
          loopInStats_ = null;
        }
        return loopInStatsBuilder_;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:looprpc.GetInfoResponse)
    }

    // @@protoc_insertion_point(class_scope:looprpc.GetInfoResponse)
    private static final looprpc.Loop.GetInfoResponse DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new looprpc.Loop.GetInfoResponse();
    }

    public static looprpc.Loop.GetInfoResponse getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<GetInfoResponse>
        PARSER = new com.google.protobuf.AbstractParser<GetInfoResponse>() {
      @java.lang.Override
      public GetInfoResponse parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<GetInfoResponse> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<GetInfoResponse> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public looprpc.Loop.GetInfoResponse getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface GetLiquidityParamsRequestOrBuilder extends
      // @@protoc_insertion_point(interface_extends:looprpc.GetLiquidityParamsRequest)
      com.google.protobuf.MessageOrBuilder {
  }
  /**
   * Protobuf type {@code looprpc.GetLiquidityParamsRequest}
   */
  public static final class GetLiquidityParamsRequest extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:looprpc.GetLiquidityParamsRequest)
      GetLiquidityParamsRequestOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use GetLiquidityParamsRequest.newBuilder() to construct.
    private GetLiquidityParamsRequest(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private GetLiquidityParamsRequest() {
    }

    @java.lang.Override
    @SuppressWarnings({"unused"})
    protected java.lang.Object newInstance(
        UnusedPrivateParameter unused) {
      return new GetLiquidityParamsRequest();
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return looprpc.Loop.internal_static_looprpc_GetLiquidityParamsRequest_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return looprpc.Loop.internal_static_looprpc_GetLiquidityParamsRequest_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              looprpc.Loop.GetLiquidityParamsRequest.class, looprpc.Loop.GetLiquidityParamsRequest.Builder.class);
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof looprpc.Loop.GetLiquidityParamsRequest)) {
        return super.equals(obj);
      }
      looprpc.Loop.GetLiquidityParamsRequest other = (looprpc.Loop.GetLiquidityParamsRequest) obj;

      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static looprpc.Loop.GetLiquidityParamsRequest parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static looprpc.Loop.GetLiquidityParamsRequest parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static looprpc.Loop.GetLiquidityParamsRequest parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static looprpc.Loop.GetLiquidityParamsRequest parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static looprpc.Loop.GetLiquidityParamsRequest parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static looprpc.Loop.GetLiquidityParamsRequest parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static looprpc.Loop.GetLiquidityParamsRequest parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static looprpc.Loop.GetLiquidityParamsRequest parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static looprpc.Loop.GetLiquidityParamsRequest parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static looprpc.Loop.GetLiquidityParamsRequest parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static looprpc.Loop.GetLiquidityParamsRequest parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static looprpc.Loop.GetLiquidityParamsRequest parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(looprpc.Loop.GetLiquidityParamsRequest prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * Protobuf type {@code looprpc.GetLiquidityParamsRequest}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:looprpc.GetLiquidityParamsRequest)
        looprpc.Loop.GetLiquidityParamsRequestOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return looprpc.Loop.internal_static_looprpc_GetLiquidityParamsRequest_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return looprpc.Loop.internal_static_looprpc_GetLiquidityParamsRequest_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                looprpc.Loop.GetLiquidityParamsRequest.class, looprpc.Loop.GetLiquidityParamsRequest.Builder.class);
      }

      // Construct using looprpc.Loop.GetLiquidityParamsRequest.newBuilder()
      private Builder() {

      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);

      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return looprpc.Loop.internal_static_looprpc_GetLiquidityParamsRequest_descriptor;
      }

      @java.lang.Override
      public looprpc.Loop.GetLiquidityParamsRequest getDefaultInstanceForType() {
        return looprpc.Loop.GetLiquidityParamsRequest.getDefaultInstance();
      }

      @java.lang.Override
      public looprpc.Loop.GetLiquidityParamsRequest build() {
        looprpc.Loop.GetLiquidityParamsRequest result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public looprpc.Loop.GetLiquidityParamsRequest buildPartial() {
        looprpc.Loop.GetLiquidityParamsRequest result = new looprpc.Loop.GetLiquidityParamsRequest(this);
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof looprpc.Loop.GetLiquidityParamsRequest) {
          return mergeFrom((looprpc.Loop.GetLiquidityParamsRequest)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(looprpc.Loop.GetLiquidityParamsRequest other) {
        if (other == looprpc.Loop.GetLiquidityParamsRequest.getDefaultInstance()) return this;
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:looprpc.GetLiquidityParamsRequest)
    }

    // @@protoc_insertion_point(class_scope:looprpc.GetLiquidityParamsRequest)
    private static final looprpc.Loop.GetLiquidityParamsRequest DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new looprpc.Loop.GetLiquidityParamsRequest();
    }

    public static looprpc.Loop.GetLiquidityParamsRequest getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<GetLiquidityParamsRequest>
        PARSER = new com.google.protobuf.AbstractParser<GetLiquidityParamsRequest>() {
      @java.lang.Override
      public GetLiquidityParamsRequest parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<GetLiquidityParamsRequest> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<GetLiquidityParamsRequest> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public looprpc.Loop.GetLiquidityParamsRequest getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface LiquidityParametersOrBuilder extends
      // @@protoc_insertion_point(interface_extends:looprpc.LiquidityParameters)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     *
     *A set of liquidity rules that describe the desired liquidity balance.
     * </pre>
     *
     * <code>repeated .looprpc.LiquidityRule rules = 1;</code>
     */
    java.util.List<looprpc.Loop.LiquidityRule> 
        getRulesList();
    /**
     * <pre>
     *
     *A set of liquidity rules that describe the desired liquidity balance.
     * </pre>
     *
     * <code>repeated .looprpc.LiquidityRule rules = 1;</code>
     */
    looprpc.Loop.LiquidityRule getRules(int index);
    /**
     * <pre>
     *
     *A set of liquidity rules that describe the desired liquidity balance.
     * </pre>
     *
     * <code>repeated .looprpc.LiquidityRule rules = 1;</code>
     */
    int getRulesCount();
    /**
     * <pre>
     *
     *A set of liquidity rules that describe the desired liquidity balance.
     * </pre>
     *
     * <code>repeated .looprpc.LiquidityRule rules = 1;</code>
     */
    java.util.List<? extends looprpc.Loop.LiquidityRuleOrBuilder> 
        getRulesOrBuilderList();
    /**
     * <pre>
     *
     *A set of liquidity rules that describe the desired liquidity balance.
     * </pre>
     *
     * <code>repeated .looprpc.LiquidityRule rules = 1;</code>
     */
    looprpc.Loop.LiquidityRuleOrBuilder getRulesOrBuilder(
        int index);

    /**
     * <pre>
     *
     *The parts per million of swap amount that is allowed to be allocated to swap
     *fees. This value is applied across swap categories and may not be set in
     *conjunction with sweep fee rate, swap fee ppm, routing fee ppm, prepay
     *routing, max prepay and max miner fee.
     * </pre>
     *
     * <code>uint64 fee_ppm = 16 [jstype = JS_STRING];</code>
     * @return The feePpm.
     */
    long getFeePpm();

    /**
     * <pre>
     *
     *The limit we place on our estimated sweep cost for a swap in sat/vByte. If
     *the estimated fee for our sweep transaction within the specified
     *confirmation target is above this value, we will not suggest any swaps.
     * </pre>
     *
     * <code>uint64 sweep_fee_rate_sat_per_vbyte = 2 [jstype = JS_STRING];</code>
     * @return The sweepFeeRateSatPerVbyte.
     */
    long getSweepFeeRateSatPerVbyte();

    /**
     * <pre>
     *
     *The maximum fee paid to the server for facilitating the swap, expressed
     *as parts per million of the swap volume.
     * </pre>
     *
     * <code>uint64 max_swap_fee_ppm = 3 [jstype = JS_STRING];</code>
     * @return The maxSwapFeePpm.
     */
    long getMaxSwapFeePpm();

    /**
     * <pre>
     *
     *The maximum fee paid to route the swap invoice off chain, expressed as
     *parts per million of the volume being routed.
     * </pre>
     *
     * <code>uint64 max_routing_fee_ppm = 4 [jstype = JS_STRING];</code>
     * @return The maxRoutingFeePpm.
     */
    long getMaxRoutingFeePpm();

    /**
     * <pre>
     *
     *The maximum fee paid to route the prepay invoice off chain, expressed as
     *parts per million of the volume being routed.
     * </pre>
     *
     * <code>uint64 max_prepay_routing_fee_ppm = 5 [jstype = JS_STRING];</code>
     * @return The maxPrepayRoutingFeePpm.
     */
    long getMaxPrepayRoutingFeePpm();

    /**
     * <pre>
     *
     *The maximum no-show penalty in satoshis paid for a swap.
     * </pre>
     *
     * <code>uint64 max_prepay_sat = 6 [jstype = JS_STRING];</code>
     * @return The maxPrepaySat.
     */
    long getMaxPrepaySat();

    /**
     * <pre>
     *
     *The maximum miner fee we will pay to sweep the swap on chain. Note that we
     *will not suggest a swap if the estimate is above the sweep limit set by
     *these parameters, and we use the current fee estimate to sweep on chain so
     *this value is only a cap placed on the amount we spend on fees in the case
     *where the swap needs to be claimed on chain, but fees have suddenly spiked.
     * </pre>
     *
     * <code>uint64 max_miner_fee_sat = 7 [jstype = JS_STRING];</code>
     * @return The maxMinerFeeSat.
     */
    long getMaxMinerFeeSat();

    /**
     * <pre>
     *
     *The number of blocks from the on-chain HTLC's confirmation height that it
     *should be swept within.
     * </pre>
     *
     * <code>int32 sweep_conf_target = 8;</code>
     * @return The sweepConfTarget.
     */
    int getSweepConfTarget();

    /**
     * <pre>
     *
     *The amount of time we require pass since a channel was part of a failed
     *swap due to off chain payment failure until it will be considered for swap
     *suggestions again, expressed in seconds.
     * </pre>
     *
     * <code>uint64 failure_backoff_sec = 9 [jstype = JS_STRING];</code>
     * @return The failureBackoffSec.
     */
    long getFailureBackoffSec();

    /**
     * <pre>
     *
     *Set to true to enable automatic dispatch of swaps. All swaps will be limited
     *to the fee categories set by these parameters, and total expenditure will
     *be limited to the autoloop budget.
     * </pre>
     *
     * <code>bool autoloop = 10;</code>
     * @return The autoloop.
     */
    boolean getAutoloop();

    /**
     * <pre>
     *
     *The total budget for automatically dispatched swaps since the budget start
     *time, expressed in satoshis.
     * </pre>
     *
     * <code>uint64 autoloop_budget_sat = 11 [jstype = JS_STRING];</code>
     * @return The autoloopBudgetSat.
     */
    long getAutoloopBudgetSat();

    /**
     * <pre>
     *
     *Deprecated, use autoloop_budget_refresh_period_sec. The start time for
     *autoloop budget, expressed as a unix timestamp in seconds. If this value is
     *0, the budget will be applied for all automatically dispatched swaps. Swaps
     *that were completed before this date will not be included in budget
     *calculations.
     * </pre>
     *
     * <code>uint64 autoloop_budget_start_sec = 12 [deprecated = true, jstype = JS_STRING];</code>
     * @deprecated looprpc.LiquidityParameters.autoloop_budget_start_sec is deprecated.
     *     See loop.proto;l=937
     * @return The autoloopBudgetStartSec.
     */
    @java.lang.Deprecated long getAutoloopBudgetStartSec();

    /**
     * <pre>
     *
     *The maximum number of automatically dispatched swaps that we allow to be in
     *flight at any point in time.
     * </pre>
     *
     * <code>uint64 auto_max_in_flight = 13 [jstype = JS_STRING];</code>
     * @return The autoMaxInFlight.
     */
    long getAutoMaxInFlight();

    /**
     * <pre>
     *
     *The minimum amount, expressed in satoshis, that the autoloop client will
     *dispatch a swap for. This value is subject to the server-side limits
     *specified by the LoopOutTerms endpoint.
     * </pre>
     *
     * <code>uint64 min_swap_amount = 14 [jstype = JS_STRING];</code>
     * @return The minSwapAmount.
     */
    long getMinSwapAmount();

    /**
     * <pre>
     *
     *The maximum amount, expressed in satoshis, that the autoloop client will
     *dispatch a swap for. This value is subject to the server-side limits
     *specified by the LoopOutTerms endpoint.
     * </pre>
     *
     * <code>uint64 max_swap_amount = 15 [jstype = JS_STRING];</code>
     * @return The maxSwapAmount.
     */
    long getMaxSwapAmount();

    /**
     * <pre>
     *
     *The confirmation target for loop in on-chain htlcs.
     * </pre>
     *
     * <code>int32 htlc_conf_target = 17;</code>
     * @return The htlcConfTarget.
     */
    int getHtlcConfTarget();

    /**
     * <pre>
     *
     *The destination address to use for autoloop loop outs. Set to "default" in
     *order to revert to default behavior.
     * </pre>
     *
     * <code>string autoloop_dest_address = 18;</code>
     * @return The autoloopDestAddress.
     */
    java.lang.String getAutoloopDestAddress();
    /**
     * <pre>
     *
     *The destination address to use for autoloop loop outs. Set to "default" in
     *order to revert to default behavior.
     * </pre>
     *
     * <code>string autoloop_dest_address = 18;</code>
     * @return The bytes for autoloopDestAddress.
     */
    com.google.protobuf.ByteString
        getAutoloopDestAddressBytes();

    /**
     * <pre>
     *
     *The period over which the autoloop budget is refreshed, expressed in
     *seconds.
     * </pre>
     *
     * <code>uint64 autoloop_budget_refresh_period_sec = 19 [jstype = JS_STRING];</code>
     * @return The autoloopBudgetRefreshPeriodSec.
     */
    long getAutoloopBudgetRefreshPeriodSec();

    /**
     * <pre>
     *
     *The time at which the autoloop budget was last refreshed, expressed as a
     *UNIX timestamp in seconds.
     * </pre>
     *
     * <code>uint64 autoloop_budget_last_refresh = 20 [jstype = JS_STRING];</code>
     * @return The autoloopBudgetLastRefresh.
     */
    long getAutoloopBudgetLastRefresh();

    /**
     * <pre>
     *
     *Set to true to enable easy autoloop. If set, all channel/peer rules will be
     *overridden and the client will automatically dispatch swaps in order to meet
     *the configured local balance target size. Currently only loop out is
     *supported, meaning that easy autoloop can only reduce the funds that are
     *held as balance in channels.
     * </pre>
     *
     * <code>bool easy_autoloop = 21;</code>
     * @return The easyAutoloop.
     */
    boolean getEasyAutoloop();

    /**
     * <pre>
     *
     *The local balance target size, expressed in satoshis. This is used by easy
     *autoloop to determine how much liquidity should be maintained in channels.
     * </pre>
     *
     * <code>uint64 easy_autoloop_local_target_sat = 22 [jstype = JS_STRING];</code>
     * @return The easyAutoloopLocalTargetSat.
     */
    long getEasyAutoloopLocalTargetSat();

    /**
     * <pre>
     *
     *An alternative destination address source for the swap. This field
     *represents the name of the account in the backing lnd instance.
     *Refer to lnd's wallet import functions for reference.
     * </pre>
     *
     * <code>string account = 23;</code>
     * @return The account.
     */
    java.lang.String getAccount();
    /**
     * <pre>
     *
     *An alternative destination address source for the swap. This field
     *represents the name of the account in the backing lnd instance.
     *Refer to lnd's wallet import functions for reference.
     * </pre>
     *
     * <code>string account = 23;</code>
     * @return The bytes for account.
     */
    com.google.protobuf.ByteString
        getAccountBytes();

    /**
     * <pre>
     *
     *The address type of the account specified in the account field.
     * </pre>
     *
     * <code>.looprpc.AddressType account_addr_type = 24;</code>
     * @return The enum numeric value on the wire for accountAddrType.
     */
    int getAccountAddrTypeValue();
    /**
     * <pre>
     *
     *The address type of the account specified in the account field.
     * </pre>
     *
     * <code>.looprpc.AddressType account_addr_type = 24;</code>
     * @return The accountAddrType.
     */
    looprpc.Loop.AddressType getAccountAddrType();
  }
  /**
   * Protobuf type {@code looprpc.LiquidityParameters}
   */
  public static final class LiquidityParameters extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:looprpc.LiquidityParameters)
      LiquidityParametersOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use LiquidityParameters.newBuilder() to construct.
    private LiquidityParameters(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private LiquidityParameters() {
      rules_ = java.util.Collections.emptyList();
      autoloopDestAddress_ = "";
      account_ = "";
      accountAddrType_ = 0;
    }

    @java.lang.Override
    @SuppressWarnings({"unused"})
    protected java.lang.Object newInstance(
        UnusedPrivateParameter unused) {
      return new LiquidityParameters();
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return looprpc.Loop.internal_static_looprpc_LiquidityParameters_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return looprpc.Loop.internal_static_looprpc_LiquidityParameters_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              looprpc.Loop.LiquidityParameters.class, looprpc.Loop.LiquidityParameters.Builder.class);
    }

    public static final int RULES_FIELD_NUMBER = 1;
    @SuppressWarnings("serial")
    private java.util.List<looprpc.Loop.LiquidityRule> rules_;
    /**
     * <pre>
     *
     *A set of liquidity rules that describe the desired liquidity balance.
     * </pre>
     *
     * <code>repeated .looprpc.LiquidityRule rules = 1;</code>
     */
    @java.lang.Override
    public java.util.List<looprpc.Loop.LiquidityRule> getRulesList() {
      return rules_;
    }
    /**
     * <pre>
     *
     *A set of liquidity rules that describe the desired liquidity balance.
     * </pre>
     *
     * <code>repeated .looprpc.LiquidityRule rules = 1;</code>
     */
    @java.lang.Override
    public java.util.List<? extends looprpc.Loop.LiquidityRuleOrBuilder> 
        getRulesOrBuilderList() {
      return rules_;
    }
    /**
     * <pre>
     *
     *A set of liquidity rules that describe the desired liquidity balance.
     * </pre>
     *
     * <code>repeated .looprpc.LiquidityRule rules = 1;</code>
     */
    @java.lang.Override
    public int getRulesCount() {
      return rules_.size();
    }
    /**
     * <pre>
     *
     *A set of liquidity rules that describe the desired liquidity balance.
     * </pre>
     *
     * <code>repeated .looprpc.LiquidityRule rules = 1;</code>
     */
    @java.lang.Override
    public looprpc.Loop.LiquidityRule getRules(int index) {
      return rules_.get(index);
    }
    /**
     * <pre>
     *
     *A set of liquidity rules that describe the desired liquidity balance.
     * </pre>
     *
     * <code>repeated .looprpc.LiquidityRule rules = 1;</code>
     */
    @java.lang.Override
    public looprpc.Loop.LiquidityRuleOrBuilder getRulesOrBuilder(
        int index) {
      return rules_.get(index);
    }

    public static final int FEE_PPM_FIELD_NUMBER = 16;
    private long feePpm_ = 0L;
    /**
     * <pre>
     *
     *The parts per million of swap amount that is allowed to be allocated to swap
     *fees. This value is applied across swap categories and may not be set in
     *conjunction with sweep fee rate, swap fee ppm, routing fee ppm, prepay
     *routing, max prepay and max miner fee.
     * </pre>
     *
     * <code>uint64 fee_ppm = 16 [jstype = JS_STRING];</code>
     * @return The feePpm.
     */
    @java.lang.Override
    public long getFeePpm() {
      return feePpm_;
    }

    public static final int SWEEP_FEE_RATE_SAT_PER_VBYTE_FIELD_NUMBER = 2;
    private long sweepFeeRateSatPerVbyte_ = 0L;
    /**
     * <pre>
     *
     *The limit we place on our estimated sweep cost for a swap in sat/vByte. If
     *the estimated fee for our sweep transaction within the specified
     *confirmation target is above this value, we will not suggest any swaps.
     * </pre>
     *
     * <code>uint64 sweep_fee_rate_sat_per_vbyte = 2 [jstype = JS_STRING];</code>
     * @return The sweepFeeRateSatPerVbyte.
     */
    @java.lang.Override
    public long getSweepFeeRateSatPerVbyte() {
      return sweepFeeRateSatPerVbyte_;
    }

    public static final int MAX_SWAP_FEE_PPM_FIELD_NUMBER = 3;
    private long maxSwapFeePpm_ = 0L;
    /**
     * <pre>
     *
     *The maximum fee paid to the server for facilitating the swap, expressed
     *as parts per million of the swap volume.
     * </pre>
     *
     * <code>uint64 max_swap_fee_ppm = 3 [jstype = JS_STRING];</code>
     * @return The maxSwapFeePpm.
     */
    @java.lang.Override
    public long getMaxSwapFeePpm() {
      return maxSwapFeePpm_;
    }

    public static final int MAX_ROUTING_FEE_PPM_FIELD_NUMBER = 4;
    private long maxRoutingFeePpm_ = 0L;
    /**
     * <pre>
     *
     *The maximum fee paid to route the swap invoice off chain, expressed as
     *parts per million of the volume being routed.
     * </pre>
     *
     * <code>uint64 max_routing_fee_ppm = 4 [jstype = JS_STRING];</code>
     * @return The maxRoutingFeePpm.
     */
    @java.lang.Override
    public long getMaxRoutingFeePpm() {
      return maxRoutingFeePpm_;
    }

    public static final int MAX_PREPAY_ROUTING_FEE_PPM_FIELD_NUMBER = 5;
    private long maxPrepayRoutingFeePpm_ = 0L;
    /**
     * <pre>
     *
     *The maximum fee paid to route the prepay invoice off chain, expressed as
     *parts per million of the volume being routed.
     * </pre>
     *
     * <code>uint64 max_prepay_routing_fee_ppm = 5 [jstype = JS_STRING];</code>
     * @return The maxPrepayRoutingFeePpm.
     */
    @java.lang.Override
    public long getMaxPrepayRoutingFeePpm() {
      return maxPrepayRoutingFeePpm_;
    }

    public static final int MAX_PREPAY_SAT_FIELD_NUMBER = 6;
    private long maxPrepaySat_ = 0L;
    /**
     * <pre>
     *
     *The maximum no-show penalty in satoshis paid for a swap.
     * </pre>
     *
     * <code>uint64 max_prepay_sat = 6 [jstype = JS_STRING];</code>
     * @return The maxPrepaySat.
     */
    @java.lang.Override
    public long getMaxPrepaySat() {
      return maxPrepaySat_;
    }

    public static final int MAX_MINER_FEE_SAT_FIELD_NUMBER = 7;
    private long maxMinerFeeSat_ = 0L;
    /**
     * <pre>
     *
     *The maximum miner fee we will pay to sweep the swap on chain. Note that we
     *will not suggest a swap if the estimate is above the sweep limit set by
     *these parameters, and we use the current fee estimate to sweep on chain so
     *this value is only a cap placed on the amount we spend on fees in the case
     *where the swap needs to be claimed on chain, but fees have suddenly spiked.
     * </pre>
     *
     * <code>uint64 max_miner_fee_sat = 7 [jstype = JS_STRING];</code>
     * @return The maxMinerFeeSat.
     */
    @java.lang.Override
    public long getMaxMinerFeeSat() {
      return maxMinerFeeSat_;
    }

    public static final int SWEEP_CONF_TARGET_FIELD_NUMBER = 8;
    private int sweepConfTarget_ = 0;
    /**
     * <pre>
     *
     *The number of blocks from the on-chain HTLC's confirmation height that it
     *should be swept within.
     * </pre>
     *
     * <code>int32 sweep_conf_target = 8;</code>
     * @return The sweepConfTarget.
     */
    @java.lang.Override
    public int getSweepConfTarget() {
      return sweepConfTarget_;
    }

    public static final int FAILURE_BACKOFF_SEC_FIELD_NUMBER = 9;
    private long failureBackoffSec_ = 0L;
    /**
     * <pre>
     *
     *The amount of time we require pass since a channel was part of a failed
     *swap due to off chain payment failure until it will be considered for swap
     *suggestions again, expressed in seconds.
     * </pre>
     *
     * <code>uint64 failure_backoff_sec = 9 [jstype = JS_STRING];</code>
     * @return The failureBackoffSec.
     */
    @java.lang.Override
    public long getFailureBackoffSec() {
      return failureBackoffSec_;
    }

    public static final int AUTOLOOP_FIELD_NUMBER = 10;
    private boolean autoloop_ = false;
    /**
     * <pre>
     *
     *Set to true to enable automatic dispatch of swaps. All swaps will be limited
     *to the fee categories set by these parameters, and total expenditure will
     *be limited to the autoloop budget.
     * </pre>
     *
     * <code>bool autoloop = 10;</code>
     * @return The autoloop.
     */
    @java.lang.Override
    public boolean getAutoloop() {
      return autoloop_;
    }

    public static final int AUTOLOOP_BUDGET_SAT_FIELD_NUMBER = 11;
    private long autoloopBudgetSat_ = 0L;
    /**
     * <pre>
     *
     *The total budget for automatically dispatched swaps since the budget start
     *time, expressed in satoshis.
     * </pre>
     *
     * <code>uint64 autoloop_budget_sat = 11 [jstype = JS_STRING];</code>
     * @return The autoloopBudgetSat.
     */
    @java.lang.Override
    public long getAutoloopBudgetSat() {
      return autoloopBudgetSat_;
    }

    public static final int AUTOLOOP_BUDGET_START_SEC_FIELD_NUMBER = 12;
    private long autoloopBudgetStartSec_ = 0L;
    /**
     * <pre>
     *
     *Deprecated, use autoloop_budget_refresh_period_sec. The start time for
     *autoloop budget, expressed as a unix timestamp in seconds. If this value is
     *0, the budget will be applied for all automatically dispatched swaps. Swaps
     *that were completed before this date will not be included in budget
     *calculations.
     * </pre>
     *
     * <code>uint64 autoloop_budget_start_sec = 12 [deprecated = true, jstype = JS_STRING];</code>
     * @deprecated looprpc.LiquidityParameters.autoloop_budget_start_sec is deprecated.
     *     See loop.proto;l=937
     * @return The autoloopBudgetStartSec.
     */
    @java.lang.Override
    @java.lang.Deprecated public long getAutoloopBudgetStartSec() {
      return autoloopBudgetStartSec_;
    }

    public static final int AUTO_MAX_IN_FLIGHT_FIELD_NUMBER = 13;
    private long autoMaxInFlight_ = 0L;
    /**
     * <pre>
     *
     *The maximum number of automatically dispatched swaps that we allow to be in
     *flight at any point in time.
     * </pre>
     *
     * <code>uint64 auto_max_in_flight = 13 [jstype = JS_STRING];</code>
     * @return The autoMaxInFlight.
     */
    @java.lang.Override
    public long getAutoMaxInFlight() {
      return autoMaxInFlight_;
    }

    public static final int MIN_SWAP_AMOUNT_FIELD_NUMBER = 14;
    private long minSwapAmount_ = 0L;
    /**
     * <pre>
     *
     *The minimum amount, expressed in satoshis, that the autoloop client will
     *dispatch a swap for. This value is subject to the server-side limits
     *specified by the LoopOutTerms endpoint.
     * </pre>
     *
     * <code>uint64 min_swap_amount = 14 [jstype = JS_STRING];</code>
     * @return The minSwapAmount.
     */
    @java.lang.Override
    public long getMinSwapAmount() {
      return minSwapAmount_;
    }

    public static final int MAX_SWAP_AMOUNT_FIELD_NUMBER = 15;
    private long maxSwapAmount_ = 0L;
    /**
     * <pre>
     *
     *The maximum amount, expressed in satoshis, that the autoloop client will
     *dispatch a swap for. This value is subject to the server-side limits
     *specified by the LoopOutTerms endpoint.
     * </pre>
     *
     * <code>uint64 max_swap_amount = 15 [jstype = JS_STRING];</code>
     * @return The maxSwapAmount.
     */
    @java.lang.Override
    public long getMaxSwapAmount() {
      return maxSwapAmount_;
    }

    public static final int HTLC_CONF_TARGET_FIELD_NUMBER = 17;
    private int htlcConfTarget_ = 0;
    /**
     * <pre>
     *
     *The confirmation target for loop in on-chain htlcs.
     * </pre>
     *
     * <code>int32 htlc_conf_target = 17;</code>
     * @return The htlcConfTarget.
     */
    @java.lang.Override
    public int getHtlcConfTarget() {
      return htlcConfTarget_;
    }

    public static final int AUTOLOOP_DEST_ADDRESS_FIELD_NUMBER = 18;
    @SuppressWarnings("serial")
    private volatile java.lang.Object autoloopDestAddress_ = "";
    /**
     * <pre>
     *
     *The destination address to use for autoloop loop outs. Set to "default" in
     *order to revert to default behavior.
     * </pre>
     *
     * <code>string autoloop_dest_address = 18;</code>
     * @return The autoloopDestAddress.
     */
    @java.lang.Override
    public java.lang.String getAutoloopDestAddress() {
      java.lang.Object ref = autoloopDestAddress_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        autoloopDestAddress_ = s;
        return s;
      }
    }
    /**
     * <pre>
     *
     *The destination address to use for autoloop loop outs. Set to "default" in
     *order to revert to default behavior.
     * </pre>
     *
     * <code>string autoloop_dest_address = 18;</code>
     * @return The bytes for autoloopDestAddress.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getAutoloopDestAddressBytes() {
      java.lang.Object ref = autoloopDestAddress_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        autoloopDestAddress_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int AUTOLOOP_BUDGET_REFRESH_PERIOD_SEC_FIELD_NUMBER = 19;
    private long autoloopBudgetRefreshPeriodSec_ = 0L;
    /**
     * <pre>
     *
     *The period over which the autoloop budget is refreshed, expressed in
     *seconds.
     * </pre>
     *
     * <code>uint64 autoloop_budget_refresh_period_sec = 19 [jstype = JS_STRING];</code>
     * @return The autoloopBudgetRefreshPeriodSec.
     */
    @java.lang.Override
    public long getAutoloopBudgetRefreshPeriodSec() {
      return autoloopBudgetRefreshPeriodSec_;
    }

    public static final int AUTOLOOP_BUDGET_LAST_REFRESH_FIELD_NUMBER = 20;
    private long autoloopBudgetLastRefresh_ = 0L;
    /**
     * <pre>
     *
     *The time at which the autoloop budget was last refreshed, expressed as a
     *UNIX timestamp in seconds.
     * </pre>
     *
     * <code>uint64 autoloop_budget_last_refresh = 20 [jstype = JS_STRING];</code>
     * @return The autoloopBudgetLastRefresh.
     */
    @java.lang.Override
    public long getAutoloopBudgetLastRefresh() {
      return autoloopBudgetLastRefresh_;
    }

    public static final int EASY_AUTOLOOP_FIELD_NUMBER = 21;
    private boolean easyAutoloop_ = false;
    /**
     * <pre>
     *
     *Set to true to enable easy autoloop. If set, all channel/peer rules will be
     *overridden and the client will automatically dispatch swaps in order to meet
     *the configured local balance target size. Currently only loop out is
     *supported, meaning that easy autoloop can only reduce the funds that are
     *held as balance in channels.
     * </pre>
     *
     * <code>bool easy_autoloop = 21;</code>
     * @return The easyAutoloop.
     */
    @java.lang.Override
    public boolean getEasyAutoloop() {
      return easyAutoloop_;
    }

    public static final int EASY_AUTOLOOP_LOCAL_TARGET_SAT_FIELD_NUMBER = 22;
    private long easyAutoloopLocalTargetSat_ = 0L;
    /**
     * <pre>
     *
     *The local balance target size, expressed in satoshis. This is used by easy
     *autoloop to determine how much liquidity should be maintained in channels.
     * </pre>
     *
     * <code>uint64 easy_autoloop_local_target_sat = 22 [jstype = JS_STRING];</code>
     * @return The easyAutoloopLocalTargetSat.
     */
    @java.lang.Override
    public long getEasyAutoloopLocalTargetSat() {
      return easyAutoloopLocalTargetSat_;
    }

    public static final int ACCOUNT_FIELD_NUMBER = 23;
    @SuppressWarnings("serial")
    private volatile java.lang.Object account_ = "";
    /**
     * <pre>
     *
     *An alternative destination address source for the swap. This field
     *represents the name of the account in the backing lnd instance.
     *Refer to lnd's wallet import functions for reference.
     * </pre>
     *
     * <code>string account = 23;</code>
     * @return The account.
     */
    @java.lang.Override
    public java.lang.String getAccount() {
      java.lang.Object ref = account_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        account_ = s;
        return s;
      }
    }
    /**
     * <pre>
     *
     *An alternative destination address source for the swap. This field
     *represents the name of the account in the backing lnd instance.
     *Refer to lnd's wallet import functions for reference.
     * </pre>
     *
     * <code>string account = 23;</code>
     * @return The bytes for account.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getAccountBytes() {
      java.lang.Object ref = account_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        account_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int ACCOUNT_ADDR_TYPE_FIELD_NUMBER = 24;
    private int accountAddrType_ = 0;
    /**
     * <pre>
     *
     *The address type of the account specified in the account field.
     * </pre>
     *
     * <code>.looprpc.AddressType account_addr_type = 24;</code>
     * @return The enum numeric value on the wire for accountAddrType.
     */
    @java.lang.Override public int getAccountAddrTypeValue() {
      return accountAddrType_;
    }
    /**
     * <pre>
     *
     *The address type of the account specified in the account field.
     * </pre>
     *
     * <code>.looprpc.AddressType account_addr_type = 24;</code>
     * @return The accountAddrType.
     */
    @java.lang.Override public looprpc.Loop.AddressType getAccountAddrType() {
      looprpc.Loop.AddressType result = looprpc.Loop.AddressType.forNumber(accountAddrType_);
      return result == null ? looprpc.Loop.AddressType.UNRECOGNIZED : result;
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      for (int i = 0; i < rules_.size(); i++) {
        output.writeMessage(1, rules_.get(i));
      }
      if (sweepFeeRateSatPerVbyte_ != 0L) {
        output.writeUInt64(2, sweepFeeRateSatPerVbyte_);
      }
      if (maxSwapFeePpm_ != 0L) {
        output.writeUInt64(3, maxSwapFeePpm_);
      }
      if (maxRoutingFeePpm_ != 0L) {
        output.writeUInt64(4, maxRoutingFeePpm_);
      }
      if (maxPrepayRoutingFeePpm_ != 0L) {
        output.writeUInt64(5, maxPrepayRoutingFeePpm_);
      }
      if (maxPrepaySat_ != 0L) {
        output.writeUInt64(6, maxPrepaySat_);
      }
      if (maxMinerFeeSat_ != 0L) {
        output.writeUInt64(7, maxMinerFeeSat_);
      }
      if (sweepConfTarget_ != 0) {
        output.writeInt32(8, sweepConfTarget_);
      }
      if (failureBackoffSec_ != 0L) {
        output.writeUInt64(9, failureBackoffSec_);
      }
      if (autoloop_ != false) {
        output.writeBool(10, autoloop_);
      }
      if (autoloopBudgetSat_ != 0L) {
        output.writeUInt64(11, autoloopBudgetSat_);
      }
      if (autoloopBudgetStartSec_ != 0L) {
        output.writeUInt64(12, autoloopBudgetStartSec_);
      }
      if (autoMaxInFlight_ != 0L) {
        output.writeUInt64(13, autoMaxInFlight_);
      }
      if (minSwapAmount_ != 0L) {
        output.writeUInt64(14, minSwapAmount_);
      }
      if (maxSwapAmount_ != 0L) {
        output.writeUInt64(15, maxSwapAmount_);
      }
      if (feePpm_ != 0L) {
        output.writeUInt64(16, feePpm_);
      }
      if (htlcConfTarget_ != 0) {
        output.writeInt32(17, htlcConfTarget_);
      }
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(autoloopDestAddress_)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 18, autoloopDestAddress_);
      }
      if (autoloopBudgetRefreshPeriodSec_ != 0L) {
        output.writeUInt64(19, autoloopBudgetRefreshPeriodSec_);
      }
      if (autoloopBudgetLastRefresh_ != 0L) {
        output.writeUInt64(20, autoloopBudgetLastRefresh_);
      }
      if (easyAutoloop_ != false) {
        output.writeBool(21, easyAutoloop_);
      }
      if (easyAutoloopLocalTargetSat_ != 0L) {
        output.writeUInt64(22, easyAutoloopLocalTargetSat_);
      }
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(account_)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 23, account_);
      }
      if (accountAddrType_ != looprpc.Loop.AddressType.ADDRESS_TYPE_UNKNOWN.getNumber()) {
        output.writeEnum(24, accountAddrType_);
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      for (int i = 0; i < rules_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(1, rules_.get(i));
      }
      if (sweepFeeRateSatPerVbyte_ != 0L) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt64Size(2, sweepFeeRateSatPerVbyte_);
      }
      if (maxSwapFeePpm_ != 0L) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt64Size(3, maxSwapFeePpm_);
      }
      if (maxRoutingFeePpm_ != 0L) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt64Size(4, maxRoutingFeePpm_);
      }
      if (maxPrepayRoutingFeePpm_ != 0L) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt64Size(5, maxPrepayRoutingFeePpm_);
      }
      if (maxPrepaySat_ != 0L) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt64Size(6, maxPrepaySat_);
      }
      if (maxMinerFeeSat_ != 0L) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt64Size(7, maxMinerFeeSat_);
      }
      if (sweepConfTarget_ != 0) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt32Size(8, sweepConfTarget_);
      }
      if (failureBackoffSec_ != 0L) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt64Size(9, failureBackoffSec_);
      }
      if (autoloop_ != false) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(10, autoloop_);
      }
      if (autoloopBudgetSat_ != 0L) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt64Size(11, autoloopBudgetSat_);
      }
      if (autoloopBudgetStartSec_ != 0L) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt64Size(12, autoloopBudgetStartSec_);
      }
      if (autoMaxInFlight_ != 0L) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt64Size(13, autoMaxInFlight_);
      }
      if (minSwapAmount_ != 0L) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt64Size(14, minSwapAmount_);
      }
      if (maxSwapAmount_ != 0L) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt64Size(15, maxSwapAmount_);
      }
      if (feePpm_ != 0L) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt64Size(16, feePpm_);
      }
      if (htlcConfTarget_ != 0) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt32Size(17, htlcConfTarget_);
      }
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(autoloopDestAddress_)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(18, autoloopDestAddress_);
      }
      if (autoloopBudgetRefreshPeriodSec_ != 0L) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt64Size(19, autoloopBudgetRefreshPeriodSec_);
      }
      if (autoloopBudgetLastRefresh_ != 0L) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt64Size(20, autoloopBudgetLastRefresh_);
      }
      if (easyAutoloop_ != false) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(21, easyAutoloop_);
      }
      if (easyAutoloopLocalTargetSat_ != 0L) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt64Size(22, easyAutoloopLocalTargetSat_);
      }
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(account_)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(23, account_);
      }
      if (accountAddrType_ != looprpc.Loop.AddressType.ADDRESS_TYPE_UNKNOWN.getNumber()) {
        size += com.google.protobuf.CodedOutputStream
          .computeEnumSize(24, accountAddrType_);
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof looprpc.Loop.LiquidityParameters)) {
        return super.equals(obj);
      }
      looprpc.Loop.LiquidityParameters other = (looprpc.Loop.LiquidityParameters) obj;

      if (!getRulesList()
          .equals(other.getRulesList())) return false;
      if (getFeePpm()
          != other.getFeePpm()) return false;
      if (getSweepFeeRateSatPerVbyte()
          != other.getSweepFeeRateSatPerVbyte()) return false;
      if (getMaxSwapFeePpm()
          != other.getMaxSwapFeePpm()) return false;
      if (getMaxRoutingFeePpm()
          != other.getMaxRoutingFeePpm()) return false;
      if (getMaxPrepayRoutingFeePpm()
          != other.getMaxPrepayRoutingFeePpm()) return false;
      if (getMaxPrepaySat()
          != other.getMaxPrepaySat()) return false;
      if (getMaxMinerFeeSat()
          != other.getMaxMinerFeeSat()) return false;
      if (getSweepConfTarget()
          != other.getSweepConfTarget()) return false;
      if (getFailureBackoffSec()
          != other.getFailureBackoffSec()) return false;
      if (getAutoloop()
          != other.getAutoloop()) return false;
      if (getAutoloopBudgetSat()
          != other.getAutoloopBudgetSat()) return false;
      if (getAutoloopBudgetStartSec()
          != other.getAutoloopBudgetStartSec()) return false;
      if (getAutoMaxInFlight()
          != other.getAutoMaxInFlight()) return false;
      if (getMinSwapAmount()
          != other.getMinSwapAmount()) return false;
      if (getMaxSwapAmount()
          != other.getMaxSwapAmount()) return false;
      if (getHtlcConfTarget()
          != other.getHtlcConfTarget()) return false;
      if (!getAutoloopDestAddress()
          .equals(other.getAutoloopDestAddress())) return false;
      if (getAutoloopBudgetRefreshPeriodSec()
          != other.getAutoloopBudgetRefreshPeriodSec()) return false;
      if (getAutoloopBudgetLastRefresh()
          != other.getAutoloopBudgetLastRefresh()) return false;
      if (getEasyAutoloop()
          != other.getEasyAutoloop()) return false;
      if (getEasyAutoloopLocalTargetSat()
          != other.getEasyAutoloopLocalTargetSat()) return false;
      if (!getAccount()
          .equals(other.getAccount())) return false;
      if (accountAddrType_ != other.accountAddrType_) return false;
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (getRulesCount() > 0) {
        hash = (37 * hash) + RULES_FIELD_NUMBER;
        hash = (53 * hash) + getRulesList().hashCode();
      }
      hash = (37 * hash) + FEE_PPM_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
          getFeePpm());
      hash = (37 * hash) + SWEEP_FEE_RATE_SAT_PER_VBYTE_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
          getSweepFeeRateSatPerVbyte());
      hash = (37 * hash) + MAX_SWAP_FEE_PPM_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
          getMaxSwapFeePpm());
      hash = (37 * hash) + MAX_ROUTING_FEE_PPM_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
          getMaxRoutingFeePpm());
      hash = (37 * hash) + MAX_PREPAY_ROUTING_FEE_PPM_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
          getMaxPrepayRoutingFeePpm());
      hash = (37 * hash) + MAX_PREPAY_SAT_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
          getMaxPrepaySat());
      hash = (37 * hash) + MAX_MINER_FEE_SAT_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
          getMaxMinerFeeSat());
      hash = (37 * hash) + SWEEP_CONF_TARGET_FIELD_NUMBER;
      hash = (53 * hash) + getSweepConfTarget();
      hash = (37 * hash) + FAILURE_BACKOFF_SEC_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
          getFailureBackoffSec());
      hash = (37 * hash) + AUTOLOOP_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
          getAutoloop());
      hash = (37 * hash) + AUTOLOOP_BUDGET_SAT_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
          getAutoloopBudgetSat());
      hash = (37 * hash) + AUTOLOOP_BUDGET_START_SEC_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
          getAutoloopBudgetStartSec());
      hash = (37 * hash) + AUTO_MAX_IN_FLIGHT_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
          getAutoMaxInFlight());
      hash = (37 * hash) + MIN_SWAP_AMOUNT_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
          getMinSwapAmount());
      hash = (37 * hash) + MAX_SWAP_AMOUNT_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
          getMaxSwapAmount());
      hash = (37 * hash) + HTLC_CONF_TARGET_FIELD_NUMBER;
      hash = (53 * hash) + getHtlcConfTarget();
      hash = (37 * hash) + AUTOLOOP_DEST_ADDRESS_FIELD_NUMBER;
      hash = (53 * hash) + getAutoloopDestAddress().hashCode();
      hash = (37 * hash) + AUTOLOOP_BUDGET_REFRESH_PERIOD_SEC_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
          getAutoloopBudgetRefreshPeriodSec());
      hash = (37 * hash) + AUTOLOOP_BUDGET_LAST_REFRESH_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
          getAutoloopBudgetLastRefresh());
      hash = (37 * hash) + EASY_AUTOLOOP_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
          getEasyAutoloop());
      hash = (37 * hash) + EASY_AUTOLOOP_LOCAL_TARGET_SAT_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
          getEasyAutoloopLocalTargetSat());
      hash = (37 * hash) + ACCOUNT_FIELD_NUMBER;
      hash = (53 * hash) + getAccount().hashCode();
      hash = (37 * hash) + ACCOUNT_ADDR_TYPE_FIELD_NUMBER;
      hash = (53 * hash) + accountAddrType_;
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static looprpc.Loop.LiquidityParameters parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static looprpc.Loop.LiquidityParameters parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static looprpc.Loop.LiquidityParameters parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static looprpc.Loop.LiquidityParameters parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static looprpc.Loop.LiquidityParameters parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static looprpc.Loop.LiquidityParameters parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static looprpc.Loop.LiquidityParameters parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static looprpc.Loop.LiquidityParameters parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static looprpc.Loop.LiquidityParameters parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static looprpc.Loop.LiquidityParameters parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static looprpc.Loop.LiquidityParameters parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static looprpc.Loop.LiquidityParameters parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(looprpc.Loop.LiquidityParameters prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * Protobuf type {@code looprpc.LiquidityParameters}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:looprpc.LiquidityParameters)
        looprpc.Loop.LiquidityParametersOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return looprpc.Loop.internal_static_looprpc_LiquidityParameters_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return looprpc.Loop.internal_static_looprpc_LiquidityParameters_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                looprpc.Loop.LiquidityParameters.class, looprpc.Loop.LiquidityParameters.Builder.class);
      }

      // Construct using looprpc.Loop.LiquidityParameters.newBuilder()
      private Builder() {

      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);

      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        if (rulesBuilder_ == null) {
          rules_ = java.util.Collections.emptyList();
        } else {
          rules_ = null;
          rulesBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000001);
        feePpm_ = 0L;
        sweepFeeRateSatPerVbyte_ = 0L;
        maxSwapFeePpm_ = 0L;
        maxRoutingFeePpm_ = 0L;
        maxPrepayRoutingFeePpm_ = 0L;
        maxPrepaySat_ = 0L;
        maxMinerFeeSat_ = 0L;
        sweepConfTarget_ = 0;
        failureBackoffSec_ = 0L;
        autoloop_ = false;
        autoloopBudgetSat_ = 0L;
        autoloopBudgetStartSec_ = 0L;
        autoMaxInFlight_ = 0L;
        minSwapAmount_ = 0L;
        maxSwapAmount_ = 0L;
        htlcConfTarget_ = 0;
        autoloopDestAddress_ = "";
        autoloopBudgetRefreshPeriodSec_ = 0L;
        autoloopBudgetLastRefresh_ = 0L;
        easyAutoloop_ = false;
        easyAutoloopLocalTargetSat_ = 0L;
        account_ = "";
        accountAddrType_ = 0;
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return looprpc.Loop.internal_static_looprpc_LiquidityParameters_descriptor;
      }

      @java.lang.Override
      public looprpc.Loop.LiquidityParameters getDefaultInstanceForType() {
        return looprpc.Loop.LiquidityParameters.getDefaultInstance();
      }

      @java.lang.Override
      public looprpc.Loop.LiquidityParameters build() {
        looprpc.Loop.LiquidityParameters result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public looprpc.Loop.LiquidityParameters buildPartial() {
        looprpc.Loop.LiquidityParameters result = new looprpc.Loop.LiquidityParameters(this);
        buildPartialRepeatedFields(result);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartialRepeatedFields(looprpc.Loop.LiquidityParameters result) {
        if (rulesBuilder_ == null) {
          if (((bitField0_ & 0x00000001) != 0)) {
            rules_ = java.util.Collections.unmodifiableList(rules_);
            bitField0_ = (bitField0_ & ~0x00000001);
          }
          result.rules_ = rules_;
        } else {
          result.rules_ = rulesBuilder_.build();
        }
      }

      private void buildPartial0(looprpc.Loop.LiquidityParameters result) {
        int from_bitField0_ = bitField0_;
        if (((from_bitField0_ & 0x00000002) != 0)) {
          result.feePpm_ = feePpm_;
        }
        if (((from_bitField0_ & 0x00000004) != 0)) {
          result.sweepFeeRateSatPerVbyte_ = sweepFeeRateSatPerVbyte_;
        }
        if (((from_bitField0_ & 0x00000008) != 0)) {
          result.maxSwapFeePpm_ = maxSwapFeePpm_;
        }
        if (((from_bitField0_ & 0x00000010) != 0)) {
          result.maxRoutingFeePpm_ = maxRoutingFeePpm_;
        }
        if (((from_bitField0_ & 0x00000020) != 0)) {
          result.maxPrepayRoutingFeePpm_ = maxPrepayRoutingFeePpm_;
        }
        if (((from_bitField0_ & 0x00000040) != 0)) {
          result.maxPrepaySat_ = maxPrepaySat_;
        }
        if (((from_bitField0_ & 0x00000080) != 0)) {
          result.maxMinerFeeSat_ = maxMinerFeeSat_;
        }
        if (((from_bitField0_ & 0x00000100) != 0)) {
          result.sweepConfTarget_ = sweepConfTarget_;
        }
        if (((from_bitField0_ & 0x00000200) != 0)) {
          result.failureBackoffSec_ = failureBackoffSec_;
        }
        if (((from_bitField0_ & 0x00000400) != 0)) {
          result.autoloop_ = autoloop_;
        }
        if (((from_bitField0_ & 0x00000800) != 0)) {
          result.autoloopBudgetSat_ = autoloopBudgetSat_;
        }
        if (((from_bitField0_ & 0x00001000) != 0)) {
          result.autoloopBudgetStartSec_ = autoloopBudgetStartSec_;
        }
        if (((from_bitField0_ & 0x00002000) != 0)) {
          result.autoMaxInFlight_ = autoMaxInFlight_;
        }
        if (((from_bitField0_ & 0x00004000) != 0)) {
          result.minSwapAmount_ = minSwapAmount_;
        }
        if (((from_bitField0_ & 0x00008000) != 0)) {
          result.maxSwapAmount_ = maxSwapAmount_;
        }
        if (((from_bitField0_ & 0x00010000) != 0)) {
          result.htlcConfTarget_ = htlcConfTarget_;
        }
        if (((from_bitField0_ & 0x00020000) != 0)) {
          result.autoloopDestAddress_ = autoloopDestAddress_;
        }
        if (((from_bitField0_ & 0x00040000) != 0)) {
          result.autoloopBudgetRefreshPeriodSec_ = autoloopBudgetRefreshPeriodSec_;
        }
        if (((from_bitField0_ & 0x00080000) != 0)) {
          result.autoloopBudgetLastRefresh_ = autoloopBudgetLastRefresh_;
        }
        if (((from_bitField0_ & 0x00100000) != 0)) {
          result.easyAutoloop_ = easyAutoloop_;
        }
        if (((from_bitField0_ & 0x00200000) != 0)) {
          result.easyAutoloopLocalTargetSat_ = easyAutoloopLocalTargetSat_;
        }
        if (((from_bitField0_ & 0x00400000) != 0)) {
          result.account_ = account_;
        }
        if (((from_bitField0_ & 0x00800000) != 0)) {
          result.accountAddrType_ = accountAddrType_;
        }
      }

      @java.lang.Override
      public Builder clone() {
        return super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof looprpc.Loop.LiquidityParameters) {
          return mergeFrom((looprpc.Loop.LiquidityParameters)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(looprpc.Loop.LiquidityParameters other) {
        if (other == looprpc.Loop.LiquidityParameters.getDefaultInstance()) return this;
        if (rulesBuilder_ == null) {
          if (!other.rules_.isEmpty()) {
            if (rules_.isEmpty()) {
              rules_ = other.rules_;
              bitField0_ = (bitField0_ & ~0x00000001);
            } else {
              ensureRulesIsMutable();
              rules_.addAll(other.rules_);
            }
            onChanged();
          }
        } else {
          if (!other.rules_.isEmpty()) {
            if (rulesBuilder_.isEmpty()) {
              rulesBuilder_.dispose();
              rulesBuilder_ = null;
              rules_ = other.rules_;
              bitField0_ = (bitField0_ & ~0x00000001);
              rulesBuilder_ = 
                com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
                   getRulesFieldBuilder() : null;
            } else {
              rulesBuilder_.addAllMessages(other.rules_);
            }
          }
        }
        if (other.getFeePpm() != 0L) {
          setFeePpm(other.getFeePpm());
        }
        if (other.getSweepFeeRateSatPerVbyte() != 0L) {
          setSweepFeeRateSatPerVbyte(other.getSweepFeeRateSatPerVbyte());
        }
        if (other.getMaxSwapFeePpm() != 0L) {
          setMaxSwapFeePpm(other.getMaxSwapFeePpm());
        }
        if (other.getMaxRoutingFeePpm() != 0L) {
          setMaxRoutingFeePpm(other.getMaxRoutingFeePpm());
        }
        if (other.getMaxPrepayRoutingFeePpm() != 0L) {
          setMaxPrepayRoutingFeePpm(other.getMaxPrepayRoutingFeePpm());
        }
        if (other.getMaxPrepaySat() != 0L) {
          setMaxPrepaySat(other.getMaxPrepaySat());
        }
        if (other.getMaxMinerFeeSat() != 0L) {
          setMaxMinerFeeSat(other.getMaxMinerFeeSat());
        }
        if (other.getSweepConfTarget() != 0) {
          setSweepConfTarget(other.getSweepConfTarget());
        }
        if (other.getFailureBackoffSec() != 0L) {
          setFailureBackoffSec(other.getFailureBackoffSec());
        }
        if (other.getAutoloop() != false) {
          setAutoloop(other.getAutoloop());
        }
        if (other.getAutoloopBudgetSat() != 0L) {
          setAutoloopBudgetSat(other.getAutoloopBudgetSat());
        }
        if (other.getAutoloopBudgetStartSec() != 0L) {
          setAutoloopBudgetStartSec(other.getAutoloopBudgetStartSec());
        }
        if (other.getAutoMaxInFlight() != 0L) {
          setAutoMaxInFlight(other.getAutoMaxInFlight());
        }
        if (other.getMinSwapAmount() != 0L) {
          setMinSwapAmount(other.getMinSwapAmount());
        }
        if (other.getMaxSwapAmount() != 0L) {
          setMaxSwapAmount(other.getMaxSwapAmount());
        }
        if (other.getHtlcConfTarget() != 0) {
          setHtlcConfTarget(other.getHtlcConfTarget());
        }
        if (!other.getAutoloopDestAddress().isEmpty()) {
          autoloopDestAddress_ = other.autoloopDestAddress_;
          bitField0_ |= 0x00020000;
          onChanged();
        }
        if (other.getAutoloopBudgetRefreshPeriodSec() != 0L) {
          setAutoloopBudgetRefreshPeriodSec(other.getAutoloopBudgetRefreshPeriodSec());
        }
        if (other.getAutoloopBudgetLastRefresh() != 0L) {
          setAutoloopBudgetLastRefresh(other.getAutoloopBudgetLastRefresh());
        }
        if (other.getEasyAutoloop() != false) {
          setEasyAutoloop(other.getEasyAutoloop());
        }
        if (other.getEasyAutoloopLocalTargetSat() != 0L) {
          setEasyAutoloopLocalTargetSat(other.getEasyAutoloopLocalTargetSat());
        }
        if (!other.getAccount().isEmpty()) {
          account_ = other.account_;
          bitField0_ |= 0x00400000;
          onChanged();
        }
        if (other.accountAddrType_ != 0) {
          setAccountAddrTypeValue(other.getAccountAddrTypeValue());
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10: {
                looprpc.Loop.LiquidityRule m =
                    input.readMessage(
                        looprpc.Loop.LiquidityRule.parser(),
                        extensionRegistry);
                if (rulesBuilder_ == null) {
                  ensureRulesIsMutable();
                  rules_.add(m);
                } else {
                  rulesBuilder_.addMessage(m);
                }
                break;
              } // case 10
              case 16: {
                sweepFeeRateSatPerVbyte_ = input.readUInt64();
                bitField0_ |= 0x00000004;
                break;
              } // case 16
              case 24: {
                maxSwapFeePpm_ = input.readUInt64();
                bitField0_ |= 0x00000008;
                break;
              } // case 24
              case 32: {
                maxRoutingFeePpm_ = input.readUInt64();
                bitField0_ |= 0x00000010;
                break;
              } // case 32
              case 40: {
                maxPrepayRoutingFeePpm_ = input.readUInt64();
                bitField0_ |= 0x00000020;
                break;
              } // case 40
              case 48: {
                maxPrepaySat_ = input.readUInt64();
                bitField0_ |= 0x00000040;
                break;
              } // case 48
              case 56: {
                maxMinerFeeSat_ = input.readUInt64();
                bitField0_ |= 0x00000080;
                break;
              } // case 56
              case 64: {
                sweepConfTarget_ = input.readInt32();
                bitField0_ |= 0x00000100;
                break;
              } // case 64
              case 72: {
                failureBackoffSec_ = input.readUInt64();
                bitField0_ |= 0x00000200;
                break;
              } // case 72
              case 80: {
                autoloop_ = input.readBool();
                bitField0_ |= 0x00000400;
                break;
              } // case 80
              case 88: {
                autoloopBudgetSat_ = input.readUInt64();
                bitField0_ |= 0x00000800;
                break;
              } // case 88
              case 96: {
                autoloopBudgetStartSec_ = input.readUInt64();
                bitField0_ |= 0x00001000;
                break;
              } // case 96
              case 104: {
                autoMaxInFlight_ = input.readUInt64();
                bitField0_ |= 0x00002000;
                break;
              } // case 104
              case 112: {
                minSwapAmount_ = input.readUInt64();
                bitField0_ |= 0x00004000;
                break;
              } // case 112
              case 120: {
                maxSwapAmount_ = input.readUInt64();
                bitField0_ |= 0x00008000;
                break;
              } // case 120
              case 128: {
                feePpm_ = input.readUInt64();
                bitField0_ |= 0x00000002;
                break;
              } // case 128
              case 136: {
                htlcConfTarget_ = input.readInt32();
                bitField0_ |= 0x00010000;
                break;
              } // case 136
              case 146: {
                autoloopDestAddress_ = input.readStringRequireUtf8();
                bitField0_ |= 0x00020000;
                break;
              } // case 146
              case 152: {
                autoloopBudgetRefreshPeriodSec_ = input.readUInt64();
                bitField0_ |= 0x00040000;
                break;
              } // case 152
              case 160: {
                autoloopBudgetLastRefresh_ = input.readUInt64();
                bitField0_ |= 0x00080000;
                break;
              } // case 160
              case 168: {
                easyAutoloop_ = input.readBool();
                bitField0_ |= 0x00100000;
                break;
              } // case 168
              case 176: {
                easyAutoloopLocalTargetSat_ = input.readUInt64();
                bitField0_ |= 0x00200000;
                break;
              } // case 176
              case 186: {
                account_ = input.readStringRequireUtf8();
                bitField0_ |= 0x00400000;
                break;
              } // case 186
              case 192: {
                accountAddrType_ = input.readEnum();
                bitField0_ |= 0x00800000;
                break;
              } // case 192
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private java.util.List<looprpc.Loop.LiquidityRule> rules_ =
        java.util.Collections.emptyList();
      private void ensureRulesIsMutable() {
        if (!((bitField0_ & 0x00000001) != 0)) {
          rules_ = new java.util.ArrayList<looprpc.Loop.LiquidityRule>(rules_);
          bitField0_ |= 0x00000001;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
          looprpc.Loop.LiquidityRule, looprpc.Loop.LiquidityRule.Builder, looprpc.Loop.LiquidityRuleOrBuilder> rulesBuilder_;

      /**
       * <pre>
       *
       *A set of liquidity rules that describe the desired liquidity balance.
       * </pre>
       *
       * <code>repeated .looprpc.LiquidityRule rules = 1;</code>
       */
      public java.util.List<looprpc.Loop.LiquidityRule> getRulesList() {
        if (rulesBuilder_ == null) {
          return java.util.Collections.unmodifiableList(rules_);
        } else {
          return rulesBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       *
       *A set of liquidity rules that describe the desired liquidity balance.
       * </pre>
       *
       * <code>repeated .looprpc.LiquidityRule rules = 1;</code>
       */
      public int getRulesCount() {
        if (rulesBuilder_ == null) {
          return rules_.size();
        } else {
          return rulesBuilder_.getCount();
        }
      }
      /**
       * <pre>
       *
       *A set of liquidity rules that describe the desired liquidity balance.
       * </pre>
       *
       * <code>repeated .looprpc.LiquidityRule rules = 1;</code>
       */
      public looprpc.Loop.LiquidityRule getRules(int index) {
        if (rulesBuilder_ == null) {
          return rules_.get(index);
        } else {
          return rulesBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       *
       *A set of liquidity rules that describe the desired liquidity balance.
       * </pre>
       *
       * <code>repeated .looprpc.LiquidityRule rules = 1;</code>
       */
      public Builder setRules(
          int index, looprpc.Loop.LiquidityRule value) {
        if (rulesBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureRulesIsMutable();
          rules_.set(index, value);
          onChanged();
        } else {
          rulesBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       *
       *A set of liquidity rules that describe the desired liquidity balance.
       * </pre>
       *
       * <code>repeated .looprpc.LiquidityRule rules = 1;</code>
       */
      public Builder setRules(
          int index, looprpc.Loop.LiquidityRule.Builder builderForValue) {
        if (rulesBuilder_ == null) {
          ensureRulesIsMutable();
          rules_.set(index, builderForValue.build());
          onChanged();
        } else {
          rulesBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       *
       *A set of liquidity rules that describe the desired liquidity balance.
       * </pre>
       *
       * <code>repeated .looprpc.LiquidityRule rules = 1;</code>
       */
      public Builder addRules(looprpc.Loop.LiquidityRule value) {
        if (rulesBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureRulesIsMutable();
          rules_.add(value);
          onChanged();
        } else {
          rulesBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       *
       *A set of liquidity rules that describe the desired liquidity balance.
       * </pre>
       *
       * <code>repeated .looprpc.LiquidityRule rules = 1;</code>
       */
      public Builder addRules(
          int index, looprpc.Loop.LiquidityRule value) {
        if (rulesBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureRulesIsMutable();
          rules_.add(index, value);
          onChanged();
        } else {
          rulesBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       *
       *A set of liquidity rules that describe the desired liquidity balance.
       * </pre>
       *
       * <code>repeated .looprpc.LiquidityRule rules = 1;</code>
       */
      public Builder addRules(
          looprpc.Loop.LiquidityRule.Builder builderForValue) {
        if (rulesBuilder_ == null) {
          ensureRulesIsMutable();
          rules_.add(builderForValue.build());
          onChanged();
        } else {
          rulesBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       *
       *A set of liquidity rules that describe the desired liquidity balance.
       * </pre>
       *
       * <code>repeated .looprpc.LiquidityRule rules = 1;</code>
       */
      public Builder addRules(
          int index, looprpc.Loop.LiquidityRule.Builder builderForValue) {
        if (rulesBuilder_ == null) {
          ensureRulesIsMutable();
          rules_.add(index, builderForValue.build());
          onChanged();
        } else {
          rulesBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       *
       *A set of liquidity rules that describe the desired liquidity balance.
       * </pre>
       *
       * <code>repeated .looprpc.LiquidityRule rules = 1;</code>
       */
      public Builder addAllRules(
          java.lang.Iterable<? extends looprpc.Loop.LiquidityRule> values) {
        if (rulesBuilder_ == null) {
          ensureRulesIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, rules_);
          onChanged();
        } else {
          rulesBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       *
       *A set of liquidity rules that describe the desired liquidity balance.
       * </pre>
       *
       * <code>repeated .looprpc.LiquidityRule rules = 1;</code>
       */
      public Builder clearRules() {
        if (rulesBuilder_ == null) {
          rules_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000001);
          onChanged();
        } else {
          rulesBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       *
       *A set of liquidity rules that describe the desired liquidity balance.
       * </pre>
       *
       * <code>repeated .looprpc.LiquidityRule rules = 1;</code>
       */
      public Builder removeRules(int index) {
        if (rulesBuilder_ == null) {
          ensureRulesIsMutable();
          rules_.remove(index);
          onChanged();
        } else {
          rulesBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       *
       *A set of liquidity rules that describe the desired liquidity balance.
       * </pre>
       *
       * <code>repeated .looprpc.LiquidityRule rules = 1;</code>
       */
      public looprpc.Loop.LiquidityRule.Builder getRulesBuilder(
          int index) {
        return getRulesFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       *
       *A set of liquidity rules that describe the desired liquidity balance.
       * </pre>
       *
       * <code>repeated .looprpc.LiquidityRule rules = 1;</code>
       */
      public looprpc.Loop.LiquidityRuleOrBuilder getRulesOrBuilder(
          int index) {
        if (rulesBuilder_ == null) {
          return rules_.get(index);  } else {
          return rulesBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       *
       *A set of liquidity rules that describe the desired liquidity balance.
       * </pre>
       *
       * <code>repeated .looprpc.LiquidityRule rules = 1;</code>
       */
      public java.util.List<? extends looprpc.Loop.LiquidityRuleOrBuilder> 
           getRulesOrBuilderList() {
        if (rulesBuilder_ != null) {
          return rulesBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(rules_);
        }
      }
      /**
       * <pre>
       *
       *A set of liquidity rules that describe the desired liquidity balance.
       * </pre>
       *
       * <code>repeated .looprpc.LiquidityRule rules = 1;</code>
       */
      public looprpc.Loop.LiquidityRule.Builder addRulesBuilder() {
        return getRulesFieldBuilder().addBuilder(
            looprpc.Loop.LiquidityRule.getDefaultInstance());
      }
      /**
       * <pre>
       *
       *A set of liquidity rules that describe the desired liquidity balance.
       * </pre>
       *
       * <code>repeated .looprpc.LiquidityRule rules = 1;</code>
       */
      public looprpc.Loop.LiquidityRule.Builder addRulesBuilder(
          int index) {
        return getRulesFieldBuilder().addBuilder(
            index, looprpc.Loop.LiquidityRule.getDefaultInstance());
      }
      /**
       * <pre>
       *
       *A set of liquidity rules that describe the desired liquidity balance.
       * </pre>
       *
       * <code>repeated .looprpc.LiquidityRule rules = 1;</code>
       */
      public java.util.List<looprpc.Loop.LiquidityRule.Builder> 
           getRulesBuilderList() {
        return getRulesFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilderV3<
          looprpc.Loop.LiquidityRule, looprpc.Loop.LiquidityRule.Builder, looprpc.Loop.LiquidityRuleOrBuilder> 
          getRulesFieldBuilder() {
        if (rulesBuilder_ == null) {
          rulesBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<
              looprpc.Loop.LiquidityRule, looprpc.Loop.LiquidityRule.Builder, looprpc.Loop.LiquidityRuleOrBuilder>(
                  rules_,
                  ((bitField0_ & 0x00000001) != 0),
                  getParentForChildren(),
                  isClean());
          rules_ = null;
        }
        return rulesBuilder_;
      }

      private long feePpm_ ;
      /**
       * <pre>
       *
       *The parts per million of swap amount that is allowed to be allocated to swap
       *fees. This value is applied across swap categories and may not be set in
       *conjunction with sweep fee rate, swap fee ppm, routing fee ppm, prepay
       *routing, max prepay and max miner fee.
       * </pre>
       *
       * <code>uint64 fee_ppm = 16 [jstype = JS_STRING];</code>
       * @return The feePpm.
       */
      @java.lang.Override
      public long getFeePpm() {
        return feePpm_;
      }
      /**
       * <pre>
       *
       *The parts per million of swap amount that is allowed to be allocated to swap
       *fees. This value is applied across swap categories and may not be set in
       *conjunction with sweep fee rate, swap fee ppm, routing fee ppm, prepay
       *routing, max prepay and max miner fee.
       * </pre>
       *
       * <code>uint64 fee_ppm = 16 [jstype = JS_STRING];</code>
       * @param value The feePpm to set.
       * @return This builder for chaining.
       */
      public Builder setFeePpm(long value) {

        feePpm_ = value;
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       *
       *The parts per million of swap amount that is allowed to be allocated to swap
       *fees. This value is applied across swap categories and may not be set in
       *conjunction with sweep fee rate, swap fee ppm, routing fee ppm, prepay
       *routing, max prepay and max miner fee.
       * </pre>
       *
       * <code>uint64 fee_ppm = 16 [jstype = JS_STRING];</code>
       * @return This builder for chaining.
       */
      public Builder clearFeePpm() {
        bitField0_ = (bitField0_ & ~0x00000002);
        feePpm_ = 0L;
        onChanged();
        return this;
      }

      private long sweepFeeRateSatPerVbyte_ ;
      /**
       * <pre>
       *
       *The limit we place on our estimated sweep cost for a swap in sat/vByte. If
       *the estimated fee for our sweep transaction within the specified
       *confirmation target is above this value, we will not suggest any swaps.
       * </pre>
       *
       * <code>uint64 sweep_fee_rate_sat_per_vbyte = 2 [jstype = JS_STRING];</code>
       * @return The sweepFeeRateSatPerVbyte.
       */
      @java.lang.Override
      public long getSweepFeeRateSatPerVbyte() {
        return sweepFeeRateSatPerVbyte_;
      }
      /**
       * <pre>
       *
       *The limit we place on our estimated sweep cost for a swap in sat/vByte. If
       *the estimated fee for our sweep transaction within the specified
       *confirmation target is above this value, we will not suggest any swaps.
       * </pre>
       *
       * <code>uint64 sweep_fee_rate_sat_per_vbyte = 2 [jstype = JS_STRING];</code>
       * @param value The sweepFeeRateSatPerVbyte to set.
       * @return This builder for chaining.
       */
      public Builder setSweepFeeRateSatPerVbyte(long value) {

        sweepFeeRateSatPerVbyte_ = value;
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }
      /**
       * <pre>
       *
       *The limit we place on our estimated sweep cost for a swap in sat/vByte. If
       *the estimated fee for our sweep transaction within the specified
       *confirmation target is above this value, we will not suggest any swaps.
       * </pre>
       *
       * <code>uint64 sweep_fee_rate_sat_per_vbyte = 2 [jstype = JS_STRING];</code>
       * @return This builder for chaining.
       */
      public Builder clearSweepFeeRateSatPerVbyte() {
        bitField0_ = (bitField0_ & ~0x00000004);
        sweepFeeRateSatPerVbyte_ = 0L;
        onChanged();
        return this;
      }

      private long maxSwapFeePpm_ ;
      /**
       * <pre>
       *
       *The maximum fee paid to the server for facilitating the swap, expressed
       *as parts per million of the swap volume.
       * </pre>
       *
       * <code>uint64 max_swap_fee_ppm = 3 [jstype = JS_STRING];</code>
       * @return The maxSwapFeePpm.
       */
      @java.lang.Override
      public long getMaxSwapFeePpm() {
        return maxSwapFeePpm_;
      }
      /**
       * <pre>
       *
       *The maximum fee paid to the server for facilitating the swap, expressed
       *as parts per million of the swap volume.
       * </pre>
       *
       * <code>uint64 max_swap_fee_ppm = 3 [jstype = JS_STRING];</code>
       * @param value The maxSwapFeePpm to set.
       * @return This builder for chaining.
       */
      public Builder setMaxSwapFeePpm(long value) {

        maxSwapFeePpm_ = value;
        bitField0_ |= 0x00000008;
        onChanged();
        return this;
      }
      /**
       * <pre>
       *
       *The maximum fee paid to the server for facilitating the swap, expressed
       *as parts per million of the swap volume.
       * </pre>
       *
       * <code>uint64 max_swap_fee_ppm = 3 [jstype = JS_STRING];</code>
       * @return This builder for chaining.
       */
      public Builder clearMaxSwapFeePpm() {
        bitField0_ = (bitField0_ & ~0x00000008);
        maxSwapFeePpm_ = 0L;
        onChanged();
        return this;
      }

      private long maxRoutingFeePpm_ ;
      /**
       * <pre>
       *
       *The maximum fee paid to route the swap invoice off chain, expressed as
       *parts per million of the volume being routed.
       * </pre>
       *
       * <code>uint64 max_routing_fee_ppm = 4 [jstype = JS_STRING];</code>
       * @return The maxRoutingFeePpm.
       */
      @java.lang.Override
      public long getMaxRoutingFeePpm() {
        return maxRoutingFeePpm_;
      }
      /**
       * <pre>
       *
       *The maximum fee paid to route the swap invoice off chain, expressed as
       *parts per million of the volume being routed.
       * </pre>
       *
       * <code>uint64 max_routing_fee_ppm = 4 [jstype = JS_STRING];</code>
       * @param value The maxRoutingFeePpm to set.
       * @return This builder for chaining.
       */
      public Builder setMaxRoutingFeePpm(long value) {

        maxRoutingFeePpm_ = value;
        bitField0_ |= 0x00000010;
        onChanged();
        return this;
      }
      /**
       * <pre>
       *
       *The maximum fee paid to route the swap invoice off chain, expressed as
       *parts per million of the volume being routed.
       * </pre>
       *
       * <code>uint64 max_routing_fee_ppm = 4 [jstype = JS_STRING];</code>
       * @return This builder for chaining.
       */
      public Builder clearMaxRoutingFeePpm() {
        bitField0_ = (bitField0_ & ~0x00000010);
        maxRoutingFeePpm_ = 0L;
        onChanged();
        return this;
      }

      private long maxPrepayRoutingFeePpm_ ;
      /**
       * <pre>
       *
       *The maximum fee paid to route the prepay invoice off chain, expressed as
       *parts per million of the volume being routed.
       * </pre>
       *
       * <code>uint64 max_prepay_routing_fee_ppm = 5 [jstype = JS_STRING];</code>
       * @return The maxPrepayRoutingFeePpm.
       */
      @java.lang.Override
      public long getMaxPrepayRoutingFeePpm() {
        return maxPrepayRoutingFeePpm_;
      }
      /**
       * <pre>
       *
       *The maximum fee paid to route the prepay invoice off chain, expressed as
       *parts per million of the volume being routed.
       * </pre>
       *
       * <code>uint64 max_prepay_routing_fee_ppm = 5 [jstype = JS_STRING];</code>
       * @param value The maxPrepayRoutingFeePpm to set.
       * @return This builder for chaining.
       */
      public Builder setMaxPrepayRoutingFeePpm(long value) {

        maxPrepayRoutingFeePpm_ = value;
        bitField0_ |= 0x00000020;
        onChanged();
        return this;
      }
      /**
       * <pre>
       *
       *The maximum fee paid to route the prepay invoice off chain, expressed as
       *parts per million of the volume being routed.
       * </pre>
       *
       * <code>uint64 max_prepay_routing_fee_ppm = 5 [jstype = JS_STRING];</code>
       * @return This builder for chaining.
       */
      public Builder clearMaxPrepayRoutingFeePpm() {
        bitField0_ = (bitField0_ & ~0x00000020);
        maxPrepayRoutingFeePpm_ = 0L;
        onChanged();
        return this;
      }

      private long maxPrepaySat_ ;
      /**
       * <pre>
       *
       *The maximum no-show penalty in satoshis paid for a swap.
       * </pre>
       *
       * <code>uint64 max_prepay_sat = 6 [jstype = JS_STRING];</code>
       * @return The maxPrepaySat.
       */
      @java.lang.Override
      public long getMaxPrepaySat() {
        return maxPrepaySat_;
      }
      /**
       * <pre>
       *
       *The maximum no-show penalty in satoshis paid for a swap.
       * </pre>
       *
       * <code>uint64 max_prepay_sat = 6 [jstype = JS_STRING];</code>
       * @param value The maxPrepaySat to set.
       * @return This builder for chaining.
       */
      public Builder setMaxPrepaySat(long value) {

        maxPrepaySat_ = value;
        bitField0_ |= 0x00000040;
        onChanged();
        return this;
      }
      /**
       * <pre>
       *
       *The maximum no-show penalty in satoshis paid for a swap.
       * </pre>
       *
       * <code>uint64 max_prepay_sat = 6 [jstype = JS_STRING];</code>
       * @return This builder for chaining.
       */
      public Builder clearMaxPrepaySat() {
        bitField0_ = (bitField0_ & ~0x00000040);
        maxPrepaySat_ = 0L;
        onChanged();
        return this;
      }

      private long maxMinerFeeSat_ ;
      /**
       * <pre>
       *
       *The maximum miner fee we will pay to sweep the swap on chain. Note that we
       *will not suggest a swap if the estimate is above the sweep limit set by
       *these parameters, and we use the current fee estimate to sweep on chain so
       *this value is only a cap placed on the amount we spend on fees in the case
       *where the swap needs to be claimed on chain, but fees have suddenly spiked.
       * </pre>
       *
       * <code>uint64 max_miner_fee_sat = 7 [jstype = JS_STRING];</code>
       * @return The maxMinerFeeSat.
       */
      @java.lang.Override
      public long getMaxMinerFeeSat() {
        return maxMinerFeeSat_;
      }
      /**
       * <pre>
       *
       *The maximum miner fee we will pay to sweep the swap on chain. Note that we
       *will not suggest a swap if the estimate is above the sweep limit set by
       *these parameters, and we use the current fee estimate to sweep on chain so
       *this value is only a cap placed on the amount we spend on fees in the case
       *where the swap needs to be claimed on chain, but fees have suddenly spiked.
       * </pre>
       *
       * <code>uint64 max_miner_fee_sat = 7 [jstype = JS_STRING];</code>
       * @param value The maxMinerFeeSat to set.
       * @return This builder for chaining.
       */
      public Builder setMaxMinerFeeSat(long value) {

        maxMinerFeeSat_ = value;
        bitField0_ |= 0x00000080;
        onChanged();
        return this;
      }
      /**
       * <pre>
       *
       *The maximum miner fee we will pay to sweep the swap on chain. Note that we
       *will not suggest a swap if the estimate is above the sweep limit set by
       *these parameters, and we use the current fee estimate to sweep on chain so
       *this value is only a cap placed on the amount we spend on fees in the case
       *where the swap needs to be claimed on chain, but fees have suddenly spiked.
       * </pre>
       *
       * <code>uint64 max_miner_fee_sat = 7 [jstype = JS_STRING];</code>
       * @return This builder for chaining.
       */
      public Builder clearMaxMinerFeeSat() {
        bitField0_ = (bitField0_ & ~0x00000080);
        maxMinerFeeSat_ = 0L;
        onChanged();
        return this;
      }

      private int sweepConfTarget_ ;
      /**
       * <pre>
       *
       *The number of blocks from the on-chain HTLC's confirmation height that it
       *should be swept within.
       * </pre>
       *
       * <code>int32 sweep_conf_target = 8;</code>
       * @return The sweepConfTarget.
       */
      @java.lang.Override
      public int getSweepConfTarget() {
        return sweepConfTarget_;
      }
      /**
       * <pre>
       *
       *The number of blocks from the on-chain HTLC's confirmation height that it
       *should be swept within.
       * </pre>
       *
       * <code>int32 sweep_conf_target = 8;</code>
       * @param value The sweepConfTarget to set.
       * @return This builder for chaining.
       */
      public Builder setSweepConfTarget(int value) {

        sweepConfTarget_ = value;
        bitField0_ |= 0x00000100;
        onChanged();
        return this;
      }
      /**
       * <pre>
       *
       *The number of blocks from the on-chain HTLC's confirmation height that it
       *should be swept within.
       * </pre>
       *
       * <code>int32 sweep_conf_target = 8;</code>
       * @return This builder for chaining.
       */
      public Builder clearSweepConfTarget() {
        bitField0_ = (bitField0_ & ~0x00000100);
        sweepConfTarget_ = 0;
        onChanged();
        return this;
      }

      private long failureBackoffSec_ ;
      /**
       * <pre>
       *
       *The amount of time we require pass since a channel was part of a failed
       *swap due to off chain payment failure until it will be considered for swap
       *suggestions again, expressed in seconds.
       * </pre>
       *
       * <code>uint64 failure_backoff_sec = 9 [jstype = JS_STRING];</code>
       * @return The failureBackoffSec.
       */
      @java.lang.Override
      public long getFailureBackoffSec() {
        return failureBackoffSec_;
      }
      /**
       * <pre>
       *
       *The amount of time we require pass since a channel was part of a failed
       *swap due to off chain payment failure until it will be considered for swap
       *suggestions again, expressed in seconds.
       * </pre>
       *
       * <code>uint64 failure_backoff_sec = 9 [jstype = JS_STRING];</code>
       * @param value The failureBackoffSec to set.
       * @return This builder for chaining.
       */
      public Builder setFailureBackoffSec(long value) {

        failureBackoffSec_ = value;
        bitField0_ |= 0x00000200;
        onChanged();
        return this;
      }
      /**
       * <pre>
       *
       *The amount of time we require pass since a channel was part of a failed
       *swap due to off chain payment failure until it will be considered for swap
       *suggestions again, expressed in seconds.
       * </pre>
       *
       * <code>uint64 failure_backoff_sec = 9 [jstype = JS_STRING];</code>
       * @return This builder for chaining.
       */
      public Builder clearFailureBackoffSec() {
        bitField0_ = (bitField0_ & ~0x00000200);
        failureBackoffSec_ = 0L;
        onChanged();
        return this;
      }

      private boolean autoloop_ ;
      /**
       * <pre>
       *
       *Set to true to enable automatic dispatch of swaps. All swaps will be limited
       *to the fee categories set by these parameters, and total expenditure will
       *be limited to the autoloop budget.
       * </pre>
       *
       * <code>bool autoloop = 10;</code>
       * @return The autoloop.
       */
      @java.lang.Override
      public boolean getAutoloop() {
        return autoloop_;
      }
      /**
       * <pre>
       *
       *Set to true to enable automatic dispatch of swaps. All swaps will be limited
       *to the fee categories set by these parameters, and total expenditure will
       *be limited to the autoloop budget.
       * </pre>
       *
       * <code>bool autoloop = 10;</code>
       * @param value The autoloop to set.
       * @return This builder for chaining.
       */
      public Builder setAutoloop(boolean value) {

        autoloop_ = value;
        bitField0_ |= 0x00000400;
        onChanged();
        return this;
      }
      /**
       * <pre>
       *
       *Set to true to enable automatic dispatch of swaps. All swaps will be limited
       *to the fee categories set by these parameters, and total expenditure will
       *be limited to the autoloop budget.
       * </pre>
       *
       * <code>bool autoloop = 10;</code>
       * @return This builder for chaining.
       */
      public Builder clearAutoloop() {
        bitField0_ = (bitField0_ & ~0x00000400);
        autoloop_ = false;
        onChanged();
        return this;
      }

      private long autoloopBudgetSat_ ;
      /**
       * <pre>
       *
       *The total budget for automatically dispatched swaps since the budget start
       *time, expressed in satoshis.
       * </pre>
       *
       * <code>uint64 autoloop_budget_sat = 11 [jstype = JS_STRING];</code>
       * @return The autoloopBudgetSat.
       */
      @java.lang.Override
      public long getAutoloopBudgetSat() {
        return autoloopBudgetSat_;
      }
      /**
       * <pre>
       *
       *The total budget for automatically dispatched swaps since the budget start
       *time, expressed in satoshis.
       * </pre>
       *
       * <code>uint64 autoloop_budget_sat = 11 [jstype = JS_STRING];</code>
       * @param value The autoloopBudgetSat to set.
       * @return This builder for chaining.
       */
      public Builder setAutoloopBudgetSat(long value) {

        autoloopBudgetSat_ = value;
        bitField0_ |= 0x00000800;
        onChanged();
        return this;
      }
      /**
       * <pre>
       *
       *The total budget for automatically dispatched swaps since the budget start
       *time, expressed in satoshis.
       * </pre>
       *
       * <code>uint64 autoloop_budget_sat = 11 [jstype = JS_STRING];</code>
       * @return This builder for chaining.
       */
      public Builder clearAutoloopBudgetSat() {
        bitField0_ = (bitField0_ & ~0x00000800);
        autoloopBudgetSat_ = 0L;
        onChanged();
        return this;
      }

      private long autoloopBudgetStartSec_ ;
      /**
       * <pre>
       *
       *Deprecated, use autoloop_budget_refresh_period_sec. The start time for
       *autoloop budget, expressed as a unix timestamp in seconds. If this value is
       *0, the budget will be applied for all automatically dispatched swaps. Swaps
       *that were completed before this date will not be included in budget
       *calculations.
       * </pre>
       *
       * <code>uint64 autoloop_budget_start_sec = 12 [deprecated = true, jstype = JS_STRING];</code>
       * @deprecated looprpc.LiquidityParameters.autoloop_budget_start_sec is deprecated.
       *     See loop.proto;l=937
       * @return The autoloopBudgetStartSec.
       */
      @java.lang.Override
      @java.lang.Deprecated public long getAutoloopBudgetStartSec() {
        return autoloopBudgetStartSec_;
      }
      /**
       * <pre>
       *
       *Deprecated, use autoloop_budget_refresh_period_sec. The start time for
       *autoloop budget, expressed as a unix timestamp in seconds. If this value is
       *0, the budget will be applied for all automatically dispatched swaps. Swaps
       *that were completed before this date will not be included in budget
       *calculations.
       * </pre>
       *
       * <code>uint64 autoloop_budget_start_sec = 12 [deprecated = true, jstype = JS_STRING];</code>
       * @deprecated looprpc.LiquidityParameters.autoloop_budget_start_sec is deprecated.
       *     See loop.proto;l=937
       * @param value The autoloopBudgetStartSec to set.
       * @return This builder for chaining.
       */
      @java.lang.Deprecated public Builder setAutoloopBudgetStartSec(long value) {

        autoloopBudgetStartSec_ = value;
        bitField0_ |= 0x00001000;
        onChanged();
        return this;
      }
      /**
       * <pre>
       *
       *Deprecated, use autoloop_budget_refresh_period_sec. The start time for
       *autoloop budget, expressed as a unix timestamp in seconds. If this value is
       *0, the budget will be applied for all automatically dispatched swaps. Swaps
       *that were completed before this date will not be included in budget
       *calculations.
       * </pre>
       *
       * <code>uint64 autoloop_budget_start_sec = 12 [deprecated = true, jstype = JS_STRING];</code>
       * @deprecated looprpc.LiquidityParameters.autoloop_budget_start_sec is deprecated.
       *     See loop.proto;l=937
       * @return This builder for chaining.
       */
      @java.lang.Deprecated public Builder clearAutoloopBudgetStartSec() {
        bitField0_ = (bitField0_ & ~0x00001000);
        autoloopBudgetStartSec_ = 0L;
        onChanged();
        return this;
      }

      private long autoMaxInFlight_ ;
      /**
       * <pre>
       *
       *The maximum number of automatically dispatched swaps that we allow to be in
       *flight at any point in time.
       * </pre>
       *
       * <code>uint64 auto_max_in_flight = 13 [jstype = JS_STRING];</code>
       * @return The autoMaxInFlight.
       */
      @java.lang.Override
      public long getAutoMaxInFlight() {
        return autoMaxInFlight_;
      }
      /**
       * <pre>
       *
       *The maximum number of automatically dispatched swaps that we allow to be in
       *flight at any point in time.
       * </pre>
       *
       * <code>uint64 auto_max_in_flight = 13 [jstype = JS_STRING];</code>
       * @param value The autoMaxInFlight to set.
       * @return This builder for chaining.
       */
      public Builder setAutoMaxInFlight(long value) {

        autoMaxInFlight_ = value;
        bitField0_ |= 0x00002000;
        onChanged();
        return this;
      }
      /**
       * <pre>
       *
       *The maximum number of automatically dispatched swaps that we allow to be in
       *flight at any point in time.
       * </pre>
       *
       * <code>uint64 auto_max_in_flight = 13 [jstype = JS_STRING];</code>
       * @return This builder for chaining.
       */
      public Builder clearAutoMaxInFlight() {
        bitField0_ = (bitField0_ & ~0x00002000);
        autoMaxInFlight_ = 0L;
        onChanged();
        return this;
      }

      private long minSwapAmount_ ;
      /**
       * <pre>
       *
       *The minimum amount, expressed in satoshis, that the autoloop client will
       *dispatch a swap for. This value is subject to the server-side limits
       *specified by the LoopOutTerms endpoint.
       * </pre>
       *
       * <code>uint64 min_swap_amount = 14 [jstype = JS_STRING];</code>
       * @return The minSwapAmount.
       */
      @java.lang.Override
      public long getMinSwapAmount() {
        return minSwapAmount_;
      }
      /**
       * <pre>
       *
       *The minimum amount, expressed in satoshis, that the autoloop client will
       *dispatch a swap for. This value is subject to the server-side limits
       *specified by the LoopOutTerms endpoint.
       * </pre>
       *
       * <code>uint64 min_swap_amount = 14 [jstype = JS_STRING];</code>
       * @param value The minSwapAmount to set.
       * @return This builder for chaining.
       */
      public Builder setMinSwapAmount(long value) {

        minSwapAmount_ = value;
        bitField0_ |= 0x00004000;
        onChanged();
        return this;
      }
      /**
       * <pre>
       *
       *The minimum amount, expressed in satoshis, that the autoloop client will
       *dispatch a swap for. This value is subject to the server-side limits
       *specified by the LoopOutTerms endpoint.
       * </pre>
       *
       * <code>uint64 min_swap_amount = 14 [jstype = JS_STRING];</code>
       * @return This builder for chaining.
       */
      public Builder clearMinSwapAmount() {
        bitField0_ = (bitField0_ & ~0x00004000);
        minSwapAmount_ = 0L;
        onChanged();
        return this;
      }

      private long maxSwapAmount_ ;
      /**
       * <pre>
       *
       *The maximum amount, expressed in satoshis, that the autoloop client will
       *dispatch a swap for. This value is subject to the server-side limits
       *specified by the LoopOutTerms endpoint.
       * </pre>
       *
       * <code>uint64 max_swap_amount = 15 [jstype = JS_STRING];</code>
       * @return The maxSwapAmount.
       */
      @java.lang.Override
      public long getMaxSwapAmount() {
        return maxSwapAmount_;
      }
      /**
       * <pre>
       *
       *The maximum amount, expressed in satoshis, that the autoloop client will
       *dispatch a swap for. This value is subject to the server-side limits
       *specified by the LoopOutTerms endpoint.
       * </pre>
       *
       * <code>uint64 max_swap_amount = 15 [jstype = JS_STRING];</code>
       * @param value The maxSwapAmount to set.
       * @return This builder for chaining.
       */
      public Builder setMaxSwapAmount(long value) {

        maxSwapAmount_ = value;
        bitField0_ |= 0x00008000;
        onChanged();
        return this;
      }
      /**
       * <pre>
       *
       *The maximum amount, expressed in satoshis, that the autoloop client will
       *dispatch a swap for. This value is subject to the server-side limits
       *specified by the LoopOutTerms endpoint.
       * </pre>
       *
       * <code>uint64 max_swap_amount = 15 [jstype = JS_STRING];</code>
       * @return This builder for chaining.
       */
      public Builder clearMaxSwapAmount() {
        bitField0_ = (bitField0_ & ~0x00008000);
        maxSwapAmount_ = 0L;
        onChanged();
        return this;
      }

      private int htlcConfTarget_ ;
      /**
       * <pre>
       *
       *The confirmation target for loop in on-chain htlcs.
       * </pre>
       *
       * <code>int32 htlc_conf_target = 17;</code>
       * @return The htlcConfTarget.
       */
      @java.lang.Override
      public int getHtlcConfTarget() {
        return htlcConfTarget_;
      }
      /**
       * <pre>
       *
       *The confirmation target for loop in on-chain htlcs.
       * </pre>
       *
       * <code>int32 htlc_conf_target = 17;</code>
       * @param value The htlcConfTarget to set.
       * @return This builder for chaining.
       */
      public Builder setHtlcConfTarget(int value) {

        htlcConfTarget_ = value;
        bitField0_ |= 0x00010000;
        onChanged();
        return this;
      }
      /**
       * <pre>
       *
       *The confirmation target for loop in on-chain htlcs.
       * </pre>
       *
       * <code>int32 htlc_conf_target = 17;</code>
       * @return This builder for chaining.
       */
      public Builder clearHtlcConfTarget() {
        bitField0_ = (bitField0_ & ~0x00010000);
        htlcConfTarget_ = 0;
        onChanged();
        return this;
      }

      private java.lang.Object autoloopDestAddress_ = "";
      /**
       * <pre>
       *
       *The destination address to use for autoloop loop outs. Set to "default" in
       *order to revert to default behavior.
       * </pre>
       *
       * <code>string autoloop_dest_address = 18;</code>
       * @return The autoloopDestAddress.
       */
      public java.lang.String getAutoloopDestAddress() {
        java.lang.Object ref = autoloopDestAddress_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          autoloopDestAddress_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       *
       *The destination address to use for autoloop loop outs. Set to "default" in
       *order to revert to default behavior.
       * </pre>
       *
       * <code>string autoloop_dest_address = 18;</code>
       * @return The bytes for autoloopDestAddress.
       */
      public com.google.protobuf.ByteString
          getAutoloopDestAddressBytes() {
        java.lang.Object ref = autoloopDestAddress_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          autoloopDestAddress_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       *
       *The destination address to use for autoloop loop outs. Set to "default" in
       *order to revert to default behavior.
       * </pre>
       *
       * <code>string autoloop_dest_address = 18;</code>
       * @param value The autoloopDestAddress to set.
       * @return This builder for chaining.
       */
      public Builder setAutoloopDestAddress(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        autoloopDestAddress_ = value;
        bitField0_ |= 0x00020000;
        onChanged();
        return this;
      }
      /**
       * <pre>
       *
       *The destination address to use for autoloop loop outs. Set to "default" in
       *order to revert to default behavior.
       * </pre>
       *
       * <code>string autoloop_dest_address = 18;</code>
       * @return This builder for chaining.
       */
      public Builder clearAutoloopDestAddress() {
        autoloopDestAddress_ = getDefaultInstance().getAutoloopDestAddress();
        bitField0_ = (bitField0_ & ~0x00020000);
        onChanged();
        return this;
      }
      /**
       * <pre>
       *
       *The destination address to use for autoloop loop outs. Set to "default" in
       *order to revert to default behavior.
       * </pre>
       *
       * <code>string autoloop_dest_address = 18;</code>
       * @param value The bytes for autoloopDestAddress to set.
       * @return This builder for chaining.
       */
      public Builder setAutoloopDestAddressBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        checkByteStringIsUtf8(value);
        autoloopDestAddress_ = value;
        bitField0_ |= 0x00020000;
        onChanged();
        return this;
      }

      private long autoloopBudgetRefreshPeriodSec_ ;
      /**
       * <pre>
       *
       *The period over which the autoloop budget is refreshed, expressed in
       *seconds.
       * </pre>
       *
       * <code>uint64 autoloop_budget_refresh_period_sec = 19 [jstype = JS_STRING];</code>
       * @return The autoloopBudgetRefreshPeriodSec.
       */
      @java.lang.Override
      public long getAutoloopBudgetRefreshPeriodSec() {
        return autoloopBudgetRefreshPeriodSec_;
      }
      /**
       * <pre>
       *
       *The period over which the autoloop budget is refreshed, expressed in
       *seconds.
       * </pre>
       *
       * <code>uint64 autoloop_budget_refresh_period_sec = 19 [jstype = JS_STRING];</code>
       * @param value The autoloopBudgetRefreshPeriodSec to set.
       * @return This builder for chaining.
       */
      public Builder setAutoloopBudgetRefreshPeriodSec(long value) {

        autoloopBudgetRefreshPeriodSec_ = value;
        bitField0_ |= 0x00040000;
        onChanged();
        return this;
      }
      /**
       * <pre>
       *
       *The period over which the autoloop budget is refreshed, expressed in
       *seconds.
       * </pre>
       *
       * <code>uint64 autoloop_budget_refresh_period_sec = 19 [jstype = JS_STRING];</code>
       * @return This builder for chaining.
       */
      public Builder clearAutoloopBudgetRefreshPeriodSec() {
        bitField0_ = (bitField0_ & ~0x00040000);
        autoloopBudgetRefreshPeriodSec_ = 0L;
        onChanged();
        return this;
      }

      private long autoloopBudgetLastRefresh_ ;
      /**
       * <pre>
       *
       *The time at which the autoloop budget was last refreshed, expressed as a
       *UNIX timestamp in seconds.
       * </pre>
       *
       * <code>uint64 autoloop_budget_last_refresh = 20 [jstype = JS_STRING];</code>
       * @return The autoloopBudgetLastRefresh.
       */
      @java.lang.Override
      public long getAutoloopBudgetLastRefresh() {
        return autoloopBudgetLastRefresh_;
      }
      /**
       * <pre>
       *
       *The time at which the autoloop budget was last refreshed, expressed as a
       *UNIX timestamp in seconds.
       * </pre>
       *
       * <code>uint64 autoloop_budget_last_refresh = 20 [jstype = JS_STRING];</code>
       * @param value The autoloopBudgetLastRefresh to set.
       * @return This builder for chaining.
       */
      public Builder setAutoloopBudgetLastRefresh(long value) {

        autoloopBudgetLastRefresh_ = value;
        bitField0_ |= 0x00080000;
        onChanged();
        return this;
      }
      /**
       * <pre>
       *
       *The time at which the autoloop budget was last refreshed, expressed as a
       *UNIX timestamp in seconds.
       * </pre>
       *
       * <code>uint64 autoloop_budget_last_refresh = 20 [jstype = JS_STRING];</code>
       * @return This builder for chaining.
       */
      public Builder clearAutoloopBudgetLastRefresh() {
        bitField0_ = (bitField0_ & ~0x00080000);
        autoloopBudgetLastRefresh_ = 0L;
        onChanged();
        return this;
      }

      private boolean easyAutoloop_ ;
      /**
       * <pre>
       *
       *Set to true to enable easy autoloop. If set, all channel/peer rules will be
       *overridden and the client will automatically dispatch swaps in order to meet
       *the configured local balance target size. Currently only loop out is
       *supported, meaning that easy autoloop can only reduce the funds that are
       *held as balance in channels.
       * </pre>
       *
       * <code>bool easy_autoloop = 21;</code>
       * @return The easyAutoloop.
       */
      @java.lang.Override
      public boolean getEasyAutoloop() {
        return easyAutoloop_;
      }
      /**
       * <pre>
       *
       *Set to true to enable easy autoloop. If set, all channel/peer rules will be
       *overridden and the client will automatically dispatch swaps in order to meet
       *the configured local balance target size. Currently only loop out is
       *supported, meaning that easy autoloop can only reduce the funds that are
       *held as balance in channels.
       * </pre>
       *
       * <code>bool easy_autoloop = 21;</code>
       * @param value The easyAutoloop to set.
       * @return This builder for chaining.
       */
      public Builder setEasyAutoloop(boolean value) {

        easyAutoloop_ = value;
        bitField0_ |= 0x00100000;
        onChanged();
        return this;
      }
      /**
       * <pre>
       *
       *Set to true to enable easy autoloop. If set, all channel/peer rules will be
       *overridden and the client will automatically dispatch swaps in order to meet
       *the configured local balance target size. Currently only loop out is
       *supported, meaning that easy autoloop can only reduce the funds that are
       *held as balance in channels.
       * </pre>
       *
       * <code>bool easy_autoloop = 21;</code>
       * @return This builder for chaining.
       */
      public Builder clearEasyAutoloop() {
        bitField0_ = (bitField0_ & ~0x00100000);
        easyAutoloop_ = false;
        onChanged();
        return this;
      }

      private long easyAutoloopLocalTargetSat_ ;
      /**
       * <pre>
       *
       *The local balance target size, expressed in satoshis. This is used by easy
       *autoloop to determine how much liquidity should be maintained in channels.
       * </pre>
       *
       * <code>uint64 easy_autoloop_local_target_sat = 22 [jstype = JS_STRING];</code>
       * @return The easyAutoloopLocalTargetSat.
       */
      @java.lang.Override
      public long getEasyAutoloopLocalTargetSat() {
        return easyAutoloopLocalTargetSat_;
      }
      /**
       * <pre>
       *
       *The local balance target size, expressed in satoshis. This is used by easy
       *autoloop to determine how much liquidity should be maintained in channels.
       * </pre>
       *
       * <code>uint64 easy_autoloop_local_target_sat = 22 [jstype = JS_STRING];</code>
       * @param value The easyAutoloopLocalTargetSat to set.
       * @return This builder for chaining.
       */
      public Builder setEasyAutoloopLocalTargetSat(long value) {

        easyAutoloopLocalTargetSat_ = value;
        bitField0_ |= 0x00200000;
        onChanged();
        return this;
      }
      /**
       * <pre>
       *
       *The local balance target size, expressed in satoshis. This is used by easy
       *autoloop to determine how much liquidity should be maintained in channels.
       * </pre>
       *
       * <code>uint64 easy_autoloop_local_target_sat = 22 [jstype = JS_STRING];</code>
       * @return This builder for chaining.
       */
      public Builder clearEasyAutoloopLocalTargetSat() {
        bitField0_ = (bitField0_ & ~0x00200000);
        easyAutoloopLocalTargetSat_ = 0L;
        onChanged();
        return this;
      }

      private java.lang.Object account_ = "";
      /**
       * <pre>
       *
       *An alternative destination address source for the swap. This field
       *represents the name of the account in the backing lnd instance.
       *Refer to lnd's wallet import functions for reference.
       * </pre>
       *
       * <code>string account = 23;</code>
       * @return The account.
       */
      public java.lang.String getAccount() {
        java.lang.Object ref = account_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          account_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       *
       *An alternative destination address source for the swap. This field
       *represents the name of the account in the backing lnd instance.
       *Refer to lnd's wallet import functions for reference.
       * </pre>
       *
       * <code>string account = 23;</code>
       * @return The bytes for account.
       */
      public com.google.protobuf.ByteString
          getAccountBytes() {
        java.lang.Object ref = account_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          account_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       *
       *An alternative destination address source for the swap. This field
       *represents the name of the account in the backing lnd instance.
       *Refer to lnd's wallet import functions for reference.
       * </pre>
       *
       * <code>string account = 23;</code>
       * @param value The account to set.
       * @return This builder for chaining.
       */
      public Builder setAccount(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        account_ = value;
        bitField0_ |= 0x00400000;
        onChanged();
        return this;
      }
      /**
       * <pre>
       *
       *An alternative destination address source for the swap. This field
       *represents the name of the account in the backing lnd instance.
       *Refer to lnd's wallet import functions for reference.
       * </pre>
       *
       * <code>string account = 23;</code>
       * @return This builder for chaining.
       */
      public Builder clearAccount() {
        account_ = getDefaultInstance().getAccount();
        bitField0_ = (bitField0_ & ~0x00400000);
        onChanged();
        return this;
      }
      /**
       * <pre>
       *
       *An alternative destination address source for the swap. This field
       *represents the name of the account in the backing lnd instance.
       *Refer to lnd's wallet import functions for reference.
       * </pre>
       *
       * <code>string account = 23;</code>
       * @param value The bytes for account to set.
       * @return This builder for chaining.
       */
      public Builder setAccountBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        checkByteStringIsUtf8(value);
        account_ = value;
        bitField0_ |= 0x00400000;
        onChanged();
        return this;
      }

      private int accountAddrType_ = 0;
      /**
       * <pre>
       *
       *The address type of the account specified in the account field.
       * </pre>
       *
       * <code>.looprpc.AddressType account_addr_type = 24;</code>
       * @return The enum numeric value on the wire for accountAddrType.
       */
      @java.lang.Override public int getAccountAddrTypeValue() {
        return accountAddrType_;
      }
      /**
       * <pre>
       *
       *The address type of the account specified in the account field.
       * </pre>
       *
       * <code>.looprpc.AddressType account_addr_type = 24;</code>
       * @param value The enum numeric value on the wire for accountAddrType to set.
       * @return This builder for chaining.
       */
      public Builder setAccountAddrTypeValue(int value) {
        accountAddrType_ = value;
        bitField0_ |= 0x00800000;
        onChanged();
        return this;
      }
      /**
       * <pre>
       *
       *The address type of the account specified in the account field.
       * </pre>
       *
       * <code>.looprpc.AddressType account_addr_type = 24;</code>
       * @return The accountAddrType.
       */
      @java.lang.Override
      public looprpc.Loop.AddressType getAccountAddrType() {
        looprpc.Loop.AddressType result = looprpc.Loop.AddressType.forNumber(accountAddrType_);
        return result == null ? looprpc.Loop.AddressType.UNRECOGNIZED : result;
      }
      /**
       * <pre>
       *
       *The address type of the account specified in the account field.
       * </pre>
       *
       * <code>.looprpc.AddressType account_addr_type = 24;</code>
       * @param value The accountAddrType to set.
       * @return This builder for chaining.
       */
      public Builder setAccountAddrType(looprpc.Loop.AddressType value) {
        if (value == null) {
          throw new NullPointerException();
        }
        bitField0_ |= 0x00800000;
        accountAddrType_ = value.getNumber();
        onChanged();
        return this;
      }
      /**
       * <pre>
       *
       *The address type of the account specified in the account field.
       * </pre>
       *
       * <code>.looprpc.AddressType account_addr_type = 24;</code>
       * @return This builder for chaining.
       */
      public Builder clearAccountAddrType() {
        bitField0_ = (bitField0_ & ~0x00800000);
        accountAddrType_ = 0;
        onChanged();
        return this;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:looprpc.LiquidityParameters)
    }

    // @@protoc_insertion_point(class_scope:looprpc.LiquidityParameters)
    private static final looprpc.Loop.LiquidityParameters DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new looprpc.Loop.LiquidityParameters();
    }

    public static looprpc.Loop.LiquidityParameters getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<LiquidityParameters>
        PARSER = new com.google.protobuf.AbstractParser<LiquidityParameters>() {
      @java.lang.Override
      public LiquidityParameters parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<LiquidityParameters> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<LiquidityParameters> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public looprpc.Loop.LiquidityParameters getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface LiquidityRuleOrBuilder extends
      // @@protoc_insertion_point(interface_extends:looprpc.LiquidityRule)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     *
     *The short channel ID of the channel that this rule should be applied to.
     *This field may not be set when the pubkey field is set.
     * </pre>
     *
     * <code>uint64 channel_id = 1 [jstype = JS_STRING];</code>
     * @return The channelId.
     */
    long getChannelId();

    /**
     * <pre>
     * The type of swap that will be dispatched for this rule.
     * </pre>
     *
     * <code>.looprpc.SwapType swap_type = 6;</code>
     * @return The enum numeric value on the wire for swapType.
     */
    int getSwapTypeValue();
    /**
     * <pre>
     * The type of swap that will be dispatched for this rule.
     * </pre>
     *
     * <code>.looprpc.SwapType swap_type = 6;</code>
     * @return The swapType.
     */
    looprpc.Loop.SwapType getSwapType();

    /**
     * <pre>
     *
     *The public key of the peer that this rule should be applied to. This field
     *may not be set when the channel id field is set.
     * </pre>
     *
     * <code>bytes pubkey = 5;</code>
     * @return The pubkey.
     */
    com.google.protobuf.ByteString getPubkey();

    /**
     * <pre>
     *
     *Type indicates the type of rule that this message rule represents. Setting
     *this value will determine which fields are used in the message. The comments
     *on each field in this message will be prefixed with the LiquidityRuleType
     *they belong to.
     * </pre>
     *
     * <code>.looprpc.LiquidityRuleType type = 2;</code>
     * @return The enum numeric value on the wire for type.
     */
    int getTypeValue();
    /**
     * <pre>
     *
     *Type indicates the type of rule that this message rule represents. Setting
     *this value will determine which fields are used in the message. The comments
     *on each field in this message will be prefixed with the LiquidityRuleType
     *they belong to.
     * </pre>
     *
     * <code>.looprpc.LiquidityRuleType type = 2;</code>
     * @return The type.
     */
    looprpc.Loop.LiquidityRuleType getType();

    /**
     * <pre>
     *
     *THRESHOLD: The percentage of total capacity that incoming capacity should
     *not drop beneath.
     * </pre>
     *
     * <code>uint32 incoming_threshold = 3;</code>
     * @return The incomingThreshold.
     */
    int getIncomingThreshold();

    /**
     * <pre>
     *
     *THRESHOLD: The percentage of total capacity that outgoing capacity should
     *not drop beneath.
     * </pre>
     *
     * <code>uint32 outgoing_threshold = 4;</code>
     * @return The outgoingThreshold.
     */
    int getOutgoingThreshold();
  }
  /**
   * Protobuf type {@code looprpc.LiquidityRule}
   */
  public static final class LiquidityRule extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:looprpc.LiquidityRule)
      LiquidityRuleOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use LiquidityRule.newBuilder() to construct.
    private LiquidityRule(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private LiquidityRule() {
      swapType_ = 0;
      pubkey_ = com.google.protobuf.ByteString.EMPTY;
      type_ = 0;
    }

    @java.lang.Override
    @SuppressWarnings({"unused"})
    protected java.lang.Object newInstance(
        UnusedPrivateParameter unused) {
      return new LiquidityRule();
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return looprpc.Loop.internal_static_looprpc_LiquidityRule_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return looprpc.Loop.internal_static_looprpc_LiquidityRule_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              looprpc.Loop.LiquidityRule.class, looprpc.Loop.LiquidityRule.Builder.class);
    }

    public static final int CHANNEL_ID_FIELD_NUMBER = 1;
    private long channelId_ = 0L;
    /**
     * <pre>
     *
     *The short channel ID of the channel that this rule should be applied to.
     *This field may not be set when the pubkey field is set.
     * </pre>
     *
     * <code>uint64 channel_id = 1 [jstype = JS_STRING];</code>
     * @return The channelId.
     */
    @java.lang.Override
    public long getChannelId() {
      return channelId_;
    }

    public static final int SWAP_TYPE_FIELD_NUMBER = 6;
    private int swapType_ = 0;
    /**
     * <pre>
     * The type of swap that will be dispatched for this rule.
     * </pre>
     *
     * <code>.looprpc.SwapType swap_type = 6;</code>
     * @return The enum numeric value on the wire for swapType.
     */
    @java.lang.Override public int getSwapTypeValue() {
      return swapType_;
    }
    /**
     * <pre>
     * The type of swap that will be dispatched for this rule.
     * </pre>
     *
     * <code>.looprpc.SwapType swap_type = 6;</code>
     * @return The swapType.
     */
    @java.lang.Override public looprpc.Loop.SwapType getSwapType() {
      looprpc.Loop.SwapType result = looprpc.Loop.SwapType.forNumber(swapType_);
      return result == null ? looprpc.Loop.SwapType.UNRECOGNIZED : result;
    }

    public static final int PUBKEY_FIELD_NUMBER = 5;
    private com.google.protobuf.ByteString pubkey_ = com.google.protobuf.ByteString.EMPTY;
    /**
     * <pre>
     *
     *The public key of the peer that this rule should be applied to. This field
     *may not be set when the channel id field is set.
     * </pre>
     *
     * <code>bytes pubkey = 5;</code>
     * @return The pubkey.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString getPubkey() {
      return pubkey_;
    }

    public static final int TYPE_FIELD_NUMBER = 2;
    private int type_ = 0;
    /**
     * <pre>
     *
     *Type indicates the type of rule that this message rule represents. Setting
     *this value will determine which fields are used in the message. The comments
     *on each field in this message will be prefixed with the LiquidityRuleType
     *they belong to.
     * </pre>
     *
     * <code>.looprpc.LiquidityRuleType type = 2;</code>
     * @return The enum numeric value on the wire for type.
     */
    @java.lang.Override public int getTypeValue() {
      return type_;
    }
    /**
     * <pre>
     *
     *Type indicates the type of rule that this message rule represents. Setting
     *this value will determine which fields are used in the message. The comments
     *on each field in this message will be prefixed with the LiquidityRuleType
     *they belong to.
     * </pre>
     *
     * <code>.looprpc.LiquidityRuleType type = 2;</code>
     * @return The type.
     */
    @java.lang.Override public looprpc.Loop.LiquidityRuleType getType() {
      looprpc.Loop.LiquidityRuleType result = looprpc.Loop.LiquidityRuleType.forNumber(type_);
      return result == null ? looprpc.Loop.LiquidityRuleType.UNRECOGNIZED : result;
    }

    public static final int INCOMING_THRESHOLD_FIELD_NUMBER = 3;
    private int incomingThreshold_ = 0;
    /**
     * <pre>
     *
     *THRESHOLD: The percentage of total capacity that incoming capacity should
     *not drop beneath.
     * </pre>
     *
     * <code>uint32 incoming_threshold = 3;</code>
     * @return The incomingThreshold.
     */
    @java.lang.Override
    public int getIncomingThreshold() {
      return incomingThreshold_;
    }

    public static final int OUTGOING_THRESHOLD_FIELD_NUMBER = 4;
    private int outgoingThreshold_ = 0;
    /**
     * <pre>
     *
     *THRESHOLD: The percentage of total capacity that outgoing capacity should
     *not drop beneath.
     * </pre>
     *
     * <code>uint32 outgoing_threshold = 4;</code>
     * @return The outgoingThreshold.
     */
    @java.lang.Override
    public int getOutgoingThreshold() {
      return outgoingThreshold_;
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (channelId_ != 0L) {
        output.writeUInt64(1, channelId_);
      }
      if (type_ != looprpc.Loop.LiquidityRuleType.UNKNOWN.getNumber()) {
        output.writeEnum(2, type_);
      }
      if (incomingThreshold_ != 0) {
        output.writeUInt32(3, incomingThreshold_);
      }
      if (outgoingThreshold_ != 0) {
        output.writeUInt32(4, outgoingThreshold_);
      }
      if (!pubkey_.isEmpty()) {
        output.writeBytes(5, pubkey_);
      }
      if (swapType_ != looprpc.Loop.SwapType.LOOP_OUT.getNumber()) {
        output.writeEnum(6, swapType_);
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (channelId_ != 0L) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt64Size(1, channelId_);
      }
      if (type_ != looprpc.Loop.LiquidityRuleType.UNKNOWN.getNumber()) {
        size += com.google.protobuf.CodedOutputStream
          .computeEnumSize(2, type_);
      }
      if (incomingThreshold_ != 0) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt32Size(3, incomingThreshold_);
      }
      if (outgoingThreshold_ != 0) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt32Size(4, outgoingThreshold_);
      }
      if (!pubkey_.isEmpty()) {
        size += com.google.protobuf.CodedOutputStream
          .computeBytesSize(5, pubkey_);
      }
      if (swapType_ != looprpc.Loop.SwapType.LOOP_OUT.getNumber()) {
        size += com.google.protobuf.CodedOutputStream
          .computeEnumSize(6, swapType_);
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof looprpc.Loop.LiquidityRule)) {
        return super.equals(obj);
      }
      looprpc.Loop.LiquidityRule other = (looprpc.Loop.LiquidityRule) obj;

      if (getChannelId()
          != other.getChannelId()) return false;
      if (swapType_ != other.swapType_) return false;
      if (!getPubkey()
          .equals(other.getPubkey())) return false;
      if (type_ != other.type_) return false;
      if (getIncomingThreshold()
          != other.getIncomingThreshold()) return false;
      if (getOutgoingThreshold()
          != other.getOutgoingThreshold()) return false;
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      hash = (37 * hash) + CHANNEL_ID_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
          getChannelId());
      hash = (37 * hash) + SWAP_TYPE_FIELD_NUMBER;
      hash = (53 * hash) + swapType_;
      hash = (37 * hash) + PUBKEY_FIELD_NUMBER;
      hash = (53 * hash) + getPubkey().hashCode();
      hash = (37 * hash) + TYPE_FIELD_NUMBER;
      hash = (53 * hash) + type_;
      hash = (37 * hash) + INCOMING_THRESHOLD_FIELD_NUMBER;
      hash = (53 * hash) + getIncomingThreshold();
      hash = (37 * hash) + OUTGOING_THRESHOLD_FIELD_NUMBER;
      hash = (53 * hash) + getOutgoingThreshold();
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static looprpc.Loop.LiquidityRule parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static looprpc.Loop.LiquidityRule parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static looprpc.Loop.LiquidityRule parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static looprpc.Loop.LiquidityRule parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static looprpc.Loop.LiquidityRule parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static looprpc.Loop.LiquidityRule parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static looprpc.Loop.LiquidityRule parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static looprpc.Loop.LiquidityRule parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static looprpc.Loop.LiquidityRule parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static looprpc.Loop.LiquidityRule parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static looprpc.Loop.LiquidityRule parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static looprpc.Loop.LiquidityRule parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(looprpc.Loop.LiquidityRule prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * Protobuf type {@code looprpc.LiquidityRule}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:looprpc.LiquidityRule)
        looprpc.Loop.LiquidityRuleOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return looprpc.Loop.internal_static_looprpc_LiquidityRule_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return looprpc.Loop.internal_static_looprpc_LiquidityRule_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                looprpc.Loop.LiquidityRule.class, looprpc.Loop.LiquidityRule.Builder.class);
      }

      // Construct using looprpc.Loop.LiquidityRule.newBuilder()
      private Builder() {

      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);

      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        channelId_ = 0L;
        swapType_ = 0;
        pubkey_ = com.google.protobuf.ByteString.EMPTY;
        type_ = 0;
        incomingThreshold_ = 0;
        outgoingThreshold_ = 0;
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return looprpc.Loop.internal_static_looprpc_LiquidityRule_descriptor;
      }

      @java.lang.Override
      public looprpc.Loop.LiquidityRule getDefaultInstanceForType() {
        return looprpc.Loop.LiquidityRule.getDefaultInstance();
      }

      @java.lang.Override
      public looprpc.Loop.LiquidityRule build() {
        looprpc.Loop.LiquidityRule result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public looprpc.Loop.LiquidityRule buildPartial() {
        looprpc.Loop.LiquidityRule result = new looprpc.Loop.LiquidityRule(this);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartial0(looprpc.Loop.LiquidityRule result) {
        int from_bitField0_ = bitField0_;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.channelId_ = channelId_;
        }
        if (((from_bitField0_ & 0x00000002) != 0)) {
          result.swapType_ = swapType_;
        }
        if (((from_bitField0_ & 0x00000004) != 0)) {
          result.pubkey_ = pubkey_;
        }
        if (((from_bitField0_ & 0x00000008) != 0)) {
          result.type_ = type_;
        }
        if (((from_bitField0_ & 0x00000010) != 0)) {
          result.incomingThreshold_ = incomingThreshold_;
        }
        if (((from_bitField0_ & 0x00000020) != 0)) {
          result.outgoingThreshold_ = outgoingThreshold_;
        }
      }

      @java.lang.Override
      public Builder clone() {
        return super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof looprpc.Loop.LiquidityRule) {
          return mergeFrom((looprpc.Loop.LiquidityRule)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(looprpc.Loop.LiquidityRule other) {
        if (other == looprpc.Loop.LiquidityRule.getDefaultInstance()) return this;
        if (other.getChannelId() != 0L) {
          setChannelId(other.getChannelId());
        }
        if (other.swapType_ != 0) {
          setSwapTypeValue(other.getSwapTypeValue());
        }
        if (other.getPubkey() != com.google.protobuf.ByteString.EMPTY) {
          setPubkey(other.getPubkey());
        }
        if (other.type_ != 0) {
          setTypeValue(other.getTypeValue());
        }
        if (other.getIncomingThreshold() != 0) {
          setIncomingThreshold(other.getIncomingThreshold());
        }
        if (other.getOutgoingThreshold() != 0) {
          setOutgoingThreshold(other.getOutgoingThreshold());
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 8: {
                channelId_ = input.readUInt64();
                bitField0_ |= 0x00000001;
                break;
              } // case 8
              case 16: {
                type_ = input.readEnum();
                bitField0_ |= 0x00000008;
                break;
              } // case 16
              case 24: {
                incomingThreshold_ = input.readUInt32();
                bitField0_ |= 0x00000010;
                break;
              } // case 24
              case 32: {
                outgoingThreshold_ = input.readUInt32();
                bitField0_ |= 0x00000020;
                break;
              } // case 32
              case 42: {
                pubkey_ = input.readBytes();
                bitField0_ |= 0x00000004;
                break;
              } // case 42
              case 48: {
                swapType_ = input.readEnum();
                bitField0_ |= 0x00000002;
                break;
              } // case 48
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private long channelId_ ;
      /**
       * <pre>
       *
       *The short channel ID of the channel that this rule should be applied to.
       *This field may not be set when the pubkey field is set.
       * </pre>
       *
       * <code>uint64 channel_id = 1 [jstype = JS_STRING];</code>
       * @return The channelId.
       */
      @java.lang.Override
      public long getChannelId() {
        return channelId_;
      }
      /**
       * <pre>
       *
       *The short channel ID of the channel that this rule should be applied to.
       *This field may not be set when the pubkey field is set.
       * </pre>
       *
       * <code>uint64 channel_id = 1 [jstype = JS_STRING];</code>
       * @param value The channelId to set.
       * @return This builder for chaining.
       */
      public Builder setChannelId(long value) {

        channelId_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       *
       *The short channel ID of the channel that this rule should be applied to.
       *This field may not be set when the pubkey field is set.
       * </pre>
       *
       * <code>uint64 channel_id = 1 [jstype = JS_STRING];</code>
       * @return This builder for chaining.
       */
      public Builder clearChannelId() {
        bitField0_ = (bitField0_ & ~0x00000001);
        channelId_ = 0L;
        onChanged();
        return this;
      }

      private int swapType_ = 0;
      /**
       * <pre>
       * The type of swap that will be dispatched for this rule.
       * </pre>
       *
       * <code>.looprpc.SwapType swap_type = 6;</code>
       * @return The enum numeric value on the wire for swapType.
       */
      @java.lang.Override public int getSwapTypeValue() {
        return swapType_;
      }
      /**
       * <pre>
       * The type of swap that will be dispatched for this rule.
       * </pre>
       *
       * <code>.looprpc.SwapType swap_type = 6;</code>
       * @param value The enum numeric value on the wire for swapType to set.
       * @return This builder for chaining.
       */
      public Builder setSwapTypeValue(int value) {
        swapType_ = value;
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The type of swap that will be dispatched for this rule.
       * </pre>
       *
       * <code>.looprpc.SwapType swap_type = 6;</code>
       * @return The swapType.
       */
      @java.lang.Override
      public looprpc.Loop.SwapType getSwapType() {
        looprpc.Loop.SwapType result = looprpc.Loop.SwapType.forNumber(swapType_);
        return result == null ? looprpc.Loop.SwapType.UNRECOGNIZED : result;
      }
      /**
       * <pre>
       * The type of swap that will be dispatched for this rule.
       * </pre>
       *
       * <code>.looprpc.SwapType swap_type = 6;</code>
       * @param value The swapType to set.
       * @return This builder for chaining.
       */
      public Builder setSwapType(looprpc.Loop.SwapType value) {
        if (value == null) {
          throw new NullPointerException();
        }
        bitField0_ |= 0x00000002;
        swapType_ = value.getNumber();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The type of swap that will be dispatched for this rule.
       * </pre>
       *
       * <code>.looprpc.SwapType swap_type = 6;</code>
       * @return This builder for chaining.
       */
      public Builder clearSwapType() {
        bitField0_ = (bitField0_ & ~0x00000002);
        swapType_ = 0;
        onChanged();
        return this;
      }

      private com.google.protobuf.ByteString pubkey_ = com.google.protobuf.ByteString.EMPTY;
      /**
       * <pre>
       *
       *The public key of the peer that this rule should be applied to. This field
       *may not be set when the channel id field is set.
       * </pre>
       *
       * <code>bytes pubkey = 5;</code>
       * @return The pubkey.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString getPubkey() {
        return pubkey_;
      }
      /**
       * <pre>
       *
       *The public key of the peer that this rule should be applied to. This field
       *may not be set when the channel id field is set.
       * </pre>
       *
       * <code>bytes pubkey = 5;</code>
       * @param value The pubkey to set.
       * @return This builder for chaining.
       */
      public Builder setPubkey(com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        pubkey_ = value;
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }
      /**
       * <pre>
       *
       *The public key of the peer that this rule should be applied to. This field
       *may not be set when the channel id field is set.
       * </pre>
       *
       * <code>bytes pubkey = 5;</code>
       * @return This builder for chaining.
       */
      public Builder clearPubkey() {
        bitField0_ = (bitField0_ & ~0x00000004);
        pubkey_ = getDefaultInstance().getPubkey();
        onChanged();
        return this;
      }

      private int type_ = 0;
      /**
       * <pre>
       *
       *Type indicates the type of rule that this message rule represents. Setting
       *this value will determine which fields are used in the message. The comments
       *on each field in this message will be prefixed with the LiquidityRuleType
       *they belong to.
       * </pre>
       *
       * <code>.looprpc.LiquidityRuleType type = 2;</code>
       * @return The enum numeric value on the wire for type.
       */
      @java.lang.Override public int getTypeValue() {
        return type_;
      }
      /**
       * <pre>
       *
       *Type indicates the type of rule that this message rule represents. Setting
       *this value will determine which fields are used in the message. The comments
       *on each field in this message will be prefixed with the LiquidityRuleType
       *they belong to.
       * </pre>
       *
       * <code>.looprpc.LiquidityRuleType type = 2;</code>
       * @param value The enum numeric value on the wire for type to set.
       * @return This builder for chaining.
       */
      public Builder setTypeValue(int value) {
        type_ = value;
        bitField0_ |= 0x00000008;
        onChanged();
        return this;
      }
      /**
       * <pre>
       *
       *Type indicates the type of rule that this message rule represents. Setting
       *this value will determine which fields are used in the message. The comments
       *on each field in this message will be prefixed with the LiquidityRuleType
       *they belong to.
       * </pre>
       *
       * <code>.looprpc.LiquidityRuleType type = 2;</code>
       * @return The type.
       */
      @java.lang.Override
      public looprpc.Loop.LiquidityRuleType getType() {
        looprpc.Loop.LiquidityRuleType result = looprpc.Loop.LiquidityRuleType.forNumber(type_);
        return result == null ? looprpc.Loop.LiquidityRuleType.UNRECOGNIZED : result;
      }
      /**
       * <pre>
       *
       *Type indicates the type of rule that this message rule represents. Setting
       *this value will determine which fields are used in the message. The comments
       *on each field in this message will be prefixed with the LiquidityRuleType
       *they belong to.
       * </pre>
       *
       * <code>.looprpc.LiquidityRuleType type = 2;</code>
       * @param value The type to set.
       * @return This builder for chaining.
       */
      public Builder setType(looprpc.Loop.LiquidityRuleType value) {
        if (value == null) {
          throw new NullPointerException();
        }
        bitField0_ |= 0x00000008;
        type_ = value.getNumber();
        onChanged();
        return this;
      }
      /**
       * <pre>
       *
       *Type indicates the type of rule that this message rule represents. Setting
       *this value will determine which fields are used in the message. The comments
       *on each field in this message will be prefixed with the LiquidityRuleType
       *they belong to.
       * </pre>
       *
       * <code>.looprpc.LiquidityRuleType type = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearType() {
        bitField0_ = (bitField0_ & ~0x00000008);
        type_ = 0;
        onChanged();
        return this;
      }

      private int incomingThreshold_ ;
      /**
       * <pre>
       *
       *THRESHOLD: The percentage of total capacity that incoming capacity should
       *not drop beneath.
       * </pre>
       *
       * <code>uint32 incoming_threshold = 3;</code>
       * @return The incomingThreshold.
       */
      @java.lang.Override
      public int getIncomingThreshold() {
        return incomingThreshold_;
      }
      /**
       * <pre>
       *
       *THRESHOLD: The percentage of total capacity that incoming capacity should
       *not drop beneath.
       * </pre>
       *
       * <code>uint32 incoming_threshold = 3;</code>
       * @param value The incomingThreshold to set.
       * @return This builder for chaining.
       */
      public Builder setIncomingThreshold(int value) {

        incomingThreshold_ = value;
        bitField0_ |= 0x00000010;
        onChanged();
        return this;
      }
      /**
       * <pre>
       *
       *THRESHOLD: The percentage of total capacity that incoming capacity should
       *not drop beneath.
       * </pre>
       *
       * <code>uint32 incoming_threshold = 3;</code>
       * @return This builder for chaining.
       */
      public Builder clearIncomingThreshold() {
        bitField0_ = (bitField0_ & ~0x00000010);
        incomingThreshold_ = 0;
        onChanged();
        return this;
      }

      private int outgoingThreshold_ ;
      /**
       * <pre>
       *
       *THRESHOLD: The percentage of total capacity that outgoing capacity should
       *not drop beneath.
       * </pre>
       *
       * <code>uint32 outgoing_threshold = 4;</code>
       * @return The outgoingThreshold.
       */
      @java.lang.Override
      public int getOutgoingThreshold() {
        return outgoingThreshold_;
      }
      /**
       * <pre>
       *
       *THRESHOLD: The percentage of total capacity that outgoing capacity should
       *not drop beneath.
       * </pre>
       *
       * <code>uint32 outgoing_threshold = 4;</code>
       * @param value The outgoingThreshold to set.
       * @return This builder for chaining.
       */
      public Builder setOutgoingThreshold(int value) {

        outgoingThreshold_ = value;
        bitField0_ |= 0x00000020;
        onChanged();
        return this;
      }
      /**
       * <pre>
       *
       *THRESHOLD: The percentage of total capacity that outgoing capacity should
       *not drop beneath.
       * </pre>
       *
       * <code>uint32 outgoing_threshold = 4;</code>
       * @return This builder for chaining.
       */
      public Builder clearOutgoingThreshold() {
        bitField0_ = (bitField0_ & ~0x00000020);
        outgoingThreshold_ = 0;
        onChanged();
        return this;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:looprpc.LiquidityRule)
    }

    // @@protoc_insertion_point(class_scope:looprpc.LiquidityRule)
    private static final looprpc.Loop.LiquidityRule DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new looprpc.Loop.LiquidityRule();
    }

    public static looprpc.Loop.LiquidityRule getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<LiquidityRule>
        PARSER = new com.google.protobuf.AbstractParser<LiquidityRule>() {
      @java.lang.Override
      public LiquidityRule parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<LiquidityRule> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<LiquidityRule> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public looprpc.Loop.LiquidityRule getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface SetLiquidityParamsRequestOrBuilder extends
      // @@protoc_insertion_point(interface_extends:looprpc.SetLiquidityParamsRequest)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     *
     *Parameters is the desired new set of parameters for the liquidity management
     *subsystem. Note that the current set of parameters will be completely
     *overwritten by the parameters provided (if they are valid), so the full set
     *of parameters should be provided for each call.
     * </pre>
     *
     * <code>.looprpc.LiquidityParameters parameters = 1;</code>
     * @return Whether the parameters field is set.
     */
    boolean hasParameters();
    /**
     * <pre>
     *
     *Parameters is the desired new set of parameters for the liquidity management
     *subsystem. Note that the current set of parameters will be completely
     *overwritten by the parameters provided (if they are valid), so the full set
     *of parameters should be provided for each call.
     * </pre>
     *
     * <code>.looprpc.LiquidityParameters parameters = 1;</code>
     * @return The parameters.
     */
    looprpc.Loop.LiquidityParameters getParameters();
    /**
     * <pre>
     *
     *Parameters is the desired new set of parameters for the liquidity management
     *subsystem. Note that the current set of parameters will be completely
     *overwritten by the parameters provided (if they are valid), so the full set
     *of parameters should be provided for each call.
     * </pre>
     *
     * <code>.looprpc.LiquidityParameters parameters = 1;</code>
     */
    looprpc.Loop.LiquidityParametersOrBuilder getParametersOrBuilder();
  }
  /**
   * Protobuf type {@code looprpc.SetLiquidityParamsRequest}
   */
  public static final class SetLiquidityParamsRequest extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:looprpc.SetLiquidityParamsRequest)
      SetLiquidityParamsRequestOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use SetLiquidityParamsRequest.newBuilder() to construct.
    private SetLiquidityParamsRequest(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private SetLiquidityParamsRequest() {
    }

    @java.lang.Override
    @SuppressWarnings({"unused"})
    protected java.lang.Object newInstance(
        UnusedPrivateParameter unused) {
      return new SetLiquidityParamsRequest();
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return looprpc.Loop.internal_static_looprpc_SetLiquidityParamsRequest_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return looprpc.Loop.internal_static_looprpc_SetLiquidityParamsRequest_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              looprpc.Loop.SetLiquidityParamsRequest.class, looprpc.Loop.SetLiquidityParamsRequest.Builder.class);
    }

    private int bitField0_;
    public static final int PARAMETERS_FIELD_NUMBER = 1;
    private looprpc.Loop.LiquidityParameters parameters_;
    /**
     * <pre>
     *
     *Parameters is the desired new set of parameters for the liquidity management
     *subsystem. Note that the current set of parameters will be completely
     *overwritten by the parameters provided (if they are valid), so the full set
     *of parameters should be provided for each call.
     * </pre>
     *
     * <code>.looprpc.LiquidityParameters parameters = 1;</code>
     * @return Whether the parameters field is set.
     */
    @java.lang.Override
    public boolean hasParameters() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     *
     *Parameters is the desired new set of parameters for the liquidity management
     *subsystem. Note that the current set of parameters will be completely
     *overwritten by the parameters provided (if they are valid), so the full set
     *of parameters should be provided for each call.
     * </pre>
     *
     * <code>.looprpc.LiquidityParameters parameters = 1;</code>
     * @return The parameters.
     */
    @java.lang.Override
    public looprpc.Loop.LiquidityParameters getParameters() {
      return parameters_ == null ? looprpc.Loop.LiquidityParameters.getDefaultInstance() : parameters_;
    }
    /**
     * <pre>
     *
     *Parameters is the desired new set of parameters for the liquidity management
     *subsystem. Note that the current set of parameters will be completely
     *overwritten by the parameters provided (if they are valid), so the full set
     *of parameters should be provided for each call.
     * </pre>
     *
     * <code>.looprpc.LiquidityParameters parameters = 1;</code>
     */
    @java.lang.Override
    public looprpc.Loop.LiquidityParametersOrBuilder getParametersOrBuilder() {
      return parameters_ == null ? looprpc.Loop.LiquidityParameters.getDefaultInstance() : parameters_;
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) != 0)) {
        output.writeMessage(1, getParameters());
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(1, getParameters());
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof looprpc.Loop.SetLiquidityParamsRequest)) {
        return super.equals(obj);
      }
      looprpc.Loop.SetLiquidityParamsRequest other = (looprpc.Loop.SetLiquidityParamsRequest) obj;

      if (hasParameters() != other.hasParameters()) return false;
      if (hasParameters()) {
        if (!getParameters()
            .equals(other.getParameters())) return false;
      }
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasParameters()) {
        hash = (37 * hash) + PARAMETERS_FIELD_NUMBER;
        hash = (53 * hash) + getParameters().hashCode();
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static looprpc.Loop.SetLiquidityParamsRequest parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static looprpc.Loop.SetLiquidityParamsRequest parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static looprpc.Loop.SetLiquidityParamsRequest parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static looprpc.Loop.SetLiquidityParamsRequest parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static looprpc.Loop.SetLiquidityParamsRequest parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static looprpc.Loop.SetLiquidityParamsRequest parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static looprpc.Loop.SetLiquidityParamsRequest parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static looprpc.Loop.SetLiquidityParamsRequest parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static looprpc.Loop.SetLiquidityParamsRequest parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static looprpc.Loop.SetLiquidityParamsRequest parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static looprpc.Loop.SetLiquidityParamsRequest parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static looprpc.Loop.SetLiquidityParamsRequest parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(looprpc.Loop.SetLiquidityParamsRequest prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * Protobuf type {@code looprpc.SetLiquidityParamsRequest}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:looprpc.SetLiquidityParamsRequest)
        looprpc.Loop.SetLiquidityParamsRequestOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return looprpc.Loop.internal_static_looprpc_SetLiquidityParamsRequest_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return looprpc.Loop.internal_static_looprpc_SetLiquidityParamsRequest_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                looprpc.Loop.SetLiquidityParamsRequest.class, looprpc.Loop.SetLiquidityParamsRequest.Builder.class);
      }

      // Construct using looprpc.Loop.SetLiquidityParamsRequest.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
          getParametersFieldBuilder();
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        parameters_ = null;
        if (parametersBuilder_ != null) {
          parametersBuilder_.dispose();
          parametersBuilder_ = null;
        }
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return looprpc.Loop.internal_static_looprpc_SetLiquidityParamsRequest_descriptor;
      }

      @java.lang.Override
      public looprpc.Loop.SetLiquidityParamsRequest getDefaultInstanceForType() {
        return looprpc.Loop.SetLiquidityParamsRequest.getDefaultInstance();
      }

      @java.lang.Override
      public looprpc.Loop.SetLiquidityParamsRequest build() {
        looprpc.Loop.SetLiquidityParamsRequest result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public looprpc.Loop.SetLiquidityParamsRequest buildPartial() {
        looprpc.Loop.SetLiquidityParamsRequest result = new looprpc.Loop.SetLiquidityParamsRequest(this);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartial0(looprpc.Loop.SetLiquidityParamsRequest result) {
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.parameters_ = parametersBuilder_ == null
              ? parameters_
              : parametersBuilder_.build();
          to_bitField0_ |= 0x00000001;
        }
        result.bitField0_ |= to_bitField0_;
      }

      @java.lang.Override
      public Builder clone() {
        return super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof looprpc.Loop.SetLiquidityParamsRequest) {
          return mergeFrom((looprpc.Loop.SetLiquidityParamsRequest)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(looprpc.Loop.SetLiquidityParamsRequest other) {
        if (other == looprpc.Loop.SetLiquidityParamsRequest.getDefaultInstance()) return this;
        if (other.hasParameters()) {
          mergeParameters(other.getParameters());
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10: {
                input.readMessage(
                    getParametersFieldBuilder().getBuilder(),
                    extensionRegistry);
                bitField0_ |= 0x00000001;
                break;
              } // case 10
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private looprpc.Loop.LiquidityParameters parameters_;
      private com.google.protobuf.SingleFieldBuilderV3<
          looprpc.Loop.LiquidityParameters, looprpc.Loop.LiquidityParameters.Builder, looprpc.Loop.LiquidityParametersOrBuilder> parametersBuilder_;
      /**
       * <pre>
       *
       *Parameters is the desired new set of parameters for the liquidity management
       *subsystem. Note that the current set of parameters will be completely
       *overwritten by the parameters provided (if they are valid), so the full set
       *of parameters should be provided for each call.
       * </pre>
       *
       * <code>.looprpc.LiquidityParameters parameters = 1;</code>
       * @return Whether the parameters field is set.
       */
      public boolean hasParameters() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <pre>
       *
       *Parameters is the desired new set of parameters for the liquidity management
       *subsystem. Note that the current set of parameters will be completely
       *overwritten by the parameters provided (if they are valid), so the full set
       *of parameters should be provided for each call.
       * </pre>
       *
       * <code>.looprpc.LiquidityParameters parameters = 1;</code>
       * @return The parameters.
       */
      public looprpc.Loop.LiquidityParameters getParameters() {
        if (parametersBuilder_ == null) {
          return parameters_ == null ? looprpc.Loop.LiquidityParameters.getDefaultInstance() : parameters_;
        } else {
          return parametersBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       *
       *Parameters is the desired new set of parameters for the liquidity management
       *subsystem. Note that the current set of parameters will be completely
       *overwritten by the parameters provided (if they are valid), so the full set
       *of parameters should be provided for each call.
       * </pre>
       *
       * <code>.looprpc.LiquidityParameters parameters = 1;</code>
       */
      public Builder setParameters(looprpc.Loop.LiquidityParameters value) {
        if (parametersBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          parameters_ = value;
        } else {
          parametersBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       *
       *Parameters is the desired new set of parameters for the liquidity management
       *subsystem. Note that the current set of parameters will be completely
       *overwritten by the parameters provided (if they are valid), so the full set
       *of parameters should be provided for each call.
       * </pre>
       *
       * <code>.looprpc.LiquidityParameters parameters = 1;</code>
       */
      public Builder setParameters(
          looprpc.Loop.LiquidityParameters.Builder builderForValue) {
        if (parametersBuilder_ == null) {
          parameters_ = builderForValue.build();
        } else {
          parametersBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       *
       *Parameters is the desired new set of parameters for the liquidity management
       *subsystem. Note that the current set of parameters will be completely
       *overwritten by the parameters provided (if they are valid), so the full set
       *of parameters should be provided for each call.
       * </pre>
       *
       * <code>.looprpc.LiquidityParameters parameters = 1;</code>
       */
      public Builder mergeParameters(looprpc.Loop.LiquidityParameters value) {
        if (parametersBuilder_ == null) {
          if (((bitField0_ & 0x00000001) != 0) &&
            parameters_ != null &&
            parameters_ != looprpc.Loop.LiquidityParameters.getDefaultInstance()) {
            getParametersBuilder().mergeFrom(value);
          } else {
            parameters_ = value;
          }
        } else {
          parametersBuilder_.mergeFrom(value);
        }
        if (parameters_ != null) {
          bitField0_ |= 0x00000001;
          onChanged();
        }
        return this;
      }
      /**
       * <pre>
       *
       *Parameters is the desired new set of parameters for the liquidity management
       *subsystem. Note that the current set of parameters will be completely
       *overwritten by the parameters provided (if they are valid), so the full set
       *of parameters should be provided for each call.
       * </pre>
       *
       * <code>.looprpc.LiquidityParameters parameters = 1;</code>
       */
      public Builder clearParameters() {
        bitField0_ = (bitField0_ & ~0x00000001);
        parameters_ = null;
        if (parametersBuilder_ != null) {
          parametersBuilder_.dispose();
          parametersBuilder_ = null;
        }
        onChanged();
        return this;
      }
      /**
       * <pre>
       *
       *Parameters is the desired new set of parameters for the liquidity management
       *subsystem. Note that the current set of parameters will be completely
       *overwritten by the parameters provided (if they are valid), so the full set
       *of parameters should be provided for each call.
       * </pre>
       *
       * <code>.looprpc.LiquidityParameters parameters = 1;</code>
       */
      public looprpc.Loop.LiquidityParameters.Builder getParametersBuilder() {
        bitField0_ |= 0x00000001;
        onChanged();
        return getParametersFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       *
       *Parameters is the desired new set of parameters for the liquidity management
       *subsystem. Note that the current set of parameters will be completely
       *overwritten by the parameters provided (if they are valid), so the full set
       *of parameters should be provided for each call.
       * </pre>
       *
       * <code>.looprpc.LiquidityParameters parameters = 1;</code>
       */
      public looprpc.Loop.LiquidityParametersOrBuilder getParametersOrBuilder() {
        if (parametersBuilder_ != null) {
          return parametersBuilder_.getMessageOrBuilder();
        } else {
          return parameters_ == null ?
              looprpc.Loop.LiquidityParameters.getDefaultInstance() : parameters_;
        }
      }
      /**
       * <pre>
       *
       *Parameters is the desired new set of parameters for the liquidity management
       *subsystem. Note that the current set of parameters will be completely
       *overwritten by the parameters provided (if they are valid), so the full set
       *of parameters should be provided for each call.
       * </pre>
       *
       * <code>.looprpc.LiquidityParameters parameters = 1;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          looprpc.Loop.LiquidityParameters, looprpc.Loop.LiquidityParameters.Builder, looprpc.Loop.LiquidityParametersOrBuilder> 
          getParametersFieldBuilder() {
        if (parametersBuilder_ == null) {
          parametersBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              looprpc.Loop.LiquidityParameters, looprpc.Loop.LiquidityParameters.Builder, looprpc.Loop.LiquidityParametersOrBuilder>(
                  getParameters(),
                  getParentForChildren(),
                  isClean());
          parameters_ = null;
        }
        return parametersBuilder_;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:looprpc.SetLiquidityParamsRequest)
    }

    // @@protoc_insertion_point(class_scope:looprpc.SetLiquidityParamsRequest)
    private static final looprpc.Loop.SetLiquidityParamsRequest DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new looprpc.Loop.SetLiquidityParamsRequest();
    }

    public static looprpc.Loop.SetLiquidityParamsRequest getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<SetLiquidityParamsRequest>
        PARSER = new com.google.protobuf.AbstractParser<SetLiquidityParamsRequest>() {
      @java.lang.Override
      public SetLiquidityParamsRequest parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<SetLiquidityParamsRequest> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<SetLiquidityParamsRequest> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public looprpc.Loop.SetLiquidityParamsRequest getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface SetLiquidityParamsResponseOrBuilder extends
      // @@protoc_insertion_point(interface_extends:looprpc.SetLiquidityParamsResponse)
      com.google.protobuf.MessageOrBuilder {
  }
  /**
   * Protobuf type {@code looprpc.SetLiquidityParamsResponse}
   */
  public static final class SetLiquidityParamsResponse extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:looprpc.SetLiquidityParamsResponse)
      SetLiquidityParamsResponseOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use SetLiquidityParamsResponse.newBuilder() to construct.
    private SetLiquidityParamsResponse(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private SetLiquidityParamsResponse() {
    }

    @java.lang.Override
    @SuppressWarnings({"unused"})
    protected java.lang.Object newInstance(
        UnusedPrivateParameter unused) {
      return new SetLiquidityParamsResponse();
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return looprpc.Loop.internal_static_looprpc_SetLiquidityParamsResponse_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return looprpc.Loop.internal_static_looprpc_SetLiquidityParamsResponse_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              looprpc.Loop.SetLiquidityParamsResponse.class, looprpc.Loop.SetLiquidityParamsResponse.Builder.class);
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof looprpc.Loop.SetLiquidityParamsResponse)) {
        return super.equals(obj);
      }
      looprpc.Loop.SetLiquidityParamsResponse other = (looprpc.Loop.SetLiquidityParamsResponse) obj;

      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static looprpc.Loop.SetLiquidityParamsResponse parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static looprpc.Loop.SetLiquidityParamsResponse parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static looprpc.Loop.SetLiquidityParamsResponse parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static looprpc.Loop.SetLiquidityParamsResponse parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static looprpc.Loop.SetLiquidityParamsResponse parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static looprpc.Loop.SetLiquidityParamsResponse parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static looprpc.Loop.SetLiquidityParamsResponse parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static looprpc.Loop.SetLiquidityParamsResponse parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static looprpc.Loop.SetLiquidityParamsResponse parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static looprpc.Loop.SetLiquidityParamsResponse parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static looprpc.Loop.SetLiquidityParamsResponse parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static looprpc.Loop.SetLiquidityParamsResponse parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(looprpc.Loop.SetLiquidityParamsResponse prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * Protobuf type {@code looprpc.SetLiquidityParamsResponse}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:looprpc.SetLiquidityParamsResponse)
        looprpc.Loop.SetLiquidityParamsResponseOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return looprpc.Loop.internal_static_looprpc_SetLiquidityParamsResponse_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return looprpc.Loop.internal_static_looprpc_SetLiquidityParamsResponse_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                looprpc.Loop.SetLiquidityParamsResponse.class, looprpc.Loop.SetLiquidityParamsResponse.Builder.class);
      }

      // Construct using looprpc.Loop.SetLiquidityParamsResponse.newBuilder()
      private Builder() {

      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);

      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return looprpc.Loop.internal_static_looprpc_SetLiquidityParamsResponse_descriptor;
      }

      @java.lang.Override
      public looprpc.Loop.SetLiquidityParamsResponse getDefaultInstanceForType() {
        return looprpc.Loop.SetLiquidityParamsResponse.getDefaultInstance();
      }

      @java.lang.Override
      public looprpc.Loop.SetLiquidityParamsResponse build() {
        looprpc.Loop.SetLiquidityParamsResponse result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public looprpc.Loop.SetLiquidityParamsResponse buildPartial() {
        looprpc.Loop.SetLiquidityParamsResponse result = new looprpc.Loop.SetLiquidityParamsResponse(this);
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof looprpc.Loop.SetLiquidityParamsResponse) {
          return mergeFrom((looprpc.Loop.SetLiquidityParamsResponse)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(looprpc.Loop.SetLiquidityParamsResponse other) {
        if (other == looprpc.Loop.SetLiquidityParamsResponse.getDefaultInstance()) return this;
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:looprpc.SetLiquidityParamsResponse)
    }

    // @@protoc_insertion_point(class_scope:looprpc.SetLiquidityParamsResponse)
    private static final looprpc.Loop.SetLiquidityParamsResponse DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new looprpc.Loop.SetLiquidityParamsResponse();
    }

    public static looprpc.Loop.SetLiquidityParamsResponse getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<SetLiquidityParamsResponse>
        PARSER = new com.google.protobuf.AbstractParser<SetLiquidityParamsResponse>() {
      @java.lang.Override
      public SetLiquidityParamsResponse parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<SetLiquidityParamsResponse> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<SetLiquidityParamsResponse> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public looprpc.Loop.SetLiquidityParamsResponse getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface SuggestSwapsRequestOrBuilder extends
      // @@protoc_insertion_point(interface_extends:looprpc.SuggestSwapsRequest)
      com.google.protobuf.MessageOrBuilder {
  }
  /**
   * Protobuf type {@code looprpc.SuggestSwapsRequest}
   */
  public static final class SuggestSwapsRequest extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:looprpc.SuggestSwapsRequest)
      SuggestSwapsRequestOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use SuggestSwapsRequest.newBuilder() to construct.
    private SuggestSwapsRequest(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private SuggestSwapsRequest() {
    }

    @java.lang.Override
    @SuppressWarnings({"unused"})
    protected java.lang.Object newInstance(
        UnusedPrivateParameter unused) {
      return new SuggestSwapsRequest();
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return looprpc.Loop.internal_static_looprpc_SuggestSwapsRequest_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return looprpc.Loop.internal_static_looprpc_SuggestSwapsRequest_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              looprpc.Loop.SuggestSwapsRequest.class, looprpc.Loop.SuggestSwapsRequest.Builder.class);
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof looprpc.Loop.SuggestSwapsRequest)) {
        return super.equals(obj);
      }
      looprpc.Loop.SuggestSwapsRequest other = (looprpc.Loop.SuggestSwapsRequest) obj;

      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static looprpc.Loop.SuggestSwapsRequest parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static looprpc.Loop.SuggestSwapsRequest parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static looprpc.Loop.SuggestSwapsRequest parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static looprpc.Loop.SuggestSwapsRequest parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static looprpc.Loop.SuggestSwapsRequest parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static looprpc.Loop.SuggestSwapsRequest parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static looprpc.Loop.SuggestSwapsRequest parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static looprpc.Loop.SuggestSwapsRequest parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static looprpc.Loop.SuggestSwapsRequest parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static looprpc.Loop.SuggestSwapsRequest parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static looprpc.Loop.SuggestSwapsRequest parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static looprpc.Loop.SuggestSwapsRequest parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(looprpc.Loop.SuggestSwapsRequest prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * Protobuf type {@code looprpc.SuggestSwapsRequest}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:looprpc.SuggestSwapsRequest)
        looprpc.Loop.SuggestSwapsRequestOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return looprpc.Loop.internal_static_looprpc_SuggestSwapsRequest_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return looprpc.Loop.internal_static_looprpc_SuggestSwapsRequest_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                looprpc.Loop.SuggestSwapsRequest.class, looprpc.Loop.SuggestSwapsRequest.Builder.class);
      }

      // Construct using looprpc.Loop.SuggestSwapsRequest.newBuilder()
      private Builder() {

      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);

      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return looprpc.Loop.internal_static_looprpc_SuggestSwapsRequest_descriptor;
      }

      @java.lang.Override
      public looprpc.Loop.SuggestSwapsRequest getDefaultInstanceForType() {
        return looprpc.Loop.SuggestSwapsRequest.getDefaultInstance();
      }

      @java.lang.Override
      public looprpc.Loop.SuggestSwapsRequest build() {
        looprpc.Loop.SuggestSwapsRequest result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public looprpc.Loop.SuggestSwapsRequest buildPartial() {
        looprpc.Loop.SuggestSwapsRequest result = new looprpc.Loop.SuggestSwapsRequest(this);
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof looprpc.Loop.SuggestSwapsRequest) {
          return mergeFrom((looprpc.Loop.SuggestSwapsRequest)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(looprpc.Loop.SuggestSwapsRequest other) {
        if (other == looprpc.Loop.SuggestSwapsRequest.getDefaultInstance()) return this;
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:looprpc.SuggestSwapsRequest)
    }

    // @@protoc_insertion_point(class_scope:looprpc.SuggestSwapsRequest)
    private static final looprpc.Loop.SuggestSwapsRequest DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new looprpc.Loop.SuggestSwapsRequest();
    }

    public static looprpc.Loop.SuggestSwapsRequest getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<SuggestSwapsRequest>
        PARSER = new com.google.protobuf.AbstractParser<SuggestSwapsRequest>() {
      @java.lang.Override
      public SuggestSwapsRequest parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<SuggestSwapsRequest> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<SuggestSwapsRequest> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public looprpc.Loop.SuggestSwapsRequest getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface DisqualifiedOrBuilder extends
      // @@protoc_insertion_point(interface_extends:looprpc.Disqualified)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     *
     *The short channel ID of the channel that was excluded from our suggestions.
     * </pre>
     *
     * <code>uint64 channel_id = 1 [jstype = JS_STRING];</code>
     * @return The channelId.
     */
    long getChannelId();

    /**
     * <pre>
     *
     *The public key of the peer that was excluded from our suggestions.
     * </pre>
     *
     * <code>bytes pubkey = 3;</code>
     * @return The pubkey.
     */
    com.google.protobuf.ByteString getPubkey();

    /**
     * <pre>
     *
     *The reason that we excluded the channel from the our suggestions.
     * </pre>
     *
     * <code>.looprpc.AutoReason reason = 2;</code>
     * @return The enum numeric value on the wire for reason.
     */
    int getReasonValue();
    /**
     * <pre>
     *
     *The reason that we excluded the channel from the our suggestions.
     * </pre>
     *
     * <code>.looprpc.AutoReason reason = 2;</code>
     * @return The reason.
     */
    looprpc.Loop.AutoReason getReason();
  }
  /**
   * Protobuf type {@code looprpc.Disqualified}
   */
  public static final class Disqualified extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:looprpc.Disqualified)
      DisqualifiedOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use Disqualified.newBuilder() to construct.
    private Disqualified(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private Disqualified() {
      pubkey_ = com.google.protobuf.ByteString.EMPTY;
      reason_ = 0;
    }

    @java.lang.Override
    @SuppressWarnings({"unused"})
    protected java.lang.Object newInstance(
        UnusedPrivateParameter unused) {
      return new Disqualified();
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return looprpc.Loop.internal_static_looprpc_Disqualified_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return looprpc.Loop.internal_static_looprpc_Disqualified_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              looprpc.Loop.Disqualified.class, looprpc.Loop.Disqualified.Builder.class);
    }

    public static final int CHANNEL_ID_FIELD_NUMBER = 1;
    private long channelId_ = 0L;
    /**
     * <pre>
     *
     *The short channel ID of the channel that was excluded from our suggestions.
     * </pre>
     *
     * <code>uint64 channel_id = 1 [jstype = JS_STRING];</code>
     * @return The channelId.
     */
    @java.lang.Override
    public long getChannelId() {
      return channelId_;
    }

    public static final int PUBKEY_FIELD_NUMBER = 3;
    private com.google.protobuf.ByteString pubkey_ = com.google.protobuf.ByteString.EMPTY;
    /**
     * <pre>
     *
     *The public key of the peer that was excluded from our suggestions.
     * </pre>
     *
     * <code>bytes pubkey = 3;</code>
     * @return The pubkey.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString getPubkey() {
      return pubkey_;
    }

    public static final int REASON_FIELD_NUMBER = 2;
    private int reason_ = 0;
    /**
     * <pre>
     *
     *The reason that we excluded the channel from the our suggestions.
     * </pre>
     *
     * <code>.looprpc.AutoReason reason = 2;</code>
     * @return The enum numeric value on the wire for reason.
     */
    @java.lang.Override public int getReasonValue() {
      return reason_;
    }
    /**
     * <pre>
     *
     *The reason that we excluded the channel from the our suggestions.
     * </pre>
     *
     * <code>.looprpc.AutoReason reason = 2;</code>
     * @return The reason.
     */
    @java.lang.Override public looprpc.Loop.AutoReason getReason() {
      looprpc.Loop.AutoReason result = looprpc.Loop.AutoReason.forNumber(reason_);
      return result == null ? looprpc.Loop.AutoReason.UNRECOGNIZED : result;
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (channelId_ != 0L) {
        output.writeUInt64(1, channelId_);
      }
      if (reason_ != looprpc.Loop.AutoReason.AUTO_REASON_UNKNOWN.getNumber()) {
        output.writeEnum(2, reason_);
      }
      if (!pubkey_.isEmpty()) {
        output.writeBytes(3, pubkey_);
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (channelId_ != 0L) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt64Size(1, channelId_);
      }
      if (reason_ != looprpc.Loop.AutoReason.AUTO_REASON_UNKNOWN.getNumber()) {
        size += com.google.protobuf.CodedOutputStream
          .computeEnumSize(2, reason_);
      }
      if (!pubkey_.isEmpty()) {
        size += com.google.protobuf.CodedOutputStream
          .computeBytesSize(3, pubkey_);
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof looprpc.Loop.Disqualified)) {
        return super.equals(obj);
      }
      looprpc.Loop.Disqualified other = (looprpc.Loop.Disqualified) obj;

      if (getChannelId()
          != other.getChannelId()) return false;
      if (!getPubkey()
          .equals(other.getPubkey())) return false;
      if (reason_ != other.reason_) return false;
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      hash = (37 * hash) + CHANNEL_ID_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
          getChannelId());
      hash = (37 * hash) + PUBKEY_FIELD_NUMBER;
      hash = (53 * hash) + getPubkey().hashCode();
      hash = (37 * hash) + REASON_FIELD_NUMBER;
      hash = (53 * hash) + reason_;
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static looprpc.Loop.Disqualified parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static looprpc.Loop.Disqualified parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static looprpc.Loop.Disqualified parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static looprpc.Loop.Disqualified parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static looprpc.Loop.Disqualified parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static looprpc.Loop.Disqualified parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static looprpc.Loop.Disqualified parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static looprpc.Loop.Disqualified parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static looprpc.Loop.Disqualified parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static looprpc.Loop.Disqualified parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static looprpc.Loop.Disqualified parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static looprpc.Loop.Disqualified parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(looprpc.Loop.Disqualified prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * Protobuf type {@code looprpc.Disqualified}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:looprpc.Disqualified)
        looprpc.Loop.DisqualifiedOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return looprpc.Loop.internal_static_looprpc_Disqualified_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return looprpc.Loop.internal_static_looprpc_Disqualified_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                looprpc.Loop.Disqualified.class, looprpc.Loop.Disqualified.Builder.class);
      }

      // Construct using looprpc.Loop.Disqualified.newBuilder()
      private Builder() {

      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);

      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        channelId_ = 0L;
        pubkey_ = com.google.protobuf.ByteString.EMPTY;
        reason_ = 0;
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return looprpc.Loop.internal_static_looprpc_Disqualified_descriptor;
      }

      @java.lang.Override
      public looprpc.Loop.Disqualified getDefaultInstanceForType() {
        return looprpc.Loop.Disqualified.getDefaultInstance();
      }

      @java.lang.Override
      public looprpc.Loop.Disqualified build() {
        looprpc.Loop.Disqualified result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public looprpc.Loop.Disqualified buildPartial() {
        looprpc.Loop.Disqualified result = new looprpc.Loop.Disqualified(this);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartial0(looprpc.Loop.Disqualified result) {
        int from_bitField0_ = bitField0_;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.channelId_ = channelId_;
        }
        if (((from_bitField0_ & 0x00000002) != 0)) {
          result.pubkey_ = pubkey_;
        }
        if (((from_bitField0_ & 0x00000004) != 0)) {
          result.reason_ = reason_;
        }
      }

      @java.lang.Override
      public Builder clone() {
        return super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof looprpc.Loop.Disqualified) {
          return mergeFrom((looprpc.Loop.Disqualified)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(looprpc.Loop.Disqualified other) {
        if (other == looprpc.Loop.Disqualified.getDefaultInstance()) return this;
        if (other.getChannelId() != 0L) {
          setChannelId(other.getChannelId());
        }
        if (other.getPubkey() != com.google.protobuf.ByteString.EMPTY) {
          setPubkey(other.getPubkey());
        }
        if (other.reason_ != 0) {
          setReasonValue(other.getReasonValue());
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 8: {
                channelId_ = input.readUInt64();
                bitField0_ |= 0x00000001;
                break;
              } // case 8
              case 16: {
                reason_ = input.readEnum();
                bitField0_ |= 0x00000004;
                break;
              } // case 16
              case 26: {
                pubkey_ = input.readBytes();
                bitField0_ |= 0x00000002;
                break;
              } // case 26
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private long channelId_ ;
      /**
       * <pre>
       *
       *The short channel ID of the channel that was excluded from our suggestions.
       * </pre>
       *
       * <code>uint64 channel_id = 1 [jstype = JS_STRING];</code>
       * @return The channelId.
       */
      @java.lang.Override
      public long getChannelId() {
        return channelId_;
      }
      /**
       * <pre>
       *
       *The short channel ID of the channel that was excluded from our suggestions.
       * </pre>
       *
       * <code>uint64 channel_id = 1 [jstype = JS_STRING];</code>
       * @param value The channelId to set.
       * @return This builder for chaining.
       */
      public Builder setChannelId(long value) {

        channelId_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       *
       *The short channel ID of the channel that was excluded from our suggestions.
       * </pre>
       *
       * <code>uint64 channel_id = 1 [jstype = JS_STRING];</code>
       * @return This builder for chaining.
       */
      public Builder clearChannelId() {
        bitField0_ = (bitField0_ & ~0x00000001);
        channelId_ = 0L;
        onChanged();
        return this;
      }

      private com.google.protobuf.ByteString pubkey_ = com.google.protobuf.ByteString.EMPTY;
      /**
       * <pre>
       *
       *The public key of the peer that was excluded from our suggestions.
       * </pre>
       *
       * <code>bytes pubkey = 3;</code>
       * @return The pubkey.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString getPubkey() {
        return pubkey_;
      }
      /**
       * <pre>
       *
       *The public key of the peer that was excluded from our suggestions.
       * </pre>
       *
       * <code>bytes pubkey = 3;</code>
       * @param value The pubkey to set.
       * @return This builder for chaining.
       */
      public Builder setPubkey(com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        pubkey_ = value;
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       *
       *The public key of the peer that was excluded from our suggestions.
       * </pre>
       *
       * <code>bytes pubkey = 3;</code>
       * @return This builder for chaining.
       */
      public Builder clearPubkey() {
        bitField0_ = (bitField0_ & ~0x00000002);
        pubkey_ = getDefaultInstance().getPubkey();
        onChanged();
        return this;
      }

      private int reason_ = 0;
      /**
       * <pre>
       *
       *The reason that we excluded the channel from the our suggestions.
       * </pre>
       *
       * <code>.looprpc.AutoReason reason = 2;</code>
       * @return The enum numeric value on the wire for reason.
       */
      @java.lang.Override public int getReasonValue() {
        return reason_;
      }
      /**
       * <pre>
       *
       *The reason that we excluded the channel from the our suggestions.
       * </pre>
       *
       * <code>.looprpc.AutoReason reason = 2;</code>
       * @param value The enum numeric value on the wire for reason to set.
       * @return This builder for chaining.
       */
      public Builder setReasonValue(int value) {
        reason_ = value;
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }
      /**
       * <pre>
       *
       *The reason that we excluded the channel from the our suggestions.
       * </pre>
       *
       * <code>.looprpc.AutoReason reason = 2;</code>
       * @return The reason.
       */
      @java.lang.Override
      public looprpc.Loop.AutoReason getReason() {
        looprpc.Loop.AutoReason result = looprpc.Loop.AutoReason.forNumber(reason_);
        return result == null ? looprpc.Loop.AutoReason.UNRECOGNIZED : result;
      }
      /**
       * <pre>
       *
       *The reason that we excluded the channel from the our suggestions.
       * </pre>
       *
       * <code>.looprpc.AutoReason reason = 2;</code>
       * @param value The reason to set.
       * @return This builder for chaining.
       */
      public Builder setReason(looprpc.Loop.AutoReason value) {
        if (value == null) {
          throw new NullPointerException();
        }
        bitField0_ |= 0x00000004;
        reason_ = value.getNumber();
        onChanged();
        return this;
      }
      /**
       * <pre>
       *
       *The reason that we excluded the channel from the our suggestions.
       * </pre>
       *
       * <code>.looprpc.AutoReason reason = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearReason() {
        bitField0_ = (bitField0_ & ~0x00000004);
        reason_ = 0;
        onChanged();
        return this;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:looprpc.Disqualified)
    }

    // @@protoc_insertion_point(class_scope:looprpc.Disqualified)
    private static final looprpc.Loop.Disqualified DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new looprpc.Loop.Disqualified();
    }

    public static looprpc.Loop.Disqualified getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<Disqualified>
        PARSER = new com.google.protobuf.AbstractParser<Disqualified>() {
      @java.lang.Override
      public Disqualified parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<Disqualified> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<Disqualified> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public looprpc.Loop.Disqualified getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface SuggestSwapsResponseOrBuilder extends
      // @@protoc_insertion_point(interface_extends:looprpc.SuggestSwapsResponse)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     *
     *The set of recommended loop outs.
     * </pre>
     *
     * <code>repeated .looprpc.LoopOutRequest loop_out = 1;</code>
     */
    java.util.List<looprpc.Loop.LoopOutRequest> 
        getLoopOutList();
    /**
     * <pre>
     *
     *The set of recommended loop outs.
     * </pre>
     *
     * <code>repeated .looprpc.LoopOutRequest loop_out = 1;</code>
     */
    looprpc.Loop.LoopOutRequest getLoopOut(int index);
    /**
     * <pre>
     *
     *The set of recommended loop outs.
     * </pre>
     *
     * <code>repeated .looprpc.LoopOutRequest loop_out = 1;</code>
     */
    int getLoopOutCount();
    /**
     * <pre>
     *
     *The set of recommended loop outs.
     * </pre>
     *
     * <code>repeated .looprpc.LoopOutRequest loop_out = 1;</code>
     */
    java.util.List<? extends looprpc.Loop.LoopOutRequestOrBuilder> 
        getLoopOutOrBuilderList();
    /**
     * <pre>
     *
     *The set of recommended loop outs.
     * </pre>
     *
     * <code>repeated .looprpc.LoopOutRequest loop_out = 1;</code>
     */
    looprpc.Loop.LoopOutRequestOrBuilder getLoopOutOrBuilder(
        int index);

    /**
     * <pre>
     *
     *The set of recommended loop in swaps
     * </pre>
     *
     * <code>repeated .looprpc.LoopInRequest loop_in = 3;</code>
     */
    java.util.List<looprpc.Loop.LoopInRequest> 
        getLoopInList();
    /**
     * <pre>
     *
     *The set of recommended loop in swaps
     * </pre>
     *
     * <code>repeated .looprpc.LoopInRequest loop_in = 3;</code>
     */
    looprpc.Loop.LoopInRequest getLoopIn(int index);
    /**
     * <pre>
     *
     *The set of recommended loop in swaps
     * </pre>
     *
     * <code>repeated .looprpc.LoopInRequest loop_in = 3;</code>
     */
    int getLoopInCount();
    /**
     * <pre>
     *
     *The set of recommended loop in swaps
     * </pre>
     *
     * <code>repeated .looprpc.LoopInRequest loop_in = 3;</code>
     */
    java.util.List<? extends looprpc.Loop.LoopInRequestOrBuilder> 
        getLoopInOrBuilderList();
    /**
     * <pre>
     *
     *The set of recommended loop in swaps
     * </pre>
     *
     * <code>repeated .looprpc.LoopInRequest loop_in = 3;</code>
     */
    looprpc.Loop.LoopInRequestOrBuilder getLoopInOrBuilder(
        int index);

    /**
     * <pre>
     *
     *Disqualified contains the set of channels that swaps are not recommended
     *for.
     * </pre>
     *
     * <code>repeated .looprpc.Disqualified disqualified = 2;</code>
     */
    java.util.List<looprpc.Loop.Disqualified> 
        getDisqualifiedList();
    /**
     * <pre>
     *
     *Disqualified contains the set of channels that swaps are not recommended
     *for.
     * </pre>
     *
     * <code>repeated .looprpc.Disqualified disqualified = 2;</code>
     */
    looprpc.Loop.Disqualified getDisqualified(int index);
    /**
     * <pre>
     *
     *Disqualified contains the set of channels that swaps are not recommended
     *for.
     * </pre>
     *
     * <code>repeated .looprpc.Disqualified disqualified = 2;</code>
     */
    int getDisqualifiedCount();
    /**
     * <pre>
     *
     *Disqualified contains the set of channels that swaps are not recommended
     *for.
     * </pre>
     *
     * <code>repeated .looprpc.Disqualified disqualified = 2;</code>
     */
    java.util.List<? extends looprpc.Loop.DisqualifiedOrBuilder> 
        getDisqualifiedOrBuilderList();
    /**
     * <pre>
     *
     *Disqualified contains the set of channels that swaps are not recommended
     *for.
     * </pre>
     *
     * <code>repeated .looprpc.Disqualified disqualified = 2;</code>
     */
    looprpc.Loop.DisqualifiedOrBuilder getDisqualifiedOrBuilder(
        int index);
  }
  /**
   * Protobuf type {@code looprpc.SuggestSwapsResponse}
   */
  public static final class SuggestSwapsResponse extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:looprpc.SuggestSwapsResponse)
      SuggestSwapsResponseOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use SuggestSwapsResponse.newBuilder() to construct.
    private SuggestSwapsResponse(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private SuggestSwapsResponse() {
      loopOut_ = java.util.Collections.emptyList();
      loopIn_ = java.util.Collections.emptyList();
      disqualified_ = java.util.Collections.emptyList();
    }

    @java.lang.Override
    @SuppressWarnings({"unused"})
    protected java.lang.Object newInstance(
        UnusedPrivateParameter unused) {
      return new SuggestSwapsResponse();
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return looprpc.Loop.internal_static_looprpc_SuggestSwapsResponse_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return looprpc.Loop.internal_static_looprpc_SuggestSwapsResponse_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              looprpc.Loop.SuggestSwapsResponse.class, looprpc.Loop.SuggestSwapsResponse.Builder.class);
    }

    public static final int LOOP_OUT_FIELD_NUMBER = 1;
    @SuppressWarnings("serial")
    private java.util.List<looprpc.Loop.LoopOutRequest> loopOut_;
    /**
     * <pre>
     *
     *The set of recommended loop outs.
     * </pre>
     *
     * <code>repeated .looprpc.LoopOutRequest loop_out = 1;</code>
     */
    @java.lang.Override
    public java.util.List<looprpc.Loop.LoopOutRequest> getLoopOutList() {
      return loopOut_;
    }
    /**
     * <pre>
     *
     *The set of recommended loop outs.
     * </pre>
     *
     * <code>repeated .looprpc.LoopOutRequest loop_out = 1;</code>
     */
    @java.lang.Override
    public java.util.List<? extends looprpc.Loop.LoopOutRequestOrBuilder> 
        getLoopOutOrBuilderList() {
      return loopOut_;
    }
    /**
     * <pre>
     *
     *The set of recommended loop outs.
     * </pre>
     *
     * <code>repeated .looprpc.LoopOutRequest loop_out = 1;</code>
     */
    @java.lang.Override
    public int getLoopOutCount() {
      return loopOut_.size();
    }
    /**
     * <pre>
     *
     *The set of recommended loop outs.
     * </pre>
     *
     * <code>repeated .looprpc.LoopOutRequest loop_out = 1;</code>
     */
    @java.lang.Override
    public looprpc.Loop.LoopOutRequest getLoopOut(int index) {
      return loopOut_.get(index);
    }
    /**
     * <pre>
     *
     *The set of recommended loop outs.
     * </pre>
     *
     * <code>repeated .looprpc.LoopOutRequest loop_out = 1;</code>
     */
    @java.lang.Override
    public looprpc.Loop.LoopOutRequestOrBuilder getLoopOutOrBuilder(
        int index) {
      return loopOut_.get(index);
    }

    public static final int LOOP_IN_FIELD_NUMBER = 3;
    @SuppressWarnings("serial")
    private java.util.List<looprpc.Loop.LoopInRequest> loopIn_;
    /**
     * <pre>
     *
     *The set of recommended loop in swaps
     * </pre>
     *
     * <code>repeated .looprpc.LoopInRequest loop_in = 3;</code>
     */
    @java.lang.Override
    public java.util.List<looprpc.Loop.LoopInRequest> getLoopInList() {
      return loopIn_;
    }
    /**
     * <pre>
     *
     *The set of recommended loop in swaps
     * </pre>
     *
     * <code>repeated .looprpc.LoopInRequest loop_in = 3;</code>
     */
    @java.lang.Override
    public java.util.List<? extends looprpc.Loop.LoopInRequestOrBuilder> 
        getLoopInOrBuilderList() {
      return loopIn_;
    }
    /**
     * <pre>
     *
     *The set of recommended loop in swaps
     * </pre>
     *
     * <code>repeated .looprpc.LoopInRequest loop_in = 3;</code>
     */
    @java.lang.Override
    public int getLoopInCount() {
      return loopIn_.size();
    }
    /**
     * <pre>
     *
     *The set of recommended loop in swaps
     * </pre>
     *
     * <code>repeated .looprpc.LoopInRequest loop_in = 3;</code>
     */
    @java.lang.Override
    public looprpc.Loop.LoopInRequest getLoopIn(int index) {
      return loopIn_.get(index);
    }
    /**
     * <pre>
     *
     *The set of recommended loop in swaps
     * </pre>
     *
     * <code>repeated .looprpc.LoopInRequest loop_in = 3;</code>
     */
    @java.lang.Override
    public looprpc.Loop.LoopInRequestOrBuilder getLoopInOrBuilder(
        int index) {
      return loopIn_.get(index);
    }

    public static final int DISQUALIFIED_FIELD_NUMBER = 2;
    @SuppressWarnings("serial")
    private java.util.List<looprpc.Loop.Disqualified> disqualified_;
    /**
     * <pre>
     *
     *Disqualified contains the set of channels that swaps are not recommended
     *for.
     * </pre>
     *
     * <code>repeated .looprpc.Disqualified disqualified = 2;</code>
     */
    @java.lang.Override
    public java.util.List<looprpc.Loop.Disqualified> getDisqualifiedList() {
      return disqualified_;
    }
    /**
     * <pre>
     *
     *Disqualified contains the set of channels that swaps are not recommended
     *for.
     * </pre>
     *
     * <code>repeated .looprpc.Disqualified disqualified = 2;</code>
     */
    @java.lang.Override
    public java.util.List<? extends looprpc.Loop.DisqualifiedOrBuilder> 
        getDisqualifiedOrBuilderList() {
      return disqualified_;
    }
    /**
     * <pre>
     *
     *Disqualified contains the set of channels that swaps are not recommended
     *for.
     * </pre>
     *
     * <code>repeated .looprpc.Disqualified disqualified = 2;</code>
     */
    @java.lang.Override
    public int getDisqualifiedCount() {
      return disqualified_.size();
    }
    /**
     * <pre>
     *
     *Disqualified contains the set of channels that swaps are not recommended
     *for.
     * </pre>
     *
     * <code>repeated .looprpc.Disqualified disqualified = 2;</code>
     */
    @java.lang.Override
    public looprpc.Loop.Disqualified getDisqualified(int index) {
      return disqualified_.get(index);
    }
    /**
     * <pre>
     *
     *Disqualified contains the set of channels that swaps are not recommended
     *for.
     * </pre>
     *
     * <code>repeated .looprpc.Disqualified disqualified = 2;</code>
     */
    @java.lang.Override
    public looprpc.Loop.DisqualifiedOrBuilder getDisqualifiedOrBuilder(
        int index) {
      return disqualified_.get(index);
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      for (int i = 0; i < loopOut_.size(); i++) {
        output.writeMessage(1, loopOut_.get(i));
      }
      for (int i = 0; i < disqualified_.size(); i++) {
        output.writeMessage(2, disqualified_.get(i));
      }
      for (int i = 0; i < loopIn_.size(); i++) {
        output.writeMessage(3, loopIn_.get(i));
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      for (int i = 0; i < loopOut_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(1, loopOut_.get(i));
      }
      for (int i = 0; i < disqualified_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(2, disqualified_.get(i));
      }
      for (int i = 0; i < loopIn_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(3, loopIn_.get(i));
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof looprpc.Loop.SuggestSwapsResponse)) {
        return super.equals(obj);
      }
      looprpc.Loop.SuggestSwapsResponse other = (looprpc.Loop.SuggestSwapsResponse) obj;

      if (!getLoopOutList()
          .equals(other.getLoopOutList())) return false;
      if (!getLoopInList()
          .equals(other.getLoopInList())) return false;
      if (!getDisqualifiedList()
          .equals(other.getDisqualifiedList())) return false;
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (getLoopOutCount() > 0) {
        hash = (37 * hash) + LOOP_OUT_FIELD_NUMBER;
        hash = (53 * hash) + getLoopOutList().hashCode();
      }
      if (getLoopInCount() > 0) {
        hash = (37 * hash) + LOOP_IN_FIELD_NUMBER;
        hash = (53 * hash) + getLoopInList().hashCode();
      }
      if (getDisqualifiedCount() > 0) {
        hash = (37 * hash) + DISQUALIFIED_FIELD_NUMBER;
        hash = (53 * hash) + getDisqualifiedList().hashCode();
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static looprpc.Loop.SuggestSwapsResponse parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static looprpc.Loop.SuggestSwapsResponse parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static looprpc.Loop.SuggestSwapsResponse parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static looprpc.Loop.SuggestSwapsResponse parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static looprpc.Loop.SuggestSwapsResponse parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static looprpc.Loop.SuggestSwapsResponse parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static looprpc.Loop.SuggestSwapsResponse parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static looprpc.Loop.SuggestSwapsResponse parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static looprpc.Loop.SuggestSwapsResponse parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static looprpc.Loop.SuggestSwapsResponse parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static looprpc.Loop.SuggestSwapsResponse parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static looprpc.Loop.SuggestSwapsResponse parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(looprpc.Loop.SuggestSwapsResponse prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * Protobuf type {@code looprpc.SuggestSwapsResponse}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:looprpc.SuggestSwapsResponse)
        looprpc.Loop.SuggestSwapsResponseOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return looprpc.Loop.internal_static_looprpc_SuggestSwapsResponse_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return looprpc.Loop.internal_static_looprpc_SuggestSwapsResponse_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                looprpc.Loop.SuggestSwapsResponse.class, looprpc.Loop.SuggestSwapsResponse.Builder.class);
      }

      // Construct using looprpc.Loop.SuggestSwapsResponse.newBuilder()
      private Builder() {

      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);

      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        if (loopOutBuilder_ == null) {
          loopOut_ = java.util.Collections.emptyList();
        } else {
          loopOut_ = null;
          loopOutBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000001);
        if (loopInBuilder_ == null) {
          loopIn_ = java.util.Collections.emptyList();
        } else {
          loopIn_ = null;
          loopInBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000002);
        if (disqualifiedBuilder_ == null) {
          disqualified_ = java.util.Collections.emptyList();
        } else {
          disqualified_ = null;
          disqualifiedBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000004);
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return looprpc.Loop.internal_static_looprpc_SuggestSwapsResponse_descriptor;
      }

      @java.lang.Override
      public looprpc.Loop.SuggestSwapsResponse getDefaultInstanceForType() {
        return looprpc.Loop.SuggestSwapsResponse.getDefaultInstance();
      }

      @java.lang.Override
      public looprpc.Loop.SuggestSwapsResponse build() {
        looprpc.Loop.SuggestSwapsResponse result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public looprpc.Loop.SuggestSwapsResponse buildPartial() {
        looprpc.Loop.SuggestSwapsResponse result = new looprpc.Loop.SuggestSwapsResponse(this);
        buildPartialRepeatedFields(result);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartialRepeatedFields(looprpc.Loop.SuggestSwapsResponse result) {
        if (loopOutBuilder_ == null) {
          if (((bitField0_ & 0x00000001) != 0)) {
            loopOut_ = java.util.Collections.unmodifiableList(loopOut_);
            bitField0_ = (bitField0_ & ~0x00000001);
          }
          result.loopOut_ = loopOut_;
        } else {
          result.loopOut_ = loopOutBuilder_.build();
        }
        if (loopInBuilder_ == null) {
          if (((bitField0_ & 0x00000002) != 0)) {
            loopIn_ = java.util.Collections.unmodifiableList(loopIn_);
            bitField0_ = (bitField0_ & ~0x00000002);
          }
          result.loopIn_ = loopIn_;
        } else {
          result.loopIn_ = loopInBuilder_.build();
        }
        if (disqualifiedBuilder_ == null) {
          if (((bitField0_ & 0x00000004) != 0)) {
            disqualified_ = java.util.Collections.unmodifiableList(disqualified_);
            bitField0_ = (bitField0_ & ~0x00000004);
          }
          result.disqualified_ = disqualified_;
        } else {
          result.disqualified_ = disqualifiedBuilder_.build();
        }
      }

      private void buildPartial0(looprpc.Loop.SuggestSwapsResponse result) {
        int from_bitField0_ = bitField0_;
      }

      @java.lang.Override
      public Builder clone() {
        return super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof looprpc.Loop.SuggestSwapsResponse) {
          return mergeFrom((looprpc.Loop.SuggestSwapsResponse)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(looprpc.Loop.SuggestSwapsResponse other) {
        if (other == looprpc.Loop.SuggestSwapsResponse.getDefaultInstance()) return this;
        if (loopOutBuilder_ == null) {
          if (!other.loopOut_.isEmpty()) {
            if (loopOut_.isEmpty()) {
              loopOut_ = other.loopOut_;
              bitField0_ = (bitField0_ & ~0x00000001);
            } else {
              ensureLoopOutIsMutable();
              loopOut_.addAll(other.loopOut_);
            }
            onChanged();
          }
        } else {
          if (!other.loopOut_.isEmpty()) {
            if (loopOutBuilder_.isEmpty()) {
              loopOutBuilder_.dispose();
              loopOutBuilder_ = null;
              loopOut_ = other.loopOut_;
              bitField0_ = (bitField0_ & ~0x00000001);
              loopOutBuilder_ = 
                com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
                   getLoopOutFieldBuilder() : null;
            } else {
              loopOutBuilder_.addAllMessages(other.loopOut_);
            }
          }
        }
        if (loopInBuilder_ == null) {
          if (!other.loopIn_.isEmpty()) {
            if (loopIn_.isEmpty()) {
              loopIn_ = other.loopIn_;
              bitField0_ = (bitField0_ & ~0x00000002);
            } else {
              ensureLoopInIsMutable();
              loopIn_.addAll(other.loopIn_);
            }
            onChanged();
          }
        } else {
          if (!other.loopIn_.isEmpty()) {
            if (loopInBuilder_.isEmpty()) {
              loopInBuilder_.dispose();
              loopInBuilder_ = null;
              loopIn_ = other.loopIn_;
              bitField0_ = (bitField0_ & ~0x00000002);
              loopInBuilder_ = 
                com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
                   getLoopInFieldBuilder() : null;
            } else {
              loopInBuilder_.addAllMessages(other.loopIn_);
            }
          }
        }
        if (disqualifiedBuilder_ == null) {
          if (!other.disqualified_.isEmpty()) {
            if (disqualified_.isEmpty()) {
              disqualified_ = other.disqualified_;
              bitField0_ = (bitField0_ & ~0x00000004);
            } else {
              ensureDisqualifiedIsMutable();
              disqualified_.addAll(other.disqualified_);
            }
            onChanged();
          }
        } else {
          if (!other.disqualified_.isEmpty()) {
            if (disqualifiedBuilder_.isEmpty()) {
              disqualifiedBuilder_.dispose();
              disqualifiedBuilder_ = null;
              disqualified_ = other.disqualified_;
              bitField0_ = (bitField0_ & ~0x00000004);
              disqualifiedBuilder_ = 
                com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
                   getDisqualifiedFieldBuilder() : null;
            } else {
              disqualifiedBuilder_.addAllMessages(other.disqualified_);
            }
          }
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10: {
                looprpc.Loop.LoopOutRequest m =
                    input.readMessage(
                        looprpc.Loop.LoopOutRequest.parser(),
                        extensionRegistry);
                if (loopOutBuilder_ == null) {
                  ensureLoopOutIsMutable();
                  loopOut_.add(m);
                } else {
                  loopOutBuilder_.addMessage(m);
                }
                break;
              } // case 10
              case 18: {
                looprpc.Loop.Disqualified m =
                    input.readMessage(
                        looprpc.Loop.Disqualified.parser(),
                        extensionRegistry);
                if (disqualifiedBuilder_ == null) {
                  ensureDisqualifiedIsMutable();
                  disqualified_.add(m);
                } else {
                  disqualifiedBuilder_.addMessage(m);
                }
                break;
              } // case 18
              case 26: {
                looprpc.Loop.LoopInRequest m =
                    input.readMessage(
                        looprpc.Loop.LoopInRequest.parser(),
                        extensionRegistry);
                if (loopInBuilder_ == null) {
                  ensureLoopInIsMutable();
                  loopIn_.add(m);
                } else {
                  loopInBuilder_.addMessage(m);
                }
                break;
              } // case 26
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private java.util.List<looprpc.Loop.LoopOutRequest> loopOut_ =
        java.util.Collections.emptyList();
      private void ensureLoopOutIsMutable() {
        if (!((bitField0_ & 0x00000001) != 0)) {
          loopOut_ = new java.util.ArrayList<looprpc.Loop.LoopOutRequest>(loopOut_);
          bitField0_ |= 0x00000001;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
          looprpc.Loop.LoopOutRequest, looprpc.Loop.LoopOutRequest.Builder, looprpc.Loop.LoopOutRequestOrBuilder> loopOutBuilder_;

      /**
       * <pre>
       *
       *The set of recommended loop outs.
       * </pre>
       *
       * <code>repeated .looprpc.LoopOutRequest loop_out = 1;</code>
       */
      public java.util.List<looprpc.Loop.LoopOutRequest> getLoopOutList() {
        if (loopOutBuilder_ == null) {
          return java.util.Collections.unmodifiableList(loopOut_);
        } else {
          return loopOutBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       *
       *The set of recommended loop outs.
       * </pre>
       *
       * <code>repeated .looprpc.LoopOutRequest loop_out = 1;</code>
       */
      public int getLoopOutCount() {
        if (loopOutBuilder_ == null) {
          return loopOut_.size();
        } else {
          return loopOutBuilder_.getCount();
        }
      }
      /**
       * <pre>
       *
       *The set of recommended loop outs.
       * </pre>
       *
       * <code>repeated .looprpc.LoopOutRequest loop_out = 1;</code>
       */
      public looprpc.Loop.LoopOutRequest getLoopOut(int index) {
        if (loopOutBuilder_ == null) {
          return loopOut_.get(index);
        } else {
          return loopOutBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       *
       *The set of recommended loop outs.
       * </pre>
       *
       * <code>repeated .looprpc.LoopOutRequest loop_out = 1;</code>
       */
      public Builder setLoopOut(
          int index, looprpc.Loop.LoopOutRequest value) {
        if (loopOutBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureLoopOutIsMutable();
          loopOut_.set(index, value);
          onChanged();
        } else {
          loopOutBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       *
       *The set of recommended loop outs.
       * </pre>
       *
       * <code>repeated .looprpc.LoopOutRequest loop_out = 1;</code>
       */
      public Builder setLoopOut(
          int index, looprpc.Loop.LoopOutRequest.Builder builderForValue) {
        if (loopOutBuilder_ == null) {
          ensureLoopOutIsMutable();
          loopOut_.set(index, builderForValue.build());
          onChanged();
        } else {
          loopOutBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       *
       *The set of recommended loop outs.
       * </pre>
       *
       * <code>repeated .looprpc.LoopOutRequest loop_out = 1;</code>
       */
      public Builder addLoopOut(looprpc.Loop.LoopOutRequest value) {
        if (loopOutBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureLoopOutIsMutable();
          loopOut_.add(value);
          onChanged();
        } else {
          loopOutBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       *
       *The set of recommended loop outs.
       * </pre>
       *
       * <code>repeated .looprpc.LoopOutRequest loop_out = 1;</code>
       */
      public Builder addLoopOut(
          int index, looprpc.Loop.LoopOutRequest value) {
        if (loopOutBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureLoopOutIsMutable();
          loopOut_.add(index, value);
          onChanged();
        } else {
          loopOutBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       *
       *The set of recommended loop outs.
       * </pre>
       *
       * <code>repeated .looprpc.LoopOutRequest loop_out = 1;</code>
       */
      public Builder addLoopOut(
          looprpc.Loop.LoopOutRequest.Builder builderForValue) {
        if (loopOutBuilder_ == null) {
          ensureLoopOutIsMutable();
          loopOut_.add(builderForValue.build());
          onChanged();
        } else {
          loopOutBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       *
       *The set of recommended loop outs.
       * </pre>
       *
       * <code>repeated .looprpc.LoopOutRequest loop_out = 1;</code>
       */
      public Builder addLoopOut(
          int index, looprpc.Loop.LoopOutRequest.Builder builderForValue) {
        if (loopOutBuilder_ == null) {
          ensureLoopOutIsMutable();
          loopOut_.add(index, builderForValue.build());
          onChanged();
        } else {
          loopOutBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       *
       *The set of recommended loop outs.
       * </pre>
       *
       * <code>repeated .looprpc.LoopOutRequest loop_out = 1;</code>
       */
      public Builder addAllLoopOut(
          java.lang.Iterable<? extends looprpc.Loop.LoopOutRequest> values) {
        if (loopOutBuilder_ == null) {
          ensureLoopOutIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, loopOut_);
          onChanged();
        } else {
          loopOutBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       *
       *The set of recommended loop outs.
       * </pre>
       *
       * <code>repeated .looprpc.LoopOutRequest loop_out = 1;</code>
       */
      public Builder clearLoopOut() {
        if (loopOutBuilder_ == null) {
          loopOut_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000001);
          onChanged();
        } else {
          loopOutBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       *
       *The set of recommended loop outs.
       * </pre>
       *
       * <code>repeated .looprpc.LoopOutRequest loop_out = 1;</code>
       */
      public Builder removeLoopOut(int index) {
        if (loopOutBuilder_ == null) {
          ensureLoopOutIsMutable();
          loopOut_.remove(index);
          onChanged();
        } else {
          loopOutBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       *
       *The set of recommended loop outs.
       * </pre>
       *
       * <code>repeated .looprpc.LoopOutRequest loop_out = 1;</code>
       */
      public looprpc.Loop.LoopOutRequest.Builder getLoopOutBuilder(
          int index) {
        return getLoopOutFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       *
       *The set of recommended loop outs.
       * </pre>
       *
       * <code>repeated .looprpc.LoopOutRequest loop_out = 1;</code>
       */
      public looprpc.Loop.LoopOutRequestOrBuilder getLoopOutOrBuilder(
          int index) {
        if (loopOutBuilder_ == null) {
          return loopOut_.get(index);  } else {
          return loopOutBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       *
       *The set of recommended loop outs.
       * </pre>
       *
       * <code>repeated .looprpc.LoopOutRequest loop_out = 1;</code>
       */
      public java.util.List<? extends looprpc.Loop.LoopOutRequestOrBuilder> 
           getLoopOutOrBuilderList() {
        if (loopOutBuilder_ != null) {
          return loopOutBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(loopOut_);
        }
      }
      /**
       * <pre>
       *
       *The set of recommended loop outs.
       * </pre>
       *
       * <code>repeated .looprpc.LoopOutRequest loop_out = 1;</code>
       */
      public looprpc.Loop.LoopOutRequest.Builder addLoopOutBuilder() {
        return getLoopOutFieldBuilder().addBuilder(
            looprpc.Loop.LoopOutRequest.getDefaultInstance());
      }
      /**
       * <pre>
       *
       *The set of recommended loop outs.
       * </pre>
       *
       * <code>repeated .looprpc.LoopOutRequest loop_out = 1;</code>
       */
      public looprpc.Loop.LoopOutRequest.Builder addLoopOutBuilder(
          int index) {
        return getLoopOutFieldBuilder().addBuilder(
            index, looprpc.Loop.LoopOutRequest.getDefaultInstance());
      }
      /**
       * <pre>
       *
       *The set of recommended loop outs.
       * </pre>
       *
       * <code>repeated .looprpc.LoopOutRequest loop_out = 1;</code>
       */
      public java.util.List<looprpc.Loop.LoopOutRequest.Builder> 
           getLoopOutBuilderList() {
        return getLoopOutFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilderV3<
          looprpc.Loop.LoopOutRequest, looprpc.Loop.LoopOutRequest.Builder, looprpc.Loop.LoopOutRequestOrBuilder> 
          getLoopOutFieldBuilder() {
        if (loopOutBuilder_ == null) {
          loopOutBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<
              looprpc.Loop.LoopOutRequest, looprpc.Loop.LoopOutRequest.Builder, looprpc.Loop.LoopOutRequestOrBuilder>(
                  loopOut_,
                  ((bitField0_ & 0x00000001) != 0),
                  getParentForChildren(),
                  isClean());
          loopOut_ = null;
        }
        return loopOutBuilder_;
      }

      private java.util.List<looprpc.Loop.LoopInRequest> loopIn_ =
        java.util.Collections.emptyList();
      private void ensureLoopInIsMutable() {
        if (!((bitField0_ & 0x00000002) != 0)) {
          loopIn_ = new java.util.ArrayList<looprpc.Loop.LoopInRequest>(loopIn_);
          bitField0_ |= 0x00000002;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
          looprpc.Loop.LoopInRequest, looprpc.Loop.LoopInRequest.Builder, looprpc.Loop.LoopInRequestOrBuilder> loopInBuilder_;

      /**
       * <pre>
       *
       *The set of recommended loop in swaps
       * </pre>
       *
       * <code>repeated .looprpc.LoopInRequest loop_in = 3;</code>
       */
      public java.util.List<looprpc.Loop.LoopInRequest> getLoopInList() {
        if (loopInBuilder_ == null) {
          return java.util.Collections.unmodifiableList(loopIn_);
        } else {
          return loopInBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       *
       *The set of recommended loop in swaps
       * </pre>
       *
       * <code>repeated .looprpc.LoopInRequest loop_in = 3;</code>
       */
      public int getLoopInCount() {
        if (loopInBuilder_ == null) {
          return loopIn_.size();
        } else {
          return loopInBuilder_.getCount();
        }
      }
      /**
       * <pre>
       *
       *The set of recommended loop in swaps
       * </pre>
       *
       * <code>repeated .looprpc.LoopInRequest loop_in = 3;</code>
       */
      public looprpc.Loop.LoopInRequest getLoopIn(int index) {
        if (loopInBuilder_ == null) {
          return loopIn_.get(index);
        } else {
          return loopInBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       *
       *The set of recommended loop in swaps
       * </pre>
       *
       * <code>repeated .looprpc.LoopInRequest loop_in = 3;</code>
       */
      public Builder setLoopIn(
          int index, looprpc.Loop.LoopInRequest value) {
        if (loopInBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureLoopInIsMutable();
          loopIn_.set(index, value);
          onChanged();
        } else {
          loopInBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       *
       *The set of recommended loop in swaps
       * </pre>
       *
       * <code>repeated .looprpc.LoopInRequest loop_in = 3;</code>
       */
      public Builder setLoopIn(
          int index, looprpc.Loop.LoopInRequest.Builder builderForValue) {
        if (loopInBuilder_ == null) {
          ensureLoopInIsMutable();
          loopIn_.set(index, builderForValue.build());
          onChanged();
        } else {
          loopInBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       *
       *The set of recommended loop in swaps
       * </pre>
       *
       * <code>repeated .looprpc.LoopInRequest loop_in = 3;</code>
       */
      public Builder addLoopIn(looprpc.Loop.LoopInRequest value) {
        if (loopInBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureLoopInIsMutable();
          loopIn_.add(value);
          onChanged();
        } else {
          loopInBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       *
       *The set of recommended loop in swaps
       * </pre>
       *
       * <code>repeated .looprpc.LoopInRequest loop_in = 3;</code>
       */
      public Builder addLoopIn(
          int index, looprpc.Loop.LoopInRequest value) {
        if (loopInBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureLoopInIsMutable();
          loopIn_.add(index, value);
          onChanged();
        } else {
          loopInBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       *
       *The set of recommended loop in swaps
       * </pre>
       *
       * <code>repeated .looprpc.LoopInRequest loop_in = 3;</code>
       */
      public Builder addLoopIn(
          looprpc.Loop.LoopInRequest.Builder builderForValue) {
        if (loopInBuilder_ == null) {
          ensureLoopInIsMutable();
          loopIn_.add(builderForValue.build());
          onChanged();
        } else {
          loopInBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       *
       *The set of recommended loop in swaps
       * </pre>
       *
       * <code>repeated .looprpc.LoopInRequest loop_in = 3;</code>
       */
      public Builder addLoopIn(
          int index, looprpc.Loop.LoopInRequest.Builder builderForValue) {
        if (loopInBuilder_ == null) {
          ensureLoopInIsMutable();
          loopIn_.add(index, builderForValue.build());
          onChanged();
        } else {
          loopInBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       *
       *The set of recommended loop in swaps
       * </pre>
       *
       * <code>repeated .looprpc.LoopInRequest loop_in = 3;</code>
       */
      public Builder addAllLoopIn(
          java.lang.Iterable<? extends looprpc.Loop.LoopInRequest> values) {
        if (loopInBuilder_ == null) {
          ensureLoopInIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, loopIn_);
          onChanged();
        } else {
          loopInBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       *
       *The set of recommended loop in swaps
       * </pre>
       *
       * <code>repeated .looprpc.LoopInRequest loop_in = 3;</code>
       */
      public Builder clearLoopIn() {
        if (loopInBuilder_ == null) {
          loopIn_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000002);
          onChanged();
        } else {
          loopInBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       *
       *The set of recommended loop in swaps
       * </pre>
       *
       * <code>repeated .looprpc.LoopInRequest loop_in = 3;</code>
       */
      public Builder removeLoopIn(int index) {
        if (loopInBuilder_ == null) {
          ensureLoopInIsMutable();
          loopIn_.remove(index);
          onChanged();
        } else {
          loopInBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       *
       *The set of recommended loop in swaps
       * </pre>
       *
       * <code>repeated .looprpc.LoopInRequest loop_in = 3;</code>
       */
      public looprpc.Loop.LoopInRequest.Builder getLoopInBuilder(
          int index) {
        return getLoopInFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       *
       *The set of recommended loop in swaps
       * </pre>
       *
       * <code>repeated .looprpc.LoopInRequest loop_in = 3;</code>
       */
      public looprpc.Loop.LoopInRequestOrBuilder getLoopInOrBuilder(
          int index) {
        if (loopInBuilder_ == null) {
          return loopIn_.get(index);  } else {
          return loopInBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       *
       *The set of recommended loop in swaps
       * </pre>
       *
       * <code>repeated .looprpc.LoopInRequest loop_in = 3;</code>
       */
      public java.util.List<? extends looprpc.Loop.LoopInRequestOrBuilder> 
           getLoopInOrBuilderList() {
        if (loopInBuilder_ != null) {
          return loopInBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(loopIn_);
        }
      }
      /**
       * <pre>
       *
       *The set of recommended loop in swaps
       * </pre>
       *
       * <code>repeated .looprpc.LoopInRequest loop_in = 3;</code>
       */
      public looprpc.Loop.LoopInRequest.Builder addLoopInBuilder() {
        return getLoopInFieldBuilder().addBuilder(
            looprpc.Loop.LoopInRequest.getDefaultInstance());
      }
      /**
       * <pre>
       *
       *The set of recommended loop in swaps
       * </pre>
       *
       * <code>repeated .looprpc.LoopInRequest loop_in = 3;</code>
       */
      public looprpc.Loop.LoopInRequest.Builder addLoopInBuilder(
          int index) {
        return getLoopInFieldBuilder().addBuilder(
            index, looprpc.Loop.LoopInRequest.getDefaultInstance());
      }
      /**
       * <pre>
       *
       *The set of recommended loop in swaps
       * </pre>
       *
       * <code>repeated .looprpc.LoopInRequest loop_in = 3;</code>
       */
      public java.util.List<looprpc.Loop.LoopInRequest.Builder> 
           getLoopInBuilderList() {
        return getLoopInFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilderV3<
          looprpc.Loop.LoopInRequest, looprpc.Loop.LoopInRequest.Builder, looprpc.Loop.LoopInRequestOrBuilder> 
          getLoopInFieldBuilder() {
        if (loopInBuilder_ == null) {
          loopInBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<
              looprpc.Loop.LoopInRequest, looprpc.Loop.LoopInRequest.Builder, looprpc.Loop.LoopInRequestOrBuilder>(
                  loopIn_,
                  ((bitField0_ & 0x00000002) != 0),
                  getParentForChildren(),
                  isClean());
          loopIn_ = null;
        }
        return loopInBuilder_;
      }

      private java.util.List<looprpc.Loop.Disqualified> disqualified_ =
        java.util.Collections.emptyList();
      private void ensureDisqualifiedIsMutable() {
        if (!((bitField0_ & 0x00000004) != 0)) {
          disqualified_ = new java.util.ArrayList<looprpc.Loop.Disqualified>(disqualified_);
          bitField0_ |= 0x00000004;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
          looprpc.Loop.Disqualified, looprpc.Loop.Disqualified.Builder, looprpc.Loop.DisqualifiedOrBuilder> disqualifiedBuilder_;

      /**
       * <pre>
       *
       *Disqualified contains the set of channels that swaps are not recommended
       *for.
       * </pre>
       *
       * <code>repeated .looprpc.Disqualified disqualified = 2;</code>
       */
      public java.util.List<looprpc.Loop.Disqualified> getDisqualifiedList() {
        if (disqualifiedBuilder_ == null) {
          return java.util.Collections.unmodifiableList(disqualified_);
        } else {
          return disqualifiedBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       *
       *Disqualified contains the set of channels that swaps are not recommended
       *for.
       * </pre>
       *
       * <code>repeated .looprpc.Disqualified disqualified = 2;</code>
       */
      public int getDisqualifiedCount() {
        if (disqualifiedBuilder_ == null) {
          return disqualified_.size();
        } else {
          return disqualifiedBuilder_.getCount();
        }
      }
      /**
       * <pre>
       *
       *Disqualified contains the set of channels that swaps are not recommended
       *for.
       * </pre>
       *
       * <code>repeated .looprpc.Disqualified disqualified = 2;</code>
       */
      public looprpc.Loop.Disqualified getDisqualified(int index) {
        if (disqualifiedBuilder_ == null) {
          return disqualified_.get(index);
        } else {
          return disqualifiedBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       *
       *Disqualified contains the set of channels that swaps are not recommended
       *for.
       * </pre>
       *
       * <code>repeated .looprpc.Disqualified disqualified = 2;</code>
       */
      public Builder setDisqualified(
          int index, looprpc.Loop.Disqualified value) {
        if (disqualifiedBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureDisqualifiedIsMutable();
          disqualified_.set(index, value);
          onChanged();
        } else {
          disqualifiedBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       *
       *Disqualified contains the set of channels that swaps are not recommended
       *for.
       * </pre>
       *
       * <code>repeated .looprpc.Disqualified disqualified = 2;</code>
       */
      public Builder setDisqualified(
          int index, looprpc.Loop.Disqualified.Builder builderForValue) {
        if (disqualifiedBuilder_ == null) {
          ensureDisqualifiedIsMutable();
          disqualified_.set(index, builderForValue.build());
          onChanged();
        } else {
          disqualifiedBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       *
       *Disqualified contains the set of channels that swaps are not recommended
       *for.
       * </pre>
       *
       * <code>repeated .looprpc.Disqualified disqualified = 2;</code>
       */
      public Builder addDisqualified(looprpc.Loop.Disqualified value) {
        if (disqualifiedBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureDisqualifiedIsMutable();
          disqualified_.add(value);
          onChanged();
        } else {
          disqualifiedBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       *
       *Disqualified contains the set of channels that swaps are not recommended
       *for.
       * </pre>
       *
       * <code>repeated .looprpc.Disqualified disqualified = 2;</code>
       */
      public Builder addDisqualified(
          int index, looprpc.Loop.Disqualified value) {
        if (disqualifiedBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureDisqualifiedIsMutable();
          disqualified_.add(index, value);
          onChanged();
        } else {
          disqualifiedBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       *
       *Disqualified contains the set of channels that swaps are not recommended
       *for.
       * </pre>
       *
       * <code>repeated .looprpc.Disqualified disqualified = 2;</code>
       */
      public Builder addDisqualified(
          looprpc.Loop.Disqualified.Builder builderForValue) {
        if (disqualifiedBuilder_ == null) {
          ensureDisqualifiedIsMutable();
          disqualified_.add(builderForValue.build());
          onChanged();
        } else {
          disqualifiedBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       *
       *Disqualified contains the set of channels that swaps are not recommended
       *for.
       * </pre>
       *
       * <code>repeated .looprpc.Disqualified disqualified = 2;</code>
       */
      public Builder addDisqualified(
          int index, looprpc.Loop.Disqualified.Builder builderForValue) {
        if (disqualifiedBuilder_ == null) {
          ensureDisqualifiedIsMutable();
          disqualified_.add(index, builderForValue.build());
          onChanged();
        } else {
          disqualifiedBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       *
       *Disqualified contains the set of channels that swaps are not recommended
       *for.
       * </pre>
       *
       * <code>repeated .looprpc.Disqualified disqualified = 2;</code>
       */
      public Builder addAllDisqualified(
          java.lang.Iterable<? extends looprpc.Loop.Disqualified> values) {
        if (disqualifiedBuilder_ == null) {
          ensureDisqualifiedIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, disqualified_);
          onChanged();
        } else {
          disqualifiedBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       *
       *Disqualified contains the set of channels that swaps are not recommended
       *for.
       * </pre>
       *
       * <code>repeated .looprpc.Disqualified disqualified = 2;</code>
       */
      public Builder clearDisqualified() {
        if (disqualifiedBuilder_ == null) {
          disqualified_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000004);
          onChanged();
        } else {
          disqualifiedBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       *
       *Disqualified contains the set of channels that swaps are not recommended
       *for.
       * </pre>
       *
       * <code>repeated .looprpc.Disqualified disqualified = 2;</code>
       */
      public Builder removeDisqualified(int index) {
        if (disqualifiedBuilder_ == null) {
          ensureDisqualifiedIsMutable();
          disqualified_.remove(index);
          onChanged();
        } else {
          disqualifiedBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       *
       *Disqualified contains the set of channels that swaps are not recommended
       *for.
       * </pre>
       *
       * <code>repeated .looprpc.Disqualified disqualified = 2;</code>
       */
      public looprpc.Loop.Disqualified.Builder getDisqualifiedBuilder(
          int index) {
        return getDisqualifiedFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       *
       *Disqualified contains the set of channels that swaps are not recommended
       *for.
       * </pre>
       *
       * <code>repeated .looprpc.Disqualified disqualified = 2;</code>
       */
      public looprpc.Loop.DisqualifiedOrBuilder getDisqualifiedOrBuilder(
          int index) {
        if (disqualifiedBuilder_ == null) {
          return disqualified_.get(index);  } else {
          return disqualifiedBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       *
       *Disqualified contains the set of channels that swaps are not recommended
       *for.
       * </pre>
       *
       * <code>repeated .looprpc.Disqualified disqualified = 2;</code>
       */
      public java.util.List<? extends looprpc.Loop.DisqualifiedOrBuilder> 
           getDisqualifiedOrBuilderList() {
        if (disqualifiedBuilder_ != null) {
          return disqualifiedBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(disqualified_);
        }
      }
      /**
       * <pre>
       *
       *Disqualified contains the set of channels that swaps are not recommended
       *for.
       * </pre>
       *
       * <code>repeated .looprpc.Disqualified disqualified = 2;</code>
       */
      public looprpc.Loop.Disqualified.Builder addDisqualifiedBuilder() {
        return getDisqualifiedFieldBuilder().addBuilder(
            looprpc.Loop.Disqualified.getDefaultInstance());
      }
      /**
       * <pre>
       *
       *Disqualified contains the set of channels that swaps are not recommended
       *for.
       * </pre>
       *
       * <code>repeated .looprpc.Disqualified disqualified = 2;</code>
       */
      public looprpc.Loop.Disqualified.Builder addDisqualifiedBuilder(
          int index) {
        return getDisqualifiedFieldBuilder().addBuilder(
            index, looprpc.Loop.Disqualified.getDefaultInstance());
      }
      /**
       * <pre>
       *
       *Disqualified contains the set of channels that swaps are not recommended
       *for.
       * </pre>
       *
       * <code>repeated .looprpc.Disqualified disqualified = 2;</code>
       */
      public java.util.List<looprpc.Loop.Disqualified.Builder> 
           getDisqualifiedBuilderList() {
        return getDisqualifiedFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilderV3<
          looprpc.Loop.Disqualified, looprpc.Loop.Disqualified.Builder, looprpc.Loop.DisqualifiedOrBuilder> 
          getDisqualifiedFieldBuilder() {
        if (disqualifiedBuilder_ == null) {
          disqualifiedBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<
              looprpc.Loop.Disqualified, looprpc.Loop.Disqualified.Builder, looprpc.Loop.DisqualifiedOrBuilder>(
                  disqualified_,
                  ((bitField0_ & 0x00000004) != 0),
                  getParentForChildren(),
                  isClean());
          disqualified_ = null;
        }
        return disqualifiedBuilder_;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:looprpc.SuggestSwapsResponse)
    }

    // @@protoc_insertion_point(class_scope:looprpc.SuggestSwapsResponse)
    private static final looprpc.Loop.SuggestSwapsResponse DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new looprpc.Loop.SuggestSwapsResponse();
    }

    public static looprpc.Loop.SuggestSwapsResponse getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<SuggestSwapsResponse>
        PARSER = new com.google.protobuf.AbstractParser<SuggestSwapsResponse>() {
      @java.lang.Override
      public SuggestSwapsResponse parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<SuggestSwapsResponse> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<SuggestSwapsResponse> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public looprpc.Loop.SuggestSwapsResponse getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface AbandonSwapRequestOrBuilder extends
      // @@protoc_insertion_point(interface_extends:looprpc.AbandonSwapRequest)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     *
     *The swap identifier which currently is the hash that locks the HTLCs. When
     *using REST, this field must be encoded as URL safe base64.
     * </pre>
     *
     * <code>bytes id = 1;</code>
     * @return The id.
     */
    com.google.protobuf.ByteString getId();

    /**
     * <pre>
     *
     *A flag that tries to ensure that the client understands that they are
     *risking loss of funds by abandoning a swap. This could happen if an
     *abandoned swap would wait on a timeout sweep by the client.
     * </pre>
     *
     * <code>bool i_know_what_i_am_doing = 2;</code>
     * @return The iKnowWhatIAmDoing.
     */
    boolean getIKnowWhatIAmDoing();
  }
  /**
   * Protobuf type {@code looprpc.AbandonSwapRequest}
   */
  public static final class AbandonSwapRequest extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:looprpc.AbandonSwapRequest)
      AbandonSwapRequestOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use AbandonSwapRequest.newBuilder() to construct.
    private AbandonSwapRequest(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private AbandonSwapRequest() {
      id_ = com.google.protobuf.ByteString.EMPTY;
    }

    @java.lang.Override
    @SuppressWarnings({"unused"})
    protected java.lang.Object newInstance(
        UnusedPrivateParameter unused) {
      return new AbandonSwapRequest();
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return looprpc.Loop.internal_static_looprpc_AbandonSwapRequest_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return looprpc.Loop.internal_static_looprpc_AbandonSwapRequest_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              looprpc.Loop.AbandonSwapRequest.class, looprpc.Loop.AbandonSwapRequest.Builder.class);
    }

    public static final int ID_FIELD_NUMBER = 1;
    private com.google.protobuf.ByteString id_ = com.google.protobuf.ByteString.EMPTY;
    /**
     * <pre>
     *
     *The swap identifier which currently is the hash that locks the HTLCs. When
     *using REST, this field must be encoded as URL safe base64.
     * </pre>
     *
     * <code>bytes id = 1;</code>
     * @return The id.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString getId() {
      return id_;
    }

    public static final int I_KNOW_WHAT_I_AM_DOING_FIELD_NUMBER = 2;
    private boolean iKnowWhatIAmDoing_ = false;
    /**
     * <pre>
     *
     *A flag that tries to ensure that the client understands that they are
     *risking loss of funds by abandoning a swap. This could happen if an
     *abandoned swap would wait on a timeout sweep by the client.
     * </pre>
     *
     * <code>bool i_know_what_i_am_doing = 2;</code>
     * @return The iKnowWhatIAmDoing.
     */
    @java.lang.Override
    public boolean getIKnowWhatIAmDoing() {
      return iKnowWhatIAmDoing_;
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (!id_.isEmpty()) {
        output.writeBytes(1, id_);
      }
      if (iKnowWhatIAmDoing_ != false) {
        output.writeBool(2, iKnowWhatIAmDoing_);
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (!id_.isEmpty()) {
        size += com.google.protobuf.CodedOutputStream
          .computeBytesSize(1, id_);
      }
      if (iKnowWhatIAmDoing_ != false) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(2, iKnowWhatIAmDoing_);
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof looprpc.Loop.AbandonSwapRequest)) {
        return super.equals(obj);
      }
      looprpc.Loop.AbandonSwapRequest other = (looprpc.Loop.AbandonSwapRequest) obj;

      if (!getId()
          .equals(other.getId())) return false;
      if (getIKnowWhatIAmDoing()
          != other.getIKnowWhatIAmDoing()) return false;
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      hash = (37 * hash) + ID_FIELD_NUMBER;
      hash = (53 * hash) + getId().hashCode();
      hash = (37 * hash) + I_KNOW_WHAT_I_AM_DOING_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
          getIKnowWhatIAmDoing());
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static looprpc.Loop.AbandonSwapRequest parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static looprpc.Loop.AbandonSwapRequest parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static looprpc.Loop.AbandonSwapRequest parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static looprpc.Loop.AbandonSwapRequest parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static looprpc.Loop.AbandonSwapRequest parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static looprpc.Loop.AbandonSwapRequest parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static looprpc.Loop.AbandonSwapRequest parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static looprpc.Loop.AbandonSwapRequest parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static looprpc.Loop.AbandonSwapRequest parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static looprpc.Loop.AbandonSwapRequest parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static looprpc.Loop.AbandonSwapRequest parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static looprpc.Loop.AbandonSwapRequest parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(looprpc.Loop.AbandonSwapRequest prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * Protobuf type {@code looprpc.AbandonSwapRequest}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:looprpc.AbandonSwapRequest)
        looprpc.Loop.AbandonSwapRequestOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return looprpc.Loop.internal_static_looprpc_AbandonSwapRequest_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return looprpc.Loop.internal_static_looprpc_AbandonSwapRequest_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                looprpc.Loop.AbandonSwapRequest.class, looprpc.Loop.AbandonSwapRequest.Builder.class);
      }

      // Construct using looprpc.Loop.AbandonSwapRequest.newBuilder()
      private Builder() {

      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);

      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        id_ = com.google.protobuf.ByteString.EMPTY;
        iKnowWhatIAmDoing_ = false;
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return looprpc.Loop.internal_static_looprpc_AbandonSwapRequest_descriptor;
      }

      @java.lang.Override
      public looprpc.Loop.AbandonSwapRequest getDefaultInstanceForType() {
        return looprpc.Loop.AbandonSwapRequest.getDefaultInstance();
      }

      @java.lang.Override
      public looprpc.Loop.AbandonSwapRequest build() {
        looprpc.Loop.AbandonSwapRequest result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public looprpc.Loop.AbandonSwapRequest buildPartial() {
        looprpc.Loop.AbandonSwapRequest result = new looprpc.Loop.AbandonSwapRequest(this);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartial0(looprpc.Loop.AbandonSwapRequest result) {
        int from_bitField0_ = bitField0_;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.id_ = id_;
        }
        if (((from_bitField0_ & 0x00000002) != 0)) {
          result.iKnowWhatIAmDoing_ = iKnowWhatIAmDoing_;
        }
      }

      @java.lang.Override
      public Builder clone() {
        return super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof looprpc.Loop.AbandonSwapRequest) {
          return mergeFrom((looprpc.Loop.AbandonSwapRequest)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(looprpc.Loop.AbandonSwapRequest other) {
        if (other == looprpc.Loop.AbandonSwapRequest.getDefaultInstance()) return this;
        if (other.getId() != com.google.protobuf.ByteString.EMPTY) {
          setId(other.getId());
        }
        if (other.getIKnowWhatIAmDoing() != false) {
          setIKnowWhatIAmDoing(other.getIKnowWhatIAmDoing());
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10: {
                id_ = input.readBytes();
                bitField0_ |= 0x00000001;
                break;
              } // case 10
              case 16: {
                iKnowWhatIAmDoing_ = input.readBool();
                bitField0_ |= 0x00000002;
                break;
              } // case 16
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private com.google.protobuf.ByteString id_ = com.google.protobuf.ByteString.EMPTY;
      /**
       * <pre>
       *
       *The swap identifier which currently is the hash that locks the HTLCs. When
       *using REST, this field must be encoded as URL safe base64.
       * </pre>
       *
       * <code>bytes id = 1;</code>
       * @return The id.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString getId() {
        return id_;
      }
      /**
       * <pre>
       *
       *The swap identifier which currently is the hash that locks the HTLCs. When
       *using REST, this field must be encoded as URL safe base64.
       * </pre>
       *
       * <code>bytes id = 1;</code>
       * @param value The id to set.
       * @return This builder for chaining.
       */
      public Builder setId(com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        id_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       *
       *The swap identifier which currently is the hash that locks the HTLCs. When
       *using REST, this field must be encoded as URL safe base64.
       * </pre>
       *
       * <code>bytes id = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearId() {
        bitField0_ = (bitField0_ & ~0x00000001);
        id_ = getDefaultInstance().getId();
        onChanged();
        return this;
      }

      private boolean iKnowWhatIAmDoing_ ;
      /**
       * <pre>
       *
       *A flag that tries to ensure that the client understands that they are
       *risking loss of funds by abandoning a swap. This could happen if an
       *abandoned swap would wait on a timeout sweep by the client.
       * </pre>
       *
       * <code>bool i_know_what_i_am_doing = 2;</code>
       * @return The iKnowWhatIAmDoing.
       */
      @java.lang.Override
      public boolean getIKnowWhatIAmDoing() {
        return iKnowWhatIAmDoing_;
      }
      /**
       * <pre>
       *
       *A flag that tries to ensure that the client understands that they are
       *risking loss of funds by abandoning a swap. This could happen if an
       *abandoned swap would wait on a timeout sweep by the client.
       * </pre>
       *
       * <code>bool i_know_what_i_am_doing = 2;</code>
       * @param value The iKnowWhatIAmDoing to set.
       * @return This builder for chaining.
       */
      public Builder setIKnowWhatIAmDoing(boolean value) {

        iKnowWhatIAmDoing_ = value;
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       *
       *A flag that tries to ensure that the client understands that they are
       *risking loss of funds by abandoning a swap. This could happen if an
       *abandoned swap would wait on a timeout sweep by the client.
       * </pre>
       *
       * <code>bool i_know_what_i_am_doing = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearIKnowWhatIAmDoing() {
        bitField0_ = (bitField0_ & ~0x00000002);
        iKnowWhatIAmDoing_ = false;
        onChanged();
        return this;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:looprpc.AbandonSwapRequest)
    }

    // @@protoc_insertion_point(class_scope:looprpc.AbandonSwapRequest)
    private static final looprpc.Loop.AbandonSwapRequest DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new looprpc.Loop.AbandonSwapRequest();
    }

    public static looprpc.Loop.AbandonSwapRequest getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<AbandonSwapRequest>
        PARSER = new com.google.protobuf.AbstractParser<AbandonSwapRequest>() {
      @java.lang.Override
      public AbandonSwapRequest parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<AbandonSwapRequest> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<AbandonSwapRequest> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public looprpc.Loop.AbandonSwapRequest getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface AbandonSwapResponseOrBuilder extends
      // @@protoc_insertion_point(interface_extends:looprpc.AbandonSwapResponse)
      com.google.protobuf.MessageOrBuilder {
  }
  /**
   * Protobuf type {@code looprpc.AbandonSwapResponse}
   */
  public static final class AbandonSwapResponse extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:looprpc.AbandonSwapResponse)
      AbandonSwapResponseOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use AbandonSwapResponse.newBuilder() to construct.
    private AbandonSwapResponse(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private AbandonSwapResponse() {
    }

    @java.lang.Override
    @SuppressWarnings({"unused"})
    protected java.lang.Object newInstance(
        UnusedPrivateParameter unused) {
      return new AbandonSwapResponse();
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return looprpc.Loop.internal_static_looprpc_AbandonSwapResponse_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return looprpc.Loop.internal_static_looprpc_AbandonSwapResponse_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              looprpc.Loop.AbandonSwapResponse.class, looprpc.Loop.AbandonSwapResponse.Builder.class);
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof looprpc.Loop.AbandonSwapResponse)) {
        return super.equals(obj);
      }
      looprpc.Loop.AbandonSwapResponse other = (looprpc.Loop.AbandonSwapResponse) obj;

      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static looprpc.Loop.AbandonSwapResponse parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static looprpc.Loop.AbandonSwapResponse parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static looprpc.Loop.AbandonSwapResponse parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static looprpc.Loop.AbandonSwapResponse parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static looprpc.Loop.AbandonSwapResponse parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static looprpc.Loop.AbandonSwapResponse parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static looprpc.Loop.AbandonSwapResponse parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static looprpc.Loop.AbandonSwapResponse parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static looprpc.Loop.AbandonSwapResponse parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static looprpc.Loop.AbandonSwapResponse parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static looprpc.Loop.AbandonSwapResponse parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static looprpc.Loop.AbandonSwapResponse parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(looprpc.Loop.AbandonSwapResponse prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * Protobuf type {@code looprpc.AbandonSwapResponse}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:looprpc.AbandonSwapResponse)
        looprpc.Loop.AbandonSwapResponseOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return looprpc.Loop.internal_static_looprpc_AbandonSwapResponse_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return looprpc.Loop.internal_static_looprpc_AbandonSwapResponse_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                looprpc.Loop.AbandonSwapResponse.class, looprpc.Loop.AbandonSwapResponse.Builder.class);
      }

      // Construct using looprpc.Loop.AbandonSwapResponse.newBuilder()
      private Builder() {

      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);

      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return looprpc.Loop.internal_static_looprpc_AbandonSwapResponse_descriptor;
      }

      @java.lang.Override
      public looprpc.Loop.AbandonSwapResponse getDefaultInstanceForType() {
        return looprpc.Loop.AbandonSwapResponse.getDefaultInstance();
      }

      @java.lang.Override
      public looprpc.Loop.AbandonSwapResponse build() {
        looprpc.Loop.AbandonSwapResponse result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public looprpc.Loop.AbandonSwapResponse buildPartial() {
        looprpc.Loop.AbandonSwapResponse result = new looprpc.Loop.AbandonSwapResponse(this);
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof looprpc.Loop.AbandonSwapResponse) {
          return mergeFrom((looprpc.Loop.AbandonSwapResponse)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(looprpc.Loop.AbandonSwapResponse other) {
        if (other == looprpc.Loop.AbandonSwapResponse.getDefaultInstance()) return this;
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:looprpc.AbandonSwapResponse)
    }

    // @@protoc_insertion_point(class_scope:looprpc.AbandonSwapResponse)
    private static final looprpc.Loop.AbandonSwapResponse DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new looprpc.Loop.AbandonSwapResponse();
    }

    public static looprpc.Loop.AbandonSwapResponse getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<AbandonSwapResponse>
        PARSER = new com.google.protobuf.AbstractParser<AbandonSwapResponse>() {
      @java.lang.Override
      public AbandonSwapResponse parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<AbandonSwapResponse> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<AbandonSwapResponse> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public looprpc.Loop.AbandonSwapResponse getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_looprpc_LoopOutRequest_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_looprpc_LoopOutRequest_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_looprpc_LoopInRequest_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_looprpc_LoopInRequest_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_looprpc_SwapResponse_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_looprpc_SwapResponse_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_looprpc_MonitorRequest_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_looprpc_MonitorRequest_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_looprpc_SwapStatus_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_looprpc_SwapStatus_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_looprpc_ListSwapsRequest_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_looprpc_ListSwapsRequest_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_looprpc_ListSwapsResponse_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_looprpc_ListSwapsResponse_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_looprpc_SwapInfoRequest_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_looprpc_SwapInfoRequest_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_looprpc_TermsRequest_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_looprpc_TermsRequest_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_looprpc_InTermsResponse_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_looprpc_InTermsResponse_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_looprpc_OutTermsResponse_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_looprpc_OutTermsResponse_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_looprpc_QuoteRequest_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_looprpc_QuoteRequest_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_looprpc_InQuoteResponse_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_looprpc_InQuoteResponse_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_looprpc_OutQuoteResponse_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_looprpc_OutQuoteResponse_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_looprpc_ProbeRequest_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_looprpc_ProbeRequest_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_looprpc_ProbeResponse_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_looprpc_ProbeResponse_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_looprpc_TokensRequest_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_looprpc_TokensRequest_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_looprpc_TokensResponse_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_looprpc_TokensResponse_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_looprpc_LsatToken_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_looprpc_LsatToken_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_looprpc_LoopStats_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_looprpc_LoopStats_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_looprpc_GetInfoRequest_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_looprpc_GetInfoRequest_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_looprpc_GetInfoResponse_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_looprpc_GetInfoResponse_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_looprpc_GetLiquidityParamsRequest_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_looprpc_GetLiquidityParamsRequest_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_looprpc_LiquidityParameters_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_looprpc_LiquidityParameters_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_looprpc_LiquidityRule_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_looprpc_LiquidityRule_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_looprpc_SetLiquidityParamsRequest_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_looprpc_SetLiquidityParamsRequest_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_looprpc_SetLiquidityParamsResponse_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_looprpc_SetLiquidityParamsResponse_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_looprpc_SuggestSwapsRequest_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_looprpc_SuggestSwapsRequest_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_looprpc_Disqualified_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_looprpc_Disqualified_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_looprpc_SuggestSwapsResponse_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_looprpc_SuggestSwapsResponse_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_looprpc_AbandonSwapRequest_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_looprpc_AbandonSwapRequest_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_looprpc_AbandonSwapResponse_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_looprpc_AbandonSwapResponse_fieldAccessorTable;

  public static com.google.protobuf.Descriptors.FileDescriptor
      getDescriptor() {
    return descriptor;
  }
  private static  com.google.protobuf.Descriptors.FileDescriptor
      descriptor;
  static {
    java.lang.String[] descriptorData = {
      "\n\nloop.proto\022\007looprpc\032\032swapserverrpc/com" +
      "mon.proto\"\307\003\n\016LoopOutRequest\022\017\n\003amt\030\001 \001(" +
      "\003B\0020\001\022\014\n\004dest\030\002 \001(\t\022 \n\024max_swap_routing_" +
      "fee\030\003 \001(\003B\0020\001\022\"\n\026max_prepay_routing_fee\030" +
      "\004 \001(\003B\0020\001\022\030\n\014max_swap_fee\030\005 \001(\003B\0020\001\022\032\n\016m" +
      "ax_prepay_amt\030\006 \001(\003B\0020\001\022\031\n\rmax_miner_fee" +
      "\030\007 \001(\003B\0020\001\022\036\n\020loop_out_channel\030\010 \001(\004B\004\030\001" +
      "0\001\022\035\n\021outgoing_chan_set\030\013 \003(\004B\0020\001\022\031\n\021swe" +
      "ep_conf_target\030\t \001(\005\022\032\n\022htlc_confirmatio" +
      "ns\030\r \001(\005\022%\n\031swap_publication_deadline\030\n " +
      "\001(\004B\0020\001\022\r\n\005label\030\014 \001(\t\022\021\n\tinitiator\030\016 \001(" +
      "\t\022\017\n\007account\030\017 \001(\t\022/\n\021account_addr_type\030" +
      "\020 \001(\0162\024.looprpc.AddressType\"\364\001\n\rLoopInRe" +
      "quest\022\017\n\003amt\030\001 \001(\003B\0020\001\022\030\n\014max_swap_fee\030\002" +
      " \001(\003B\0020\001\022\031\n\rmax_miner_fee\030\003 \001(\003B\0020\001\022\020\n\010l" +
      "ast_hop\030\004 \001(\014\022\025\n\rexternal_htlc\030\005 \001(\010\022\030\n\020" +
      "htlc_conf_target\030\006 \001(\005\022\r\n\005label\030\007 \001(\t\022\021\n" +
      "\tinitiator\030\010 \001(\t\022\'\n\013route_hints\030\t \003(\0132\022." +
      "looprpc.RouteHint\022\017\n\007private\030\n \001(\010\"\217\001\n\014S" +
      "wapResponse\022\020\n\010id_bytes\030\003 \001(\014\022\030\n\014htlc_ad" +
      "dress\030\002 \001(\tB\002\030\001\022\032\n\022htlc_address_p2wsh\030\005 " +
      "\001(\t\022\031\n\021htlc_address_p2tr\030\007 \001(\t\022\026\n\016server" +
      "_message\030\006 \001(\tJ\004\010\004\020\005\"\020\n\016MonitorRequest\"\275" +
      "\003\n\nSwapStatus\022\017\n\003amt\030\001 \001(\003B\0020\001\022\020\n\010id_byt" +
      "es\030\013 \001(\014\022\037\n\004type\030\003 \001(\0162\021.looprpc.SwapTyp" +
      "e\022!\n\005state\030\004 \001(\0162\022.looprpc.SwapState\022.\n\016" +
      "failure_reason\030\016 \001(\0162\026.looprpc.FailureRe" +
      "ason\022\033\n\017initiation_time\030\005 \001(\003B\0020\001\022\034\n\020las" +
      "t_update_time\030\006 \001(\003B\0020\001\022\030\n\014htlc_address\030" +
      "\007 \001(\tB\002\030\001\022\032\n\022htlc_address_p2wsh\030\014 \001(\t\022\031\n" +
      "\021htlc_address_p2tr\030\022 \001(\t\022\027\n\013cost_server\030" +
      "\010 \001(\003B\0020\001\022\030\n\014cost_onchain\030\t \001(\003B\0020\001\022\031\n\rc" +
      "ost_offchain\030\n \001(\003B\0020\001\022\020\n\010last_hop\030\020 \001(\014" +
      "\022\035\n\021outgoing_chan_set\030\021 \003(\004B\0020\001\022\r\n\005label" +
      "\030\017 \001(\t\"\022\n\020ListSwapsRequest\"7\n\021ListSwapsR" +
      "esponse\022\"\n\005swaps\030\001 \003(\0132\023.looprpc.SwapSta" +
      "tus\"\035\n\017SwapInfoRequest\022\n\n\002id\030\001 \001(\014\"\016\n\014Te" +
      "rmsRequest\"i\n\017InTermsResponse\022\033\n\017min_swa" +
      "p_amount\030\005 \001(\003B\0020\001\022\033\n\017max_swap_amount\030\006 " +
      "\001(\003B\0020\001J\004\010\001\020\002J\004\010\002\020\003J\004\010\003\020\004J\004\010\004\020\005J\004\010\007\020\010\"\232\001" +
      "\n\020OutTermsResponse\022\033\n\017min_swap_amount\030\005 " +
      "\001(\003B\0020\001\022\033\n\017max_swap_amount\030\006 \001(\003B\0020\001\022\026\n\016" +
      "min_cltv_delta\030\010 \001(\005\022\026\n\016max_cltv_delta\030\t" +
      " \001(\005J\004\010\001\020\002J\004\010\002\020\003J\004\010\003\020\004J\004\010\004\020\005J\004\010\007\020\010\"\316\001\n\014Q" +
      "uoteRequest\022\017\n\003amt\030\001 \001(\003B\0020\001\022\023\n\013conf_tar" +
      "get\030\002 \001(\005\022\025\n\rexternal_htlc\030\003 \001(\010\022%\n\031swap" +
      "_publication_deadline\030\004 \001(\004B\0020\001\022\030\n\020loop_" +
      "in_last_hop\030\005 \001(\014\022/\n\023loop_in_route_hints" +
      "\030\006 \003(\0132\022.looprpc.RouteHint\022\017\n\007private\030\007 " +
      "\001(\010\"\202\001\n\017InQuoteResponse\022\030\n\014swap_fee_sat\030" +
      "\001 \001(\003B\0020\001\022 \n\024htlc_publish_fee_sat\030\003 \001(\003B" +
      "\0020\001\022\022\n\ncltv_delta\030\005 \001(\005\022\023\n\013conf_target\030\006" +
      " \001(\005J\004\010\002\020\003J\004\010\004\020\005\"\254\001\n\020OutQuoteResponse\022\030\n" +
      "\014swap_fee_sat\030\001 \001(\003B\0020\001\022\032\n\016prepay_amt_sa" +
      "t\030\002 \001(\003B\0020\001\022\036\n\022htlc_sweep_fee_sat\030\003 \001(\003B" +
      "\0020\001\022\031\n\021swap_payment_dest\030\004 \001(\014\022\022\n\ncltv_d" +
      "elta\030\005 \001(\005\022\023\n\013conf_target\030\006 \001(\005\"Z\n\014Probe" +
      "Request\022\017\n\003amt\030\001 \001(\003B\0020\001\022\020\n\010last_hop\030\002 \001" +
      "(\014\022\'\n\013route_hints\030\003 \003(\0132\022.looprpc.RouteH" +
      "int\"\017\n\rProbeResponse\"\017\n\rTokensRequest\"4\n" +
      "\016TokensResponse\022\"\n\006tokens\030\001 \003(\0132\022.looprp" +
      "c.LsatToken\"\340\001\n\tLsatToken\022\025\n\rbase_macaro" +
      "on\030\001 \001(\014\022\024\n\014payment_hash\030\002 \001(\014\022\030\n\020paymen" +
      "t_preimage\030\003 \001(\014\022\034\n\020amount_paid_msat\030\004 \001" +
      "(\003B\0020\001\022!\n\025routing_fee_paid_msat\030\005 \001(\003B\0020" +
      "\001\022\030\n\014time_created\030\006 \001(\003B\0020\001\022\017\n\007expired\030\007" +
      " \001(\010\022\024\n\014storage_name\030\010 \001(\t\022\n\n\002id\030\t \001(\t\"\225" +
      "\001\n\tLoopStats\022\031\n\rpending_count\030\001 \001(\004B\0020\001\022" +
      "\031\n\rsuccess_count\030\002 \001(\004B\0020\001\022\026\n\nfail_count" +
      "\030\003 \001(\004B\0020\001\022\033\n\017sum_pending_amt\030\004 \001(\003B\0020\001\022" +
      "\035\n\021sum_succeeded_amt\030\005 \001(\003B\0020\001\"\020\n\016GetInf" +
      "oRequest\"\341\001\n\017GetInfoResponse\022\017\n\007version\030" +
      "\001 \001(\t\022\017\n\007network\030\002 \001(\t\022\022\n\nrpc_listen\030\003 \001" +
      "(\t\022\023\n\013rest_listen\030\004 \001(\t\022\025\n\rmacaroon_path" +
      "\030\005 \001(\t\022\025\n\rtls_cert_path\030\006 \001(\t\022*\n\016loop_ou" +
      "t_stats\030\007 \001(\0132\022.looprpc.LoopStats\022)\n\rloo" +
      "p_in_stats\030\010 \001(\0132\022.looprpc.LoopStats\"\033\n\031" +
      "GetLiquidityParamsRequest\"\247\006\n\023LiquidityP" +
      "arameters\022%\n\005rules\030\001 \003(\0132\026.looprpc.Liqui" +
      "dityRule\022\023\n\007fee_ppm\030\020 \001(\004B\0020\001\022(\n\034sweep_f" +
      "ee_rate_sat_per_vbyte\030\002 \001(\004B\0020\001\022\034\n\020max_s" +
      "wap_fee_ppm\030\003 \001(\004B\0020\001\022\037\n\023max_routing_fee" +
      "_ppm\030\004 \001(\004B\0020\001\022&\n\032max_prepay_routing_fee" +
      "_ppm\030\005 \001(\004B\0020\001\022\032\n\016max_prepay_sat\030\006 \001(\004B\002" +
      "0\001\022\035\n\021max_miner_fee_sat\030\007 \001(\004B\0020\001\022\031\n\021swe" +
      "ep_conf_target\030\010 \001(\005\022\037\n\023failure_backoff_" +
      "sec\030\t \001(\004B\0020\001\022\020\n\010autoloop\030\n \001(\010\022\037\n\023autol" +
      "oop_budget_sat\030\013 \001(\004B\0020\001\022\'\n\031autoloop_bud" +
      "get_start_sec\030\014 \001(\004B\004\030\0010\001\022\036\n\022auto_max_in" +
      "_flight\030\r \001(\004B\0020\001\022\033\n\017min_swap_amount\030\016 \001" +
      "(\004B\0020\001\022\033\n\017max_swap_amount\030\017 \001(\004B\0020\001\022\030\n\020h" +
      "tlc_conf_target\030\021 \001(\005\022\035\n\025autoloop_dest_a" +
      "ddress\030\022 \001(\t\022.\n\"autoloop_budget_refresh_" +
      "period_sec\030\023 \001(\004B\0020\001\022(\n\034autoloop_budget_" +
      "last_refresh\030\024 \001(\004B\0020\001\022\025\n\reasy_autoloop\030" +
      "\025 \001(\010\022*\n\036easy_autoloop_local_target_sat\030" +
      "\026 \001(\004B\0020\001\022\017\n\007account\030\027 \001(\t\022/\n\021account_ad" +
      "dr_type\030\030 \001(\0162\024.looprpc.AddressType\"\277\001\n\r" +
      "LiquidityRule\022\026\n\nchannel_id\030\001 \001(\004B\0020\001\022$\n" +
      "\tswap_type\030\006 \001(\0162\021.looprpc.SwapType\022\016\n\006p" +
      "ubkey\030\005 \001(\014\022(\n\004type\030\002 \001(\0162\032.looprpc.Liqu" +
      "idityRuleType\022\032\n\022incoming_threshold\030\003 \001(" +
      "\r\022\032\n\022outgoing_threshold\030\004 \001(\r\"M\n\031SetLiqu" +
      "idityParamsRequest\0220\n\nparameters\030\001 \001(\0132\034" +
      ".looprpc.LiquidityParameters\"\034\n\032SetLiqui" +
      "dityParamsResponse\"\025\n\023SuggestSwapsReques" +
      "t\"[\n\014Disqualified\022\026\n\nchannel_id\030\001 \001(\004B\0020" +
      "\001\022\016\n\006pubkey\030\003 \001(\014\022#\n\006reason\030\002 \001(\0162\023.loop" +
      "rpc.AutoReason\"\227\001\n\024SuggestSwapsResponse\022" +
      ")\n\010loop_out\030\001 \003(\0132\027.looprpc.LoopOutReque" +
      "st\022\'\n\007loop_in\030\003 \003(\0132\026.looprpc.LoopInRequ" +
      "est\022+\n\014disqualified\030\002 \003(\0132\025.looprpc.Disq" +
      "ualified\"@\n\022AbandonSwapRequest\022\n\n\002id\030\001 \001" +
      "(\014\022\036\n\026i_know_what_i_am_doing\030\002 \001(\010\"\025\n\023Ab" +
      "andonSwapResponse*;\n\013AddressType\022\030\n\024ADDR" +
      "ESS_TYPE_UNKNOWN\020\000\022\022\n\016TAPROOT_PUBKEY\020\001*%" +
      "\n\010SwapType\022\014\n\010LOOP_OUT\020\000\022\013\n\007LOOP_IN\020\001*s\n" +
      "\tSwapState\022\r\n\tINITIATED\020\000\022\025\n\021PREIMAGE_RE" +
      "VEALED\020\001\022\022\n\016HTLC_PUBLISHED\020\002\022\013\n\007SUCCESS\020" +
      "\003\022\n\n\006FAILED\020\004\022\023\n\017INVOICE_SETTLED\020\005*\276\002\n\rF" +
      "ailureReason\022\027\n\023FAILURE_REASON_NONE\020\000\022\033\n" +
      "\027FAILURE_REASON_OFFCHAIN\020\001\022\032\n\026FAILURE_RE" +
      "ASON_TIMEOUT\020\002\022 \n\034FAILURE_REASON_SWEEP_T" +
      "IMEOUT\020\003\022%\n!FAILURE_REASON_INSUFFICIENT_" +
      "VALUE\020\004\022\034\n\030FAILURE_REASON_TEMPORARY\020\005\022#\n" +
      "\037FAILURE_REASON_INCORRECT_AMOUNT\020\006\022\034\n\030FA" +
      "ILURE_REASON_ABANDONED\020\007\0221\n-FAILURE_REAS" +
      "ON_INSUFFICIENT_CONFIRMED_BALANCE\020\010*/\n\021L" +
      "iquidityRuleType\022\013\n\007UNKNOWN\020\000\022\r\n\tTHRESHO" +
      "LD\020\001*\246\003\n\nAutoReason\022\027\n\023AUTO_REASON_UNKNO" +
      "WN\020\000\022\"\n\036AUTO_REASON_BUDGET_NOT_STARTED\020\001" +
      "\022\032\n\026AUTO_REASON_SWEEP_FEES\020\002\022\036\n\032AUTO_REA" +
      "SON_BUDGET_ELAPSED\020\003\022\031\n\025AUTO_REASON_IN_F" +
      "LIGHT\020\004\022\030\n\024AUTO_REASON_SWAP_FEE\020\005\022\031\n\025AUT" +
      "O_REASON_MINER_FEE\020\006\022\026\n\022AUTO_REASON_PREP" +
      "AY\020\007\022\037\n\033AUTO_REASON_FAILURE_BACKOFF\020\010\022\030\n" +
      "\024AUTO_REASON_LOOP_OUT\020\t\022\027\n\023AUTO_REASON_L" +
      "OOP_IN\020\n\022\034\n\030AUTO_REASON_LIQUIDITY_OK\020\013\022#" +
      "\n\037AUTO_REASON_BUDGET_INSUFFICIENT\020\014\022 \n\034A" +
      "UTO_REASON_FEE_INSUFFICIENT\020\r2\312\010\n\nSwapCl" +
      "ient\0229\n\007LoopOut\022\027.looprpc.LoopOutRequest" +
      "\032\025.looprpc.SwapResponse\0227\n\006LoopIn\022\026.loop" +
      "rpc.LoopInRequest\032\025.looprpc.SwapResponse" +
      "\0229\n\007Monitor\022\027.looprpc.MonitorRequest\032\023.l" +
      "ooprpc.SwapStatus0\001\022B\n\tListSwaps\022\031.loopr" +
      "pc.ListSwapsRequest\032\032.looprpc.ListSwapsR" +
      "esponse\0229\n\010SwapInfo\022\030.looprpc.SwapInfoRe" +
      "quest\032\023.looprpc.SwapStatus\022H\n\013AbandonSwa" +
      "p\022\033.looprpc.AbandonSwapRequest\032\034.looprpc" +
      ".AbandonSwapResponse\022@\n\014LoopOutTerms\022\025.l" +
      "ooprpc.TermsRequest\032\031.looprpc.OutTermsRe" +
      "sponse\022@\n\014LoopOutQuote\022\025.looprpc.QuoteRe" +
      "quest\032\031.looprpc.OutQuoteResponse\022A\n\016GetL" +
      "oopInTerms\022\025.looprpc.TermsRequest\032\030.loop" +
      "rpc.InTermsResponse\022A\n\016GetLoopInQuote\022\025." +
      "looprpc.QuoteRequest\032\030.looprpc.InQuoteRe" +
      "sponse\0226\n\005Probe\022\025.looprpc.ProbeRequest\032\026" +
      ".looprpc.ProbeResponse\022@\n\rGetLsatTokens\022" +
      "\026.looprpc.TokensRequest\032\027.looprpc.Tokens" +
      "Response\022<\n\007GetInfo\022\027.looprpc.GetInfoReq" +
      "uest\032\030.looprpc.GetInfoResponse\022V\n\022GetLiq" +
      "uidityParams\022\".looprpc.GetLiquidityParam" +
      "sRequest\032\034.looprpc.LiquidityParameters\022]" +
      "\n\022SetLiquidityParams\022\".looprpc.SetLiquid" +
      "ityParamsRequest\032#.looprpc.SetLiquidityP" +
      "aramsResponse\022K\n\014SuggestSwaps\022\034.looprpc." +
      "SuggestSwapsRequest\032\035.looprpc.SuggestSwa" +
      "psResponseB\'Z%github.com/lightninglabs/l" +
      "oop/looprpcb\006proto3"
    };
    descriptor = com.google.protobuf.Descriptors.FileDescriptor
      .internalBuildGeneratedFileFrom(descriptorData,
        new com.google.protobuf.Descriptors.FileDescriptor[] {
          looprpc.Common.getDescriptor(),
        });
    internal_static_looprpc_LoopOutRequest_descriptor =
      getDescriptor().getMessageTypes().get(0);
    internal_static_looprpc_LoopOutRequest_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_looprpc_LoopOutRequest_descriptor,
        new java.lang.String[] { "Amt", "Dest", "MaxSwapRoutingFee", "MaxPrepayRoutingFee", "MaxSwapFee", "MaxPrepayAmt", "MaxMinerFee", "LoopOutChannel", "OutgoingChanSet", "SweepConfTarget", "HtlcConfirmations", "SwapPublicationDeadline", "Label", "Initiator", "Account", "AccountAddrType", });
    internal_static_looprpc_LoopInRequest_descriptor =
      getDescriptor().getMessageTypes().get(1);
    internal_static_looprpc_LoopInRequest_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_looprpc_LoopInRequest_descriptor,
        new java.lang.String[] { "Amt", "MaxSwapFee", "MaxMinerFee", "LastHop", "ExternalHtlc", "HtlcConfTarget", "Label", "Initiator", "RouteHints", "Private", });
    internal_static_looprpc_SwapResponse_descriptor =
      getDescriptor().getMessageTypes().get(2);
    internal_static_looprpc_SwapResponse_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_looprpc_SwapResponse_descriptor,
        new java.lang.String[] { "IdBytes", "HtlcAddress", "HtlcAddressP2Wsh", "HtlcAddressP2Tr", "ServerMessage", });
    internal_static_looprpc_MonitorRequest_descriptor =
      getDescriptor().getMessageTypes().get(3);
    internal_static_looprpc_MonitorRequest_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_looprpc_MonitorRequest_descriptor,
        new java.lang.String[] { });
    internal_static_looprpc_SwapStatus_descriptor =
      getDescriptor().getMessageTypes().get(4);
    internal_static_looprpc_SwapStatus_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_looprpc_SwapStatus_descriptor,
        new java.lang.String[] { "Amt", "IdBytes", "Type", "State", "FailureReason", "InitiationTime", "LastUpdateTime", "HtlcAddress", "HtlcAddressP2Wsh", "HtlcAddressP2Tr", "CostServer", "CostOnchain", "CostOffchain", "LastHop", "OutgoingChanSet", "Label", });
    internal_static_looprpc_ListSwapsRequest_descriptor =
      getDescriptor().getMessageTypes().get(5);
    internal_static_looprpc_ListSwapsRequest_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_looprpc_ListSwapsRequest_descriptor,
        new java.lang.String[] { });
    internal_static_looprpc_ListSwapsResponse_descriptor =
      getDescriptor().getMessageTypes().get(6);
    internal_static_looprpc_ListSwapsResponse_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_looprpc_ListSwapsResponse_descriptor,
        new java.lang.String[] { "Swaps", });
    internal_static_looprpc_SwapInfoRequest_descriptor =
      getDescriptor().getMessageTypes().get(7);
    internal_static_looprpc_SwapInfoRequest_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_looprpc_SwapInfoRequest_descriptor,
        new java.lang.String[] { "Id", });
    internal_static_looprpc_TermsRequest_descriptor =
      getDescriptor().getMessageTypes().get(8);
    internal_static_looprpc_TermsRequest_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_looprpc_TermsRequest_descriptor,
        new java.lang.String[] { });
    internal_static_looprpc_InTermsResponse_descriptor =
      getDescriptor().getMessageTypes().get(9);
    internal_static_looprpc_InTermsResponse_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_looprpc_InTermsResponse_descriptor,
        new java.lang.String[] { "MinSwapAmount", "MaxSwapAmount", });
    internal_static_looprpc_OutTermsResponse_descriptor =
      getDescriptor().getMessageTypes().get(10);
    internal_static_looprpc_OutTermsResponse_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_looprpc_OutTermsResponse_descriptor,
        new java.lang.String[] { "MinSwapAmount", "MaxSwapAmount", "MinCltvDelta", "MaxCltvDelta", });
    internal_static_looprpc_QuoteRequest_descriptor =
      getDescriptor().getMessageTypes().get(11);
    internal_static_looprpc_QuoteRequest_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_looprpc_QuoteRequest_descriptor,
        new java.lang.String[] { "Amt", "ConfTarget", "ExternalHtlc", "SwapPublicationDeadline", "LoopInLastHop", "LoopInRouteHints", "Private", });
    internal_static_looprpc_InQuoteResponse_descriptor =
      getDescriptor().getMessageTypes().get(12);
    internal_static_looprpc_InQuoteResponse_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_looprpc_InQuoteResponse_descriptor,
        new java.lang.String[] { "SwapFeeSat", "HtlcPublishFeeSat", "CltvDelta", "ConfTarget", });
    internal_static_looprpc_OutQuoteResponse_descriptor =
      getDescriptor().getMessageTypes().get(13);
    internal_static_looprpc_OutQuoteResponse_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_looprpc_OutQuoteResponse_descriptor,
        new java.lang.String[] { "SwapFeeSat", "PrepayAmtSat", "HtlcSweepFeeSat", "SwapPaymentDest", "CltvDelta", "ConfTarget", });
    internal_static_looprpc_ProbeRequest_descriptor =
      getDescriptor().getMessageTypes().get(14);
    internal_static_looprpc_ProbeRequest_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_looprpc_ProbeRequest_descriptor,
        new java.lang.String[] { "Amt", "LastHop", "RouteHints", });
    internal_static_looprpc_ProbeResponse_descriptor =
      getDescriptor().getMessageTypes().get(15);
    internal_static_looprpc_ProbeResponse_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_looprpc_ProbeResponse_descriptor,
        new java.lang.String[] { });
    internal_static_looprpc_TokensRequest_descriptor =
      getDescriptor().getMessageTypes().get(16);
    internal_static_looprpc_TokensRequest_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_looprpc_TokensRequest_descriptor,
        new java.lang.String[] { });
    internal_static_looprpc_TokensResponse_descriptor =
      getDescriptor().getMessageTypes().get(17);
    internal_static_looprpc_TokensResponse_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_looprpc_TokensResponse_descriptor,
        new java.lang.String[] { "Tokens", });
    internal_static_looprpc_LsatToken_descriptor =
      getDescriptor().getMessageTypes().get(18);
    internal_static_looprpc_LsatToken_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_looprpc_LsatToken_descriptor,
        new java.lang.String[] { "BaseMacaroon", "PaymentHash", "PaymentPreimage", "AmountPaidMsat", "RoutingFeePaidMsat", "TimeCreated", "Expired", "StorageName", "Id", });
    internal_static_looprpc_LoopStats_descriptor =
      getDescriptor().getMessageTypes().get(19);
    internal_static_looprpc_LoopStats_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_looprpc_LoopStats_descriptor,
        new java.lang.String[] { "PendingCount", "SuccessCount", "FailCount", "SumPendingAmt", "SumSucceededAmt", });
    internal_static_looprpc_GetInfoRequest_descriptor =
      getDescriptor().getMessageTypes().get(20);
    internal_static_looprpc_GetInfoRequest_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_looprpc_GetInfoRequest_descriptor,
        new java.lang.String[] { });
    internal_static_looprpc_GetInfoResponse_descriptor =
      getDescriptor().getMessageTypes().get(21);
    internal_static_looprpc_GetInfoResponse_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_looprpc_GetInfoResponse_descriptor,
        new java.lang.String[] { "Version", "Network", "RpcListen", "RestListen", "MacaroonPath", "TlsCertPath", "LoopOutStats", "LoopInStats", });
    internal_static_looprpc_GetLiquidityParamsRequest_descriptor =
      getDescriptor().getMessageTypes().get(22);
    internal_static_looprpc_GetLiquidityParamsRequest_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_looprpc_GetLiquidityParamsRequest_descriptor,
        new java.lang.String[] { });
    internal_static_looprpc_LiquidityParameters_descriptor =
      getDescriptor().getMessageTypes().get(23);
    internal_static_looprpc_LiquidityParameters_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_looprpc_LiquidityParameters_descriptor,
        new java.lang.String[] { "Rules", "FeePpm", "SweepFeeRateSatPerVbyte", "MaxSwapFeePpm", "MaxRoutingFeePpm", "MaxPrepayRoutingFeePpm", "MaxPrepaySat", "MaxMinerFeeSat", "SweepConfTarget", "FailureBackoffSec", "Autoloop", "AutoloopBudgetSat", "AutoloopBudgetStartSec", "AutoMaxInFlight", "MinSwapAmount", "MaxSwapAmount", "HtlcConfTarget", "AutoloopDestAddress", "AutoloopBudgetRefreshPeriodSec", "AutoloopBudgetLastRefresh", "EasyAutoloop", "EasyAutoloopLocalTargetSat", "Account", "AccountAddrType", });
    internal_static_looprpc_LiquidityRule_descriptor =
      getDescriptor().getMessageTypes().get(24);
    internal_static_looprpc_LiquidityRule_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_looprpc_LiquidityRule_descriptor,
        new java.lang.String[] { "ChannelId", "SwapType", "Pubkey", "Type", "IncomingThreshold", "OutgoingThreshold", });
    internal_static_looprpc_SetLiquidityParamsRequest_descriptor =
      getDescriptor().getMessageTypes().get(25);
    internal_static_looprpc_SetLiquidityParamsRequest_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_looprpc_SetLiquidityParamsRequest_descriptor,
        new java.lang.String[] { "Parameters", });
    internal_static_looprpc_SetLiquidityParamsResponse_descriptor =
      getDescriptor().getMessageTypes().get(26);
    internal_static_looprpc_SetLiquidityParamsResponse_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_looprpc_SetLiquidityParamsResponse_descriptor,
        new java.lang.String[] { });
    internal_static_looprpc_SuggestSwapsRequest_descriptor =
      getDescriptor().getMessageTypes().get(27);
    internal_static_looprpc_SuggestSwapsRequest_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_looprpc_SuggestSwapsRequest_descriptor,
        new java.lang.String[] { });
    internal_static_looprpc_Disqualified_descriptor =
      getDescriptor().getMessageTypes().get(28);
    internal_static_looprpc_Disqualified_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_looprpc_Disqualified_descriptor,
        new java.lang.String[] { "ChannelId", "Pubkey", "Reason", });
    internal_static_looprpc_SuggestSwapsResponse_descriptor =
      getDescriptor().getMessageTypes().get(29);
    internal_static_looprpc_SuggestSwapsResponse_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_looprpc_SuggestSwapsResponse_descriptor,
        new java.lang.String[] { "LoopOut", "LoopIn", "Disqualified", });
    internal_static_looprpc_AbandonSwapRequest_descriptor =
      getDescriptor().getMessageTypes().get(30);
    internal_static_looprpc_AbandonSwapRequest_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_looprpc_AbandonSwapRequest_descriptor,
        new java.lang.String[] { "Id", "IKnowWhatIAmDoing", });
    internal_static_looprpc_AbandonSwapResponse_descriptor =
      getDescriptor().getMessageTypes().get(31);
    internal_static_looprpc_AbandonSwapResponse_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_looprpc_AbandonSwapResponse_descriptor,
        new java.lang.String[] { });
    looprpc.Common.getDescriptor();
  }

  // @@protoc_insertion_point(outer_class_scope)
}
