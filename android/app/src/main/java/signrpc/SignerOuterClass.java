// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: signrpc/signer.proto

package signrpc;

public final class SignerOuterClass {
  private SignerOuterClass() {}
  public static void registerAllExtensions(
      com.google.protobuf.ExtensionRegistryLite registry) {
  }

  public static void registerAllExtensions(
      com.google.protobuf.ExtensionRegistry registry) {
    registerAllExtensions(
        (com.google.protobuf.ExtensionRegistryLite) registry);
  }
  /**
   * Protobuf enum {@code signrpc.SignMethod}
   */
  public enum SignMethod
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <pre>
     *
     *Specifies that a SegWit v0 (p2wkh, np2wkh, p2wsh) input script should be
     *signed.
     * </pre>
     *
     * <code>SIGN_METHOD_WITNESS_V0 = 0;</code>
     */
    SIGN_METHOD_WITNESS_V0(0),
    /**
     * <pre>
     *
     *Specifies that a SegWit v1 (p2tr) input should be signed by using the
     *BIP0086 method (commit to internal key only).
     * </pre>
     *
     * <code>SIGN_METHOD_TAPROOT_KEY_SPEND_BIP0086 = 1;</code>
     */
    SIGN_METHOD_TAPROOT_KEY_SPEND_BIP0086(1),
    /**
     * <pre>
     *
     *Specifies that a SegWit v1 (p2tr) input should be signed by using a given
     *taproot hash to commit to in addition to the internal key.
     * </pre>
     *
     * <code>SIGN_METHOD_TAPROOT_KEY_SPEND = 2;</code>
     */
    SIGN_METHOD_TAPROOT_KEY_SPEND(2),
    /**
     * <pre>
     *
     *Specifies that a SegWit v1 (p2tr) input should be spent using the script
     *path and that a specific leaf script should be signed for.
     * </pre>
     *
     * <code>SIGN_METHOD_TAPROOT_SCRIPT_SPEND = 3;</code>
     */
    SIGN_METHOD_TAPROOT_SCRIPT_SPEND(3),
    UNRECOGNIZED(-1),
    ;

    /**
     * <pre>
     *
     *Specifies that a SegWit v0 (p2wkh, np2wkh, p2wsh) input script should be
     *signed.
     * </pre>
     *
     * <code>SIGN_METHOD_WITNESS_V0 = 0;</code>
     */
    public static final int SIGN_METHOD_WITNESS_V0_VALUE = 0;
    /**
     * <pre>
     *
     *Specifies that a SegWit v1 (p2tr) input should be signed by using the
     *BIP0086 method (commit to internal key only).
     * </pre>
     *
     * <code>SIGN_METHOD_TAPROOT_KEY_SPEND_BIP0086 = 1;</code>
     */
    public static final int SIGN_METHOD_TAPROOT_KEY_SPEND_BIP0086_VALUE = 1;
    /**
     * <pre>
     *
     *Specifies that a SegWit v1 (p2tr) input should be signed by using a given
     *taproot hash to commit to in addition to the internal key.
     * </pre>
     *
     * <code>SIGN_METHOD_TAPROOT_KEY_SPEND = 2;</code>
     */
    public static final int SIGN_METHOD_TAPROOT_KEY_SPEND_VALUE = 2;
    /**
     * <pre>
     *
     *Specifies that a SegWit v1 (p2tr) input should be spent using the script
     *path and that a specific leaf script should be signed for.
     * </pre>
     *
     * <code>SIGN_METHOD_TAPROOT_SCRIPT_SPEND = 3;</code>
     */
    public static final int SIGN_METHOD_TAPROOT_SCRIPT_SPEND_VALUE = 3;


    public final int getNumber() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalArgumentException(
            "Can't get the number of an unknown enum value.");
      }
      return value;
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     * @deprecated Use {@link #forNumber(int)} instead.
     */
    @java.lang.Deprecated
    public static SignMethod valueOf(int value) {
      return forNumber(value);
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     */
    public static SignMethod forNumber(int value) {
      switch (value) {
        case 0: return SIGN_METHOD_WITNESS_V0;
        case 1: return SIGN_METHOD_TAPROOT_KEY_SPEND_BIP0086;
        case 2: return SIGN_METHOD_TAPROOT_KEY_SPEND;
        case 3: return SIGN_METHOD_TAPROOT_SCRIPT_SPEND;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<SignMethod>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static final com.google.protobuf.Internal.EnumLiteMap<
        SignMethod> internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<SignMethod>() {
            public SignMethod findValueByNumber(int number) {
              return SignMethod.forNumber(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalStateException(
            "Can't get the descriptor of an unrecognized enum value.");
      }
      return getDescriptor().getValues().get(ordinal());
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return signrpc.SignerOuterClass.getDescriptor().getEnumTypes().get(0);
    }

    private static final SignMethod[] VALUES = values();

    public static SignMethod valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      if (desc.getIndex() == -1) {
        return UNRECOGNIZED;
      }
      return VALUES[desc.getIndex()];
    }

    private final int value;

    private SignMethod(int value) {
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:signrpc.SignMethod)
  }

  /**
   * Protobuf enum {@code signrpc.MuSig2Version}
   */
  public enum MuSig2Version
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <pre>
     *
     *The default value on the RPC is zero for enums so we need to represent an
     *invalid/undefined version by default to make sure clients upgrade their
     *software to set the version explicitly.
     * </pre>
     *
     * <code>MUSIG2_VERSION_UNDEFINED = 0;</code>
     */
    MUSIG2_VERSION_UNDEFINED(0),
    /**
     * <pre>
     *
     *The version of MuSig2 that lnd 0.15.x shipped with, which corresponds to the
     *version v0.4.0 of the MuSig2 BIP draft.
     * </pre>
     *
     * <code>MUSIG2_VERSION_V040 = 1;</code>
     */
    MUSIG2_VERSION_V040(1),
    /**
     * <pre>
     *
     *The current version of MuSig2 which corresponds to the version v1.0.0rc2 of
     *the MuSig2 BIP draft.
     * </pre>
     *
     * <code>MUSIG2_VERSION_V100RC2 = 2;</code>
     */
    MUSIG2_VERSION_V100RC2(2),
    UNRECOGNIZED(-1),
    ;

    /**
     * <pre>
     *
     *The default value on the RPC is zero for enums so we need to represent an
     *invalid/undefined version by default to make sure clients upgrade their
     *software to set the version explicitly.
     * </pre>
     *
     * <code>MUSIG2_VERSION_UNDEFINED = 0;</code>
     */
    public static final int MUSIG2_VERSION_UNDEFINED_VALUE = 0;
    /**
     * <pre>
     *
     *The version of MuSig2 that lnd 0.15.x shipped with, which corresponds to the
     *version v0.4.0 of the MuSig2 BIP draft.
     * </pre>
     *
     * <code>MUSIG2_VERSION_V040 = 1;</code>
     */
    public static final int MUSIG2_VERSION_V040_VALUE = 1;
    /**
     * <pre>
     *
     *The current version of MuSig2 which corresponds to the version v1.0.0rc2 of
     *the MuSig2 BIP draft.
     * </pre>
     *
     * <code>MUSIG2_VERSION_V100RC2 = 2;</code>
     */
    public static final int MUSIG2_VERSION_V100RC2_VALUE = 2;


    public final int getNumber() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalArgumentException(
            "Can't get the number of an unknown enum value.");
      }
      return value;
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     * @deprecated Use {@link #forNumber(int)} instead.
     */
    @java.lang.Deprecated
    public static MuSig2Version valueOf(int value) {
      return forNumber(value);
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     */
    public static MuSig2Version forNumber(int value) {
      switch (value) {
        case 0: return MUSIG2_VERSION_UNDEFINED;
        case 1: return MUSIG2_VERSION_V040;
        case 2: return MUSIG2_VERSION_V100RC2;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<MuSig2Version>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static final com.google.protobuf.Internal.EnumLiteMap<
        MuSig2Version> internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<MuSig2Version>() {
            public MuSig2Version findValueByNumber(int number) {
              return MuSig2Version.forNumber(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalStateException(
            "Can't get the descriptor of an unrecognized enum value.");
      }
      return getDescriptor().getValues().get(ordinal());
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return signrpc.SignerOuterClass.getDescriptor().getEnumTypes().get(1);
    }

    private static final MuSig2Version[] VALUES = values();

    public static MuSig2Version valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      if (desc.getIndex() == -1) {
        return UNRECOGNIZED;
      }
      return VALUES[desc.getIndex()];
    }

    private final int value;

    private MuSig2Version(int value) {
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:signrpc.MuSig2Version)
  }

  public interface KeyLocatorOrBuilder extends
      // @@protoc_insertion_point(interface_extends:signrpc.KeyLocator)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * The family of key being identified.
     * </pre>
     *
     * <code>int32 key_family = 1;</code>
     * @return The keyFamily.
     */
    int getKeyFamily();

    /**
     * <pre>
     * The precise index of the key being identified.
     * </pre>
     *
     * <code>int32 key_index = 2;</code>
     * @return The keyIndex.
     */
    int getKeyIndex();
  }
  /**
   * Protobuf type {@code signrpc.KeyLocator}
   */
  public static final class KeyLocator extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:signrpc.KeyLocator)
      KeyLocatorOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use KeyLocator.newBuilder() to construct.
    private KeyLocator(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private KeyLocator() {
    }

    @java.lang.Override
    @SuppressWarnings({"unused"})
    protected java.lang.Object newInstance(
        UnusedPrivateParameter unused) {
      return new KeyLocator();
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return signrpc.SignerOuterClass.internal_static_signrpc_KeyLocator_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return signrpc.SignerOuterClass.internal_static_signrpc_KeyLocator_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              signrpc.SignerOuterClass.KeyLocator.class, signrpc.SignerOuterClass.KeyLocator.Builder.class);
    }

    public static final int KEY_FAMILY_FIELD_NUMBER = 1;
    private int keyFamily_ = 0;
    /**
     * <pre>
     * The family of key being identified.
     * </pre>
     *
     * <code>int32 key_family = 1;</code>
     * @return The keyFamily.
     */
    @java.lang.Override
    public int getKeyFamily() {
      return keyFamily_;
    }

    public static final int KEY_INDEX_FIELD_NUMBER = 2;
    private int keyIndex_ = 0;
    /**
     * <pre>
     * The precise index of the key being identified.
     * </pre>
     *
     * <code>int32 key_index = 2;</code>
     * @return The keyIndex.
     */
    @java.lang.Override
    public int getKeyIndex() {
      return keyIndex_;
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (keyFamily_ != 0) {
        output.writeInt32(1, keyFamily_);
      }
      if (keyIndex_ != 0) {
        output.writeInt32(2, keyIndex_);
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (keyFamily_ != 0) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt32Size(1, keyFamily_);
      }
      if (keyIndex_ != 0) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt32Size(2, keyIndex_);
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof signrpc.SignerOuterClass.KeyLocator)) {
        return super.equals(obj);
      }
      signrpc.SignerOuterClass.KeyLocator other = (signrpc.SignerOuterClass.KeyLocator) obj;

      if (getKeyFamily()
          != other.getKeyFamily()) return false;
      if (getKeyIndex()
          != other.getKeyIndex()) return false;
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      hash = (37 * hash) + KEY_FAMILY_FIELD_NUMBER;
      hash = (53 * hash) + getKeyFamily();
      hash = (37 * hash) + KEY_INDEX_FIELD_NUMBER;
      hash = (53 * hash) + getKeyIndex();
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static signrpc.SignerOuterClass.KeyLocator parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static signrpc.SignerOuterClass.KeyLocator parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static signrpc.SignerOuterClass.KeyLocator parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static signrpc.SignerOuterClass.KeyLocator parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static signrpc.SignerOuterClass.KeyLocator parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static signrpc.SignerOuterClass.KeyLocator parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static signrpc.SignerOuterClass.KeyLocator parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static signrpc.SignerOuterClass.KeyLocator parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static signrpc.SignerOuterClass.KeyLocator parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static signrpc.SignerOuterClass.KeyLocator parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static signrpc.SignerOuterClass.KeyLocator parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static signrpc.SignerOuterClass.KeyLocator parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(signrpc.SignerOuterClass.KeyLocator prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * Protobuf type {@code signrpc.KeyLocator}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:signrpc.KeyLocator)
        signrpc.SignerOuterClass.KeyLocatorOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return signrpc.SignerOuterClass.internal_static_signrpc_KeyLocator_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return signrpc.SignerOuterClass.internal_static_signrpc_KeyLocator_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                signrpc.SignerOuterClass.KeyLocator.class, signrpc.SignerOuterClass.KeyLocator.Builder.class);
      }

      // Construct using signrpc.SignerOuterClass.KeyLocator.newBuilder()
      private Builder() {

      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);

      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        keyFamily_ = 0;
        keyIndex_ = 0;
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return signrpc.SignerOuterClass.internal_static_signrpc_KeyLocator_descriptor;
      }

      @java.lang.Override
      public signrpc.SignerOuterClass.KeyLocator getDefaultInstanceForType() {
        return signrpc.SignerOuterClass.KeyLocator.getDefaultInstance();
      }

      @java.lang.Override
      public signrpc.SignerOuterClass.KeyLocator build() {
        signrpc.SignerOuterClass.KeyLocator result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public signrpc.SignerOuterClass.KeyLocator buildPartial() {
        signrpc.SignerOuterClass.KeyLocator result = new signrpc.SignerOuterClass.KeyLocator(this);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartial0(signrpc.SignerOuterClass.KeyLocator result) {
        int from_bitField0_ = bitField0_;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.keyFamily_ = keyFamily_;
        }
        if (((from_bitField0_ & 0x00000002) != 0)) {
          result.keyIndex_ = keyIndex_;
        }
      }

      @java.lang.Override
      public Builder clone() {
        return super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof signrpc.SignerOuterClass.KeyLocator) {
          return mergeFrom((signrpc.SignerOuterClass.KeyLocator)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(signrpc.SignerOuterClass.KeyLocator other) {
        if (other == signrpc.SignerOuterClass.KeyLocator.getDefaultInstance()) return this;
        if (other.getKeyFamily() != 0) {
          setKeyFamily(other.getKeyFamily());
        }
        if (other.getKeyIndex() != 0) {
          setKeyIndex(other.getKeyIndex());
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 8: {
                keyFamily_ = input.readInt32();
                bitField0_ |= 0x00000001;
                break;
              } // case 8
              case 16: {
                keyIndex_ = input.readInt32();
                bitField0_ |= 0x00000002;
                break;
              } // case 16
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private int keyFamily_ ;
      /**
       * <pre>
       * The family of key being identified.
       * </pre>
       *
       * <code>int32 key_family = 1;</code>
       * @return The keyFamily.
       */
      @java.lang.Override
      public int getKeyFamily() {
        return keyFamily_;
      }
      /**
       * <pre>
       * The family of key being identified.
       * </pre>
       *
       * <code>int32 key_family = 1;</code>
       * @param value The keyFamily to set.
       * @return This builder for chaining.
       */
      public Builder setKeyFamily(int value) {

        keyFamily_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The family of key being identified.
       * </pre>
       *
       * <code>int32 key_family = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearKeyFamily() {
        bitField0_ = (bitField0_ & ~0x00000001);
        keyFamily_ = 0;
        onChanged();
        return this;
      }

      private int keyIndex_ ;
      /**
       * <pre>
       * The precise index of the key being identified.
       * </pre>
       *
       * <code>int32 key_index = 2;</code>
       * @return The keyIndex.
       */
      @java.lang.Override
      public int getKeyIndex() {
        return keyIndex_;
      }
      /**
       * <pre>
       * The precise index of the key being identified.
       * </pre>
       *
       * <code>int32 key_index = 2;</code>
       * @param value The keyIndex to set.
       * @return This builder for chaining.
       */
      public Builder setKeyIndex(int value) {

        keyIndex_ = value;
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The precise index of the key being identified.
       * </pre>
       *
       * <code>int32 key_index = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearKeyIndex() {
        bitField0_ = (bitField0_ & ~0x00000002);
        keyIndex_ = 0;
        onChanged();
        return this;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:signrpc.KeyLocator)
    }

    // @@protoc_insertion_point(class_scope:signrpc.KeyLocator)
    private static final signrpc.SignerOuterClass.KeyLocator DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new signrpc.SignerOuterClass.KeyLocator();
    }

    public static signrpc.SignerOuterClass.KeyLocator getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<KeyLocator>
        PARSER = new com.google.protobuf.AbstractParser<KeyLocator>() {
      @java.lang.Override
      public KeyLocator parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<KeyLocator> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<KeyLocator> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public signrpc.SignerOuterClass.KeyLocator getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface KeyDescriptorOrBuilder extends
      // @@protoc_insertion_point(interface_extends:signrpc.KeyDescriptor)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     *
     *The raw bytes of the public key in the key pair being identified. Either
     *this or the KeyLocator must be specified.
     * </pre>
     *
     * <code>bytes raw_key_bytes = 1;</code>
     * @return The rawKeyBytes.
     */
    com.google.protobuf.ByteString getRawKeyBytes();

    /**
     * <pre>
     *
     *The key locator that identifies which private key to use for signing.
     *Either this or the raw bytes of the target public key must be specified.
     * </pre>
     *
     * <code>.signrpc.KeyLocator key_loc = 2;</code>
     * @return Whether the keyLoc field is set.
     */
    boolean hasKeyLoc();
    /**
     * <pre>
     *
     *The key locator that identifies which private key to use for signing.
     *Either this or the raw bytes of the target public key must be specified.
     * </pre>
     *
     * <code>.signrpc.KeyLocator key_loc = 2;</code>
     * @return The keyLoc.
     */
    signrpc.SignerOuterClass.KeyLocator getKeyLoc();
    /**
     * <pre>
     *
     *The key locator that identifies which private key to use for signing.
     *Either this or the raw bytes of the target public key must be specified.
     * </pre>
     *
     * <code>.signrpc.KeyLocator key_loc = 2;</code>
     */
    signrpc.SignerOuterClass.KeyLocatorOrBuilder getKeyLocOrBuilder();
  }
  /**
   * Protobuf type {@code signrpc.KeyDescriptor}
   */
  public static final class KeyDescriptor extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:signrpc.KeyDescriptor)
      KeyDescriptorOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use KeyDescriptor.newBuilder() to construct.
    private KeyDescriptor(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private KeyDescriptor() {
      rawKeyBytes_ = com.google.protobuf.ByteString.EMPTY;
    }

    @java.lang.Override
    @SuppressWarnings({"unused"})
    protected java.lang.Object newInstance(
        UnusedPrivateParameter unused) {
      return new KeyDescriptor();
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return signrpc.SignerOuterClass.internal_static_signrpc_KeyDescriptor_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return signrpc.SignerOuterClass.internal_static_signrpc_KeyDescriptor_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              signrpc.SignerOuterClass.KeyDescriptor.class, signrpc.SignerOuterClass.KeyDescriptor.Builder.class);
    }

    private int bitField0_;
    public static final int RAW_KEY_BYTES_FIELD_NUMBER = 1;
    private com.google.protobuf.ByteString rawKeyBytes_ = com.google.protobuf.ByteString.EMPTY;
    /**
     * <pre>
     *
     *The raw bytes of the public key in the key pair being identified. Either
     *this or the KeyLocator must be specified.
     * </pre>
     *
     * <code>bytes raw_key_bytes = 1;</code>
     * @return The rawKeyBytes.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString getRawKeyBytes() {
      return rawKeyBytes_;
    }

    public static final int KEY_LOC_FIELD_NUMBER = 2;
    private signrpc.SignerOuterClass.KeyLocator keyLoc_;
    /**
     * <pre>
     *
     *The key locator that identifies which private key to use for signing.
     *Either this or the raw bytes of the target public key must be specified.
     * </pre>
     *
     * <code>.signrpc.KeyLocator key_loc = 2;</code>
     * @return Whether the keyLoc field is set.
     */
    @java.lang.Override
    public boolean hasKeyLoc() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     *
     *The key locator that identifies which private key to use for signing.
     *Either this or the raw bytes of the target public key must be specified.
     * </pre>
     *
     * <code>.signrpc.KeyLocator key_loc = 2;</code>
     * @return The keyLoc.
     */
    @java.lang.Override
    public signrpc.SignerOuterClass.KeyLocator getKeyLoc() {
      return keyLoc_ == null ? signrpc.SignerOuterClass.KeyLocator.getDefaultInstance() : keyLoc_;
    }
    /**
     * <pre>
     *
     *The key locator that identifies which private key to use for signing.
     *Either this or the raw bytes of the target public key must be specified.
     * </pre>
     *
     * <code>.signrpc.KeyLocator key_loc = 2;</code>
     */
    @java.lang.Override
    public signrpc.SignerOuterClass.KeyLocatorOrBuilder getKeyLocOrBuilder() {
      return keyLoc_ == null ? signrpc.SignerOuterClass.KeyLocator.getDefaultInstance() : keyLoc_;
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (!rawKeyBytes_.isEmpty()) {
        output.writeBytes(1, rawKeyBytes_);
      }
      if (((bitField0_ & 0x00000001) != 0)) {
        output.writeMessage(2, getKeyLoc());
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (!rawKeyBytes_.isEmpty()) {
        size += com.google.protobuf.CodedOutputStream
          .computeBytesSize(1, rawKeyBytes_);
      }
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(2, getKeyLoc());
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof signrpc.SignerOuterClass.KeyDescriptor)) {
        return super.equals(obj);
      }
      signrpc.SignerOuterClass.KeyDescriptor other = (signrpc.SignerOuterClass.KeyDescriptor) obj;

      if (!getRawKeyBytes()
          .equals(other.getRawKeyBytes())) return false;
      if (hasKeyLoc() != other.hasKeyLoc()) return false;
      if (hasKeyLoc()) {
        if (!getKeyLoc()
            .equals(other.getKeyLoc())) return false;
      }
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      hash = (37 * hash) + RAW_KEY_BYTES_FIELD_NUMBER;
      hash = (53 * hash) + getRawKeyBytes().hashCode();
      if (hasKeyLoc()) {
        hash = (37 * hash) + KEY_LOC_FIELD_NUMBER;
        hash = (53 * hash) + getKeyLoc().hashCode();
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static signrpc.SignerOuterClass.KeyDescriptor parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static signrpc.SignerOuterClass.KeyDescriptor parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static signrpc.SignerOuterClass.KeyDescriptor parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static signrpc.SignerOuterClass.KeyDescriptor parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static signrpc.SignerOuterClass.KeyDescriptor parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static signrpc.SignerOuterClass.KeyDescriptor parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static signrpc.SignerOuterClass.KeyDescriptor parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static signrpc.SignerOuterClass.KeyDescriptor parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static signrpc.SignerOuterClass.KeyDescriptor parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static signrpc.SignerOuterClass.KeyDescriptor parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static signrpc.SignerOuterClass.KeyDescriptor parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static signrpc.SignerOuterClass.KeyDescriptor parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(signrpc.SignerOuterClass.KeyDescriptor prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * Protobuf type {@code signrpc.KeyDescriptor}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:signrpc.KeyDescriptor)
        signrpc.SignerOuterClass.KeyDescriptorOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return signrpc.SignerOuterClass.internal_static_signrpc_KeyDescriptor_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return signrpc.SignerOuterClass.internal_static_signrpc_KeyDescriptor_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                signrpc.SignerOuterClass.KeyDescriptor.class, signrpc.SignerOuterClass.KeyDescriptor.Builder.class);
      }

      // Construct using signrpc.SignerOuterClass.KeyDescriptor.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
          getKeyLocFieldBuilder();
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        rawKeyBytes_ = com.google.protobuf.ByteString.EMPTY;
        keyLoc_ = null;
        if (keyLocBuilder_ != null) {
          keyLocBuilder_.dispose();
          keyLocBuilder_ = null;
        }
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return signrpc.SignerOuterClass.internal_static_signrpc_KeyDescriptor_descriptor;
      }

      @java.lang.Override
      public signrpc.SignerOuterClass.KeyDescriptor getDefaultInstanceForType() {
        return signrpc.SignerOuterClass.KeyDescriptor.getDefaultInstance();
      }

      @java.lang.Override
      public signrpc.SignerOuterClass.KeyDescriptor build() {
        signrpc.SignerOuterClass.KeyDescriptor result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public signrpc.SignerOuterClass.KeyDescriptor buildPartial() {
        signrpc.SignerOuterClass.KeyDescriptor result = new signrpc.SignerOuterClass.KeyDescriptor(this);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartial0(signrpc.SignerOuterClass.KeyDescriptor result) {
        int from_bitField0_ = bitField0_;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.rawKeyBytes_ = rawKeyBytes_;
        }
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000002) != 0)) {
          result.keyLoc_ = keyLocBuilder_ == null
              ? keyLoc_
              : keyLocBuilder_.build();
          to_bitField0_ |= 0x00000001;
        }
        result.bitField0_ |= to_bitField0_;
      }

      @java.lang.Override
      public Builder clone() {
        return super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof signrpc.SignerOuterClass.KeyDescriptor) {
          return mergeFrom((signrpc.SignerOuterClass.KeyDescriptor)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(signrpc.SignerOuterClass.KeyDescriptor other) {
        if (other == signrpc.SignerOuterClass.KeyDescriptor.getDefaultInstance()) return this;
        if (other.getRawKeyBytes() != com.google.protobuf.ByteString.EMPTY) {
          setRawKeyBytes(other.getRawKeyBytes());
        }
        if (other.hasKeyLoc()) {
          mergeKeyLoc(other.getKeyLoc());
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10: {
                rawKeyBytes_ = input.readBytes();
                bitField0_ |= 0x00000001;
                break;
              } // case 10
              case 18: {
                input.readMessage(
                    getKeyLocFieldBuilder().getBuilder(),
                    extensionRegistry);
                bitField0_ |= 0x00000002;
                break;
              } // case 18
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private com.google.protobuf.ByteString rawKeyBytes_ = com.google.protobuf.ByteString.EMPTY;
      /**
       * <pre>
       *
       *The raw bytes of the public key in the key pair being identified. Either
       *this or the KeyLocator must be specified.
       * </pre>
       *
       * <code>bytes raw_key_bytes = 1;</code>
       * @return The rawKeyBytes.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString getRawKeyBytes() {
        return rawKeyBytes_;
      }
      /**
       * <pre>
       *
       *The raw bytes of the public key in the key pair being identified. Either
       *this or the KeyLocator must be specified.
       * </pre>
       *
       * <code>bytes raw_key_bytes = 1;</code>
       * @param value The rawKeyBytes to set.
       * @return This builder for chaining.
       */
      public Builder setRawKeyBytes(com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        rawKeyBytes_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       *
       *The raw bytes of the public key in the key pair being identified. Either
       *this or the KeyLocator must be specified.
       * </pre>
       *
       * <code>bytes raw_key_bytes = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearRawKeyBytes() {
        bitField0_ = (bitField0_ & ~0x00000001);
        rawKeyBytes_ = getDefaultInstance().getRawKeyBytes();
        onChanged();
        return this;
      }

      private signrpc.SignerOuterClass.KeyLocator keyLoc_;
      private com.google.protobuf.SingleFieldBuilderV3<
          signrpc.SignerOuterClass.KeyLocator, signrpc.SignerOuterClass.KeyLocator.Builder, signrpc.SignerOuterClass.KeyLocatorOrBuilder> keyLocBuilder_;
      /**
       * <pre>
       *
       *The key locator that identifies which private key to use for signing.
       *Either this or the raw bytes of the target public key must be specified.
       * </pre>
       *
       * <code>.signrpc.KeyLocator key_loc = 2;</code>
       * @return Whether the keyLoc field is set.
       */
      public boolean hasKeyLoc() {
        return ((bitField0_ & 0x00000002) != 0);
      }
      /**
       * <pre>
       *
       *The key locator that identifies which private key to use for signing.
       *Either this or the raw bytes of the target public key must be specified.
       * </pre>
       *
       * <code>.signrpc.KeyLocator key_loc = 2;</code>
       * @return The keyLoc.
       */
      public signrpc.SignerOuterClass.KeyLocator getKeyLoc() {
        if (keyLocBuilder_ == null) {
          return keyLoc_ == null ? signrpc.SignerOuterClass.KeyLocator.getDefaultInstance() : keyLoc_;
        } else {
          return keyLocBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       *
       *The key locator that identifies which private key to use for signing.
       *Either this or the raw bytes of the target public key must be specified.
       * </pre>
       *
       * <code>.signrpc.KeyLocator key_loc = 2;</code>
       */
      public Builder setKeyLoc(signrpc.SignerOuterClass.KeyLocator value) {
        if (keyLocBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          keyLoc_ = value;
        } else {
          keyLocBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       *
       *The key locator that identifies which private key to use for signing.
       *Either this or the raw bytes of the target public key must be specified.
       * </pre>
       *
       * <code>.signrpc.KeyLocator key_loc = 2;</code>
       */
      public Builder setKeyLoc(
          signrpc.SignerOuterClass.KeyLocator.Builder builderForValue) {
        if (keyLocBuilder_ == null) {
          keyLoc_ = builderForValue.build();
        } else {
          keyLocBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       *
       *The key locator that identifies which private key to use for signing.
       *Either this or the raw bytes of the target public key must be specified.
       * </pre>
       *
       * <code>.signrpc.KeyLocator key_loc = 2;</code>
       */
      public Builder mergeKeyLoc(signrpc.SignerOuterClass.KeyLocator value) {
        if (keyLocBuilder_ == null) {
          if (((bitField0_ & 0x00000002) != 0) &&
            keyLoc_ != null &&
            keyLoc_ != signrpc.SignerOuterClass.KeyLocator.getDefaultInstance()) {
            getKeyLocBuilder().mergeFrom(value);
          } else {
            keyLoc_ = value;
          }
        } else {
          keyLocBuilder_.mergeFrom(value);
        }
        if (keyLoc_ != null) {
          bitField0_ |= 0x00000002;
          onChanged();
        }
        return this;
      }
      /**
       * <pre>
       *
       *The key locator that identifies which private key to use for signing.
       *Either this or the raw bytes of the target public key must be specified.
       * </pre>
       *
       * <code>.signrpc.KeyLocator key_loc = 2;</code>
       */
      public Builder clearKeyLoc() {
        bitField0_ = (bitField0_ & ~0x00000002);
        keyLoc_ = null;
        if (keyLocBuilder_ != null) {
          keyLocBuilder_.dispose();
          keyLocBuilder_ = null;
        }
        onChanged();
        return this;
      }
      /**
       * <pre>
       *
       *The key locator that identifies which private key to use for signing.
       *Either this or the raw bytes of the target public key must be specified.
       * </pre>
       *
       * <code>.signrpc.KeyLocator key_loc = 2;</code>
       */
      public signrpc.SignerOuterClass.KeyLocator.Builder getKeyLocBuilder() {
        bitField0_ |= 0x00000002;
        onChanged();
        return getKeyLocFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       *
       *The key locator that identifies which private key to use for signing.
       *Either this or the raw bytes of the target public key must be specified.
       * </pre>
       *
       * <code>.signrpc.KeyLocator key_loc = 2;</code>
       */
      public signrpc.SignerOuterClass.KeyLocatorOrBuilder getKeyLocOrBuilder() {
        if (keyLocBuilder_ != null) {
          return keyLocBuilder_.getMessageOrBuilder();
        } else {
          return keyLoc_ == null ?
              signrpc.SignerOuterClass.KeyLocator.getDefaultInstance() : keyLoc_;
        }
      }
      /**
       * <pre>
       *
       *The key locator that identifies which private key to use for signing.
       *Either this or the raw bytes of the target public key must be specified.
       * </pre>
       *
       * <code>.signrpc.KeyLocator key_loc = 2;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          signrpc.SignerOuterClass.KeyLocator, signrpc.SignerOuterClass.KeyLocator.Builder, signrpc.SignerOuterClass.KeyLocatorOrBuilder> 
          getKeyLocFieldBuilder() {
        if (keyLocBuilder_ == null) {
          keyLocBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              signrpc.SignerOuterClass.KeyLocator, signrpc.SignerOuterClass.KeyLocator.Builder, signrpc.SignerOuterClass.KeyLocatorOrBuilder>(
                  getKeyLoc(),
                  getParentForChildren(),
                  isClean());
          keyLoc_ = null;
        }
        return keyLocBuilder_;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:signrpc.KeyDescriptor)
    }

    // @@protoc_insertion_point(class_scope:signrpc.KeyDescriptor)
    private static final signrpc.SignerOuterClass.KeyDescriptor DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new signrpc.SignerOuterClass.KeyDescriptor();
    }

    public static signrpc.SignerOuterClass.KeyDescriptor getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<KeyDescriptor>
        PARSER = new com.google.protobuf.AbstractParser<KeyDescriptor>() {
      @java.lang.Override
      public KeyDescriptor parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<KeyDescriptor> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<KeyDescriptor> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public signrpc.SignerOuterClass.KeyDescriptor getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface TxOutOrBuilder extends
      // @@protoc_insertion_point(interface_extends:signrpc.TxOut)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * The value of the output being spent.
     * </pre>
     *
     * <code>int64 value = 1;</code>
     * @return The value.
     */
    long getValue();

    /**
     * <pre>
     * The script of the output being spent.
     * </pre>
     *
     * <code>bytes pk_script = 2;</code>
     * @return The pkScript.
     */
    com.google.protobuf.ByteString getPkScript();
  }
  /**
   * Protobuf type {@code signrpc.TxOut}
   */
  public static final class TxOut extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:signrpc.TxOut)
      TxOutOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use TxOut.newBuilder() to construct.
    private TxOut(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private TxOut() {
      pkScript_ = com.google.protobuf.ByteString.EMPTY;
    }

    @java.lang.Override
    @SuppressWarnings({"unused"})
    protected java.lang.Object newInstance(
        UnusedPrivateParameter unused) {
      return new TxOut();
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return signrpc.SignerOuterClass.internal_static_signrpc_TxOut_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return signrpc.SignerOuterClass.internal_static_signrpc_TxOut_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              signrpc.SignerOuterClass.TxOut.class, signrpc.SignerOuterClass.TxOut.Builder.class);
    }

    public static final int VALUE_FIELD_NUMBER = 1;
    private long value_ = 0L;
    /**
     * <pre>
     * The value of the output being spent.
     * </pre>
     *
     * <code>int64 value = 1;</code>
     * @return The value.
     */
    @java.lang.Override
    public long getValue() {
      return value_;
    }

    public static final int PK_SCRIPT_FIELD_NUMBER = 2;
    private com.google.protobuf.ByteString pkScript_ = com.google.protobuf.ByteString.EMPTY;
    /**
     * <pre>
     * The script of the output being spent.
     * </pre>
     *
     * <code>bytes pk_script = 2;</code>
     * @return The pkScript.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString getPkScript() {
      return pkScript_;
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (value_ != 0L) {
        output.writeInt64(1, value_);
      }
      if (!pkScript_.isEmpty()) {
        output.writeBytes(2, pkScript_);
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (value_ != 0L) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt64Size(1, value_);
      }
      if (!pkScript_.isEmpty()) {
        size += com.google.protobuf.CodedOutputStream
          .computeBytesSize(2, pkScript_);
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof signrpc.SignerOuterClass.TxOut)) {
        return super.equals(obj);
      }
      signrpc.SignerOuterClass.TxOut other = (signrpc.SignerOuterClass.TxOut) obj;

      if (getValue()
          != other.getValue()) return false;
      if (!getPkScript()
          .equals(other.getPkScript())) return false;
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      hash = (37 * hash) + VALUE_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
          getValue());
      hash = (37 * hash) + PK_SCRIPT_FIELD_NUMBER;
      hash = (53 * hash) + getPkScript().hashCode();
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static signrpc.SignerOuterClass.TxOut parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static signrpc.SignerOuterClass.TxOut parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static signrpc.SignerOuterClass.TxOut parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static signrpc.SignerOuterClass.TxOut parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static signrpc.SignerOuterClass.TxOut parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static signrpc.SignerOuterClass.TxOut parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static signrpc.SignerOuterClass.TxOut parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static signrpc.SignerOuterClass.TxOut parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static signrpc.SignerOuterClass.TxOut parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static signrpc.SignerOuterClass.TxOut parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static signrpc.SignerOuterClass.TxOut parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static signrpc.SignerOuterClass.TxOut parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(signrpc.SignerOuterClass.TxOut prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * Protobuf type {@code signrpc.TxOut}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:signrpc.TxOut)
        signrpc.SignerOuterClass.TxOutOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return signrpc.SignerOuterClass.internal_static_signrpc_TxOut_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return signrpc.SignerOuterClass.internal_static_signrpc_TxOut_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                signrpc.SignerOuterClass.TxOut.class, signrpc.SignerOuterClass.TxOut.Builder.class);
      }

      // Construct using signrpc.SignerOuterClass.TxOut.newBuilder()
      private Builder() {

      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);

      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        value_ = 0L;
        pkScript_ = com.google.protobuf.ByteString.EMPTY;
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return signrpc.SignerOuterClass.internal_static_signrpc_TxOut_descriptor;
      }

      @java.lang.Override
      public signrpc.SignerOuterClass.TxOut getDefaultInstanceForType() {
        return signrpc.SignerOuterClass.TxOut.getDefaultInstance();
      }

      @java.lang.Override
      public signrpc.SignerOuterClass.TxOut build() {
        signrpc.SignerOuterClass.TxOut result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public signrpc.SignerOuterClass.TxOut buildPartial() {
        signrpc.SignerOuterClass.TxOut result = new signrpc.SignerOuterClass.TxOut(this);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartial0(signrpc.SignerOuterClass.TxOut result) {
        int from_bitField0_ = bitField0_;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.value_ = value_;
        }
        if (((from_bitField0_ & 0x00000002) != 0)) {
          result.pkScript_ = pkScript_;
        }
      }

      @java.lang.Override
      public Builder clone() {
        return super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof signrpc.SignerOuterClass.TxOut) {
          return mergeFrom((signrpc.SignerOuterClass.TxOut)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(signrpc.SignerOuterClass.TxOut other) {
        if (other == signrpc.SignerOuterClass.TxOut.getDefaultInstance()) return this;
        if (other.getValue() != 0L) {
          setValue(other.getValue());
        }
        if (other.getPkScript() != com.google.protobuf.ByteString.EMPTY) {
          setPkScript(other.getPkScript());
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 8: {
                value_ = input.readInt64();
                bitField0_ |= 0x00000001;
                break;
              } // case 8
              case 18: {
                pkScript_ = input.readBytes();
                bitField0_ |= 0x00000002;
                break;
              } // case 18
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private long value_ ;
      /**
       * <pre>
       * The value of the output being spent.
       * </pre>
       *
       * <code>int64 value = 1;</code>
       * @return The value.
       */
      @java.lang.Override
      public long getValue() {
        return value_;
      }
      /**
       * <pre>
       * The value of the output being spent.
       * </pre>
       *
       * <code>int64 value = 1;</code>
       * @param value The value to set.
       * @return This builder for chaining.
       */
      public Builder setValue(long value) {

        value_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The value of the output being spent.
       * </pre>
       *
       * <code>int64 value = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearValue() {
        bitField0_ = (bitField0_ & ~0x00000001);
        value_ = 0L;
        onChanged();
        return this;
      }

      private com.google.protobuf.ByteString pkScript_ = com.google.protobuf.ByteString.EMPTY;
      /**
       * <pre>
       * The script of the output being spent.
       * </pre>
       *
       * <code>bytes pk_script = 2;</code>
       * @return The pkScript.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString getPkScript() {
        return pkScript_;
      }
      /**
       * <pre>
       * The script of the output being spent.
       * </pre>
       *
       * <code>bytes pk_script = 2;</code>
       * @param value The pkScript to set.
       * @return This builder for chaining.
       */
      public Builder setPkScript(com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        pkScript_ = value;
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The script of the output being spent.
       * </pre>
       *
       * <code>bytes pk_script = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearPkScript() {
        bitField0_ = (bitField0_ & ~0x00000002);
        pkScript_ = getDefaultInstance().getPkScript();
        onChanged();
        return this;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:signrpc.TxOut)
    }

    // @@protoc_insertion_point(class_scope:signrpc.TxOut)
    private static final signrpc.SignerOuterClass.TxOut DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new signrpc.SignerOuterClass.TxOut();
    }

    public static signrpc.SignerOuterClass.TxOut getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<TxOut>
        PARSER = new com.google.protobuf.AbstractParser<TxOut>() {
      @java.lang.Override
      public TxOut parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<TxOut> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<TxOut> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public signrpc.SignerOuterClass.TxOut getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface SignDescriptorOrBuilder extends
      // @@protoc_insertion_point(interface_extends:signrpc.SignDescriptor)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     *
     *A descriptor that precisely describes *which* key to use for signing. This
     *may provide the raw public key directly, or require the Signer to re-derive
     *the key according to the populated derivation path.
     *
     *Note that if the key descriptor was obtained through walletrpc.DeriveKey,
     *then the key locator MUST always be provided, since the derived keys are not
     *persisted unlike with DeriveNextKey.
     * </pre>
     *
     * <code>.signrpc.KeyDescriptor key_desc = 1;</code>
     * @return Whether the keyDesc field is set.
     */
    boolean hasKeyDesc();
    /**
     * <pre>
     *
     *A descriptor that precisely describes *which* key to use for signing. This
     *may provide the raw public key directly, or require the Signer to re-derive
     *the key according to the populated derivation path.
     *
     *Note that if the key descriptor was obtained through walletrpc.DeriveKey,
     *then the key locator MUST always be provided, since the derived keys are not
     *persisted unlike with DeriveNextKey.
     * </pre>
     *
     * <code>.signrpc.KeyDescriptor key_desc = 1;</code>
     * @return The keyDesc.
     */
    signrpc.SignerOuterClass.KeyDescriptor getKeyDesc();
    /**
     * <pre>
     *
     *A descriptor that precisely describes *which* key to use for signing. This
     *may provide the raw public key directly, or require the Signer to re-derive
     *the key according to the populated derivation path.
     *
     *Note that if the key descriptor was obtained through walletrpc.DeriveKey,
     *then the key locator MUST always be provided, since the derived keys are not
     *persisted unlike with DeriveNextKey.
     * </pre>
     *
     * <code>.signrpc.KeyDescriptor key_desc = 1;</code>
     */
    signrpc.SignerOuterClass.KeyDescriptorOrBuilder getKeyDescOrBuilder();

    /**
     * <pre>
     *
     *A scalar value that will be added to the private key corresponding to the
     *above public key to obtain the private key to be used to sign this input.
     *This value is typically derived via the following computation:
     *
     * derivedKey = privkey + sha256(perCommitmentPoint || pubKey) mod N
     * </pre>
     *
     * <code>bytes single_tweak = 2;</code>
     * @return The singleTweak.
     */
    com.google.protobuf.ByteString getSingleTweak();

    /**
     * <pre>
     *
     *A private key that will be used in combination with its corresponding
     *private key to derive the private key that is to be used to sign the target
     *input. Within the Lightning protocol, this value is typically the
     *commitment secret from a previously revoked commitment transaction. This
     *value is in combination with two hash values, and the original private key
     *to derive the private key to be used when signing.
     *
     * k = (privKey*sha256(pubKey || tweakPub) +
     *tweakPriv*sha256(tweakPub || pubKey)) mod N
     * </pre>
     *
     * <code>bytes double_tweak = 3;</code>
     * @return The doubleTweak.
     */
    com.google.protobuf.ByteString getDoubleTweak();

    /**
     * <pre>
     *
     *The 32 byte input to the taproot tweak derivation that is used to derive
     *the output key from an internal key: outputKey = internalKey +
     *tagged_hash("tapTweak", internalKey || tapTweak).
     *
     *When doing a BIP 86 spend, this field can be an empty byte slice.
     *
     *When doing a normal key path spend, with the output key committing to an
     *actual script root, then this field should be: the tapscript root hash.
     * </pre>
     *
     * <code>bytes tap_tweak = 10;</code>
     * @return The tapTweak.
     */
    com.google.protobuf.ByteString getTapTweak();

    /**
     * <pre>
     *
     *The full script required to properly redeem the output. This field will
     *only be populated if a p2tr, p2wsh or a p2sh output is being signed. If a
     *taproot script path spend is being attempted, then this should be the raw
     *leaf script.
     * </pre>
     *
     * <code>bytes witness_script = 4;</code>
     * @return The witnessScript.
     */
    com.google.protobuf.ByteString getWitnessScript();

    /**
     * <pre>
     *
     *A description of the output being spent. The value and script MUST be
     *provided.
     * </pre>
     *
     * <code>.signrpc.TxOut output = 5;</code>
     * @return Whether the output field is set.
     */
    boolean hasOutput();
    /**
     * <pre>
     *
     *A description of the output being spent. The value and script MUST be
     *provided.
     * </pre>
     *
     * <code>.signrpc.TxOut output = 5;</code>
     * @return The output.
     */
    signrpc.SignerOuterClass.TxOut getOutput();
    /**
     * <pre>
     *
     *A description of the output being spent. The value and script MUST be
     *provided.
     * </pre>
     *
     * <code>.signrpc.TxOut output = 5;</code>
     */
    signrpc.SignerOuterClass.TxOutOrBuilder getOutputOrBuilder();

    /**
     * <pre>
     *
     *The target sighash type that should be used when generating the final
     *sighash, and signature.
     * </pre>
     *
     * <code>uint32 sighash = 7;</code>
     * @return The sighash.
     */
    int getSighash();

    /**
     * <pre>
     *
     *The target input within the transaction that should be signed.
     * </pre>
     *
     * <code>int32 input_index = 8;</code>
     * @return The inputIndex.
     */
    int getInputIndex();

    /**
     * <pre>
     *
     *The sign method specifies how the input should be signed. Depending on the
     *method, either the tap_tweak, witness_script or both need to be specified.
     *Defaults to SegWit v0 signing to be backward compatible with older RPC
     *clients.
     * </pre>
     *
     * <code>.signrpc.SignMethod sign_method = 9;</code>
     * @return The enum numeric value on the wire for signMethod.
     */
    int getSignMethodValue();
    /**
     * <pre>
     *
     *The sign method specifies how the input should be signed. Depending on the
     *method, either the tap_tweak, witness_script or both need to be specified.
     *Defaults to SegWit v0 signing to be backward compatible with older RPC
     *clients.
     * </pre>
     *
     * <code>.signrpc.SignMethod sign_method = 9;</code>
     * @return The signMethod.
     */
    signrpc.SignerOuterClass.SignMethod getSignMethod();
  }
  /**
   * Protobuf type {@code signrpc.SignDescriptor}
   */
  public static final class SignDescriptor extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:signrpc.SignDescriptor)
      SignDescriptorOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use SignDescriptor.newBuilder() to construct.
    private SignDescriptor(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private SignDescriptor() {
      singleTweak_ = com.google.protobuf.ByteString.EMPTY;
      doubleTweak_ = com.google.protobuf.ByteString.EMPTY;
      tapTweak_ = com.google.protobuf.ByteString.EMPTY;
      witnessScript_ = com.google.protobuf.ByteString.EMPTY;
      signMethod_ = 0;
    }

    @java.lang.Override
    @SuppressWarnings({"unused"})
    protected java.lang.Object newInstance(
        UnusedPrivateParameter unused) {
      return new SignDescriptor();
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return signrpc.SignerOuterClass.internal_static_signrpc_SignDescriptor_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return signrpc.SignerOuterClass.internal_static_signrpc_SignDescriptor_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              signrpc.SignerOuterClass.SignDescriptor.class, signrpc.SignerOuterClass.SignDescriptor.Builder.class);
    }

    private int bitField0_;
    public static final int KEY_DESC_FIELD_NUMBER = 1;
    private signrpc.SignerOuterClass.KeyDescriptor keyDesc_;
    /**
     * <pre>
     *
     *A descriptor that precisely describes *which* key to use for signing. This
     *may provide the raw public key directly, or require the Signer to re-derive
     *the key according to the populated derivation path.
     *
     *Note that if the key descriptor was obtained through walletrpc.DeriveKey,
     *then the key locator MUST always be provided, since the derived keys are not
     *persisted unlike with DeriveNextKey.
     * </pre>
     *
     * <code>.signrpc.KeyDescriptor key_desc = 1;</code>
     * @return Whether the keyDesc field is set.
     */
    @java.lang.Override
    public boolean hasKeyDesc() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     *
     *A descriptor that precisely describes *which* key to use for signing. This
     *may provide the raw public key directly, or require the Signer to re-derive
     *the key according to the populated derivation path.
     *
     *Note that if the key descriptor was obtained through walletrpc.DeriveKey,
     *then the key locator MUST always be provided, since the derived keys are not
     *persisted unlike with DeriveNextKey.
     * </pre>
     *
     * <code>.signrpc.KeyDescriptor key_desc = 1;</code>
     * @return The keyDesc.
     */
    @java.lang.Override
    public signrpc.SignerOuterClass.KeyDescriptor getKeyDesc() {
      return keyDesc_ == null ? signrpc.SignerOuterClass.KeyDescriptor.getDefaultInstance() : keyDesc_;
    }
    /**
     * <pre>
     *
     *A descriptor that precisely describes *which* key to use for signing. This
     *may provide the raw public key directly, or require the Signer to re-derive
     *the key according to the populated derivation path.
     *
     *Note that if the key descriptor was obtained through walletrpc.DeriveKey,
     *then the key locator MUST always be provided, since the derived keys are not
     *persisted unlike with DeriveNextKey.
     * </pre>
     *
     * <code>.signrpc.KeyDescriptor key_desc = 1;</code>
     */
    @java.lang.Override
    public signrpc.SignerOuterClass.KeyDescriptorOrBuilder getKeyDescOrBuilder() {
      return keyDesc_ == null ? signrpc.SignerOuterClass.KeyDescriptor.getDefaultInstance() : keyDesc_;
    }

    public static final int SINGLE_TWEAK_FIELD_NUMBER = 2;
    private com.google.protobuf.ByteString singleTweak_ = com.google.protobuf.ByteString.EMPTY;
    /**
     * <pre>
     *
     *A scalar value that will be added to the private key corresponding to the
     *above public key to obtain the private key to be used to sign this input.
     *This value is typically derived via the following computation:
     *
     * derivedKey = privkey + sha256(perCommitmentPoint || pubKey) mod N
     * </pre>
     *
     * <code>bytes single_tweak = 2;</code>
     * @return The singleTweak.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString getSingleTweak() {
      return singleTweak_;
    }

    public static final int DOUBLE_TWEAK_FIELD_NUMBER = 3;
    private com.google.protobuf.ByteString doubleTweak_ = com.google.protobuf.ByteString.EMPTY;
    /**
     * <pre>
     *
     *A private key that will be used in combination with its corresponding
     *private key to derive the private key that is to be used to sign the target
     *input. Within the Lightning protocol, this value is typically the
     *commitment secret from a previously revoked commitment transaction. This
     *value is in combination with two hash values, and the original private key
     *to derive the private key to be used when signing.
     *
     * k = (privKey*sha256(pubKey || tweakPub) +
     *tweakPriv*sha256(tweakPub || pubKey)) mod N
     * </pre>
     *
     * <code>bytes double_tweak = 3;</code>
     * @return The doubleTweak.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString getDoubleTweak() {
      return doubleTweak_;
    }

    public static final int TAP_TWEAK_FIELD_NUMBER = 10;
    private com.google.protobuf.ByteString tapTweak_ = com.google.protobuf.ByteString.EMPTY;
    /**
     * <pre>
     *
     *The 32 byte input to the taproot tweak derivation that is used to derive
     *the output key from an internal key: outputKey = internalKey +
     *tagged_hash("tapTweak", internalKey || tapTweak).
     *
     *When doing a BIP 86 spend, this field can be an empty byte slice.
     *
     *When doing a normal key path spend, with the output key committing to an
     *actual script root, then this field should be: the tapscript root hash.
     * </pre>
     *
     * <code>bytes tap_tweak = 10;</code>
     * @return The tapTweak.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString getTapTweak() {
      return tapTweak_;
    }

    public static final int WITNESS_SCRIPT_FIELD_NUMBER = 4;
    private com.google.protobuf.ByteString witnessScript_ = com.google.protobuf.ByteString.EMPTY;
    /**
     * <pre>
     *
     *The full script required to properly redeem the output. This field will
     *only be populated if a p2tr, p2wsh or a p2sh output is being signed. If a
     *taproot script path spend is being attempted, then this should be the raw
     *leaf script.
     * </pre>
     *
     * <code>bytes witness_script = 4;</code>
     * @return The witnessScript.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString getWitnessScript() {
      return witnessScript_;
    }

    public static final int OUTPUT_FIELD_NUMBER = 5;
    private signrpc.SignerOuterClass.TxOut output_;
    /**
     * <pre>
     *
     *A description of the output being spent. The value and script MUST be
     *provided.
     * </pre>
     *
     * <code>.signrpc.TxOut output = 5;</code>
     * @return Whether the output field is set.
     */
    @java.lang.Override
    public boolean hasOutput() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <pre>
     *
     *A description of the output being spent. The value and script MUST be
     *provided.
     * </pre>
     *
     * <code>.signrpc.TxOut output = 5;</code>
     * @return The output.
     */
    @java.lang.Override
    public signrpc.SignerOuterClass.TxOut getOutput() {
      return output_ == null ? signrpc.SignerOuterClass.TxOut.getDefaultInstance() : output_;
    }
    /**
     * <pre>
     *
     *A description of the output being spent. The value and script MUST be
     *provided.
     * </pre>
     *
     * <code>.signrpc.TxOut output = 5;</code>
     */
    @java.lang.Override
    public signrpc.SignerOuterClass.TxOutOrBuilder getOutputOrBuilder() {
      return output_ == null ? signrpc.SignerOuterClass.TxOut.getDefaultInstance() : output_;
    }

    public static final int SIGHASH_FIELD_NUMBER = 7;
    private int sighash_ = 0;
    /**
     * <pre>
     *
     *The target sighash type that should be used when generating the final
     *sighash, and signature.
     * </pre>
     *
     * <code>uint32 sighash = 7;</code>
     * @return The sighash.
     */
    @java.lang.Override
    public int getSighash() {
      return sighash_;
    }

    public static final int INPUT_INDEX_FIELD_NUMBER = 8;
    private int inputIndex_ = 0;
    /**
     * <pre>
     *
     *The target input within the transaction that should be signed.
     * </pre>
     *
     * <code>int32 input_index = 8;</code>
     * @return The inputIndex.
     */
    @java.lang.Override
    public int getInputIndex() {
      return inputIndex_;
    }

    public static final int SIGN_METHOD_FIELD_NUMBER = 9;
    private int signMethod_ = 0;
    /**
     * <pre>
     *
     *The sign method specifies how the input should be signed. Depending on the
     *method, either the tap_tweak, witness_script or both need to be specified.
     *Defaults to SegWit v0 signing to be backward compatible with older RPC
     *clients.
     * </pre>
     *
     * <code>.signrpc.SignMethod sign_method = 9;</code>
     * @return The enum numeric value on the wire for signMethod.
     */
    @java.lang.Override public int getSignMethodValue() {
      return signMethod_;
    }
    /**
     * <pre>
     *
     *The sign method specifies how the input should be signed. Depending on the
     *method, either the tap_tweak, witness_script or both need to be specified.
     *Defaults to SegWit v0 signing to be backward compatible with older RPC
     *clients.
     * </pre>
     *
     * <code>.signrpc.SignMethod sign_method = 9;</code>
     * @return The signMethod.
     */
    @java.lang.Override public signrpc.SignerOuterClass.SignMethod getSignMethod() {
      signrpc.SignerOuterClass.SignMethod result = signrpc.SignerOuterClass.SignMethod.forNumber(signMethod_);
      return result == null ? signrpc.SignerOuterClass.SignMethod.UNRECOGNIZED : result;
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) != 0)) {
        output.writeMessage(1, getKeyDesc());
      }
      if (!singleTweak_.isEmpty()) {
        output.writeBytes(2, singleTweak_);
      }
      if (!doubleTweak_.isEmpty()) {
        output.writeBytes(3, doubleTweak_);
      }
      if (!witnessScript_.isEmpty()) {
        output.writeBytes(4, witnessScript_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        output.writeMessage(5, getOutput());
      }
      if (sighash_ != 0) {
        output.writeUInt32(7, sighash_);
      }
      if (inputIndex_ != 0) {
        output.writeInt32(8, inputIndex_);
      }
      if (signMethod_ != signrpc.SignerOuterClass.SignMethod.SIGN_METHOD_WITNESS_V0.getNumber()) {
        output.writeEnum(9, signMethod_);
      }
      if (!tapTweak_.isEmpty()) {
        output.writeBytes(10, tapTweak_);
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(1, getKeyDesc());
      }
      if (!singleTweak_.isEmpty()) {
        size += com.google.protobuf.CodedOutputStream
          .computeBytesSize(2, singleTweak_);
      }
      if (!doubleTweak_.isEmpty()) {
        size += com.google.protobuf.CodedOutputStream
          .computeBytesSize(3, doubleTweak_);
      }
      if (!witnessScript_.isEmpty()) {
        size += com.google.protobuf.CodedOutputStream
          .computeBytesSize(4, witnessScript_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(5, getOutput());
      }
      if (sighash_ != 0) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt32Size(7, sighash_);
      }
      if (inputIndex_ != 0) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt32Size(8, inputIndex_);
      }
      if (signMethod_ != signrpc.SignerOuterClass.SignMethod.SIGN_METHOD_WITNESS_V0.getNumber()) {
        size += com.google.protobuf.CodedOutputStream
          .computeEnumSize(9, signMethod_);
      }
      if (!tapTweak_.isEmpty()) {
        size += com.google.protobuf.CodedOutputStream
          .computeBytesSize(10, tapTweak_);
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof signrpc.SignerOuterClass.SignDescriptor)) {
        return super.equals(obj);
      }
      signrpc.SignerOuterClass.SignDescriptor other = (signrpc.SignerOuterClass.SignDescriptor) obj;

      if (hasKeyDesc() != other.hasKeyDesc()) return false;
      if (hasKeyDesc()) {
        if (!getKeyDesc()
            .equals(other.getKeyDesc())) return false;
      }
      if (!getSingleTweak()
          .equals(other.getSingleTweak())) return false;
      if (!getDoubleTweak()
          .equals(other.getDoubleTweak())) return false;
      if (!getTapTweak()
          .equals(other.getTapTweak())) return false;
      if (!getWitnessScript()
          .equals(other.getWitnessScript())) return false;
      if (hasOutput() != other.hasOutput()) return false;
      if (hasOutput()) {
        if (!getOutput()
            .equals(other.getOutput())) return false;
      }
      if (getSighash()
          != other.getSighash()) return false;
      if (getInputIndex()
          != other.getInputIndex()) return false;
      if (signMethod_ != other.signMethod_) return false;
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasKeyDesc()) {
        hash = (37 * hash) + KEY_DESC_FIELD_NUMBER;
        hash = (53 * hash) + getKeyDesc().hashCode();
      }
      hash = (37 * hash) + SINGLE_TWEAK_FIELD_NUMBER;
      hash = (53 * hash) + getSingleTweak().hashCode();
      hash = (37 * hash) + DOUBLE_TWEAK_FIELD_NUMBER;
      hash = (53 * hash) + getDoubleTweak().hashCode();
      hash = (37 * hash) + TAP_TWEAK_FIELD_NUMBER;
      hash = (53 * hash) + getTapTweak().hashCode();
      hash = (37 * hash) + WITNESS_SCRIPT_FIELD_NUMBER;
      hash = (53 * hash) + getWitnessScript().hashCode();
      if (hasOutput()) {
        hash = (37 * hash) + OUTPUT_FIELD_NUMBER;
        hash = (53 * hash) + getOutput().hashCode();
      }
      hash = (37 * hash) + SIGHASH_FIELD_NUMBER;
      hash = (53 * hash) + getSighash();
      hash = (37 * hash) + INPUT_INDEX_FIELD_NUMBER;
      hash = (53 * hash) + getInputIndex();
      hash = (37 * hash) + SIGN_METHOD_FIELD_NUMBER;
      hash = (53 * hash) + signMethod_;
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static signrpc.SignerOuterClass.SignDescriptor parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static signrpc.SignerOuterClass.SignDescriptor parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static signrpc.SignerOuterClass.SignDescriptor parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static signrpc.SignerOuterClass.SignDescriptor parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static signrpc.SignerOuterClass.SignDescriptor parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static signrpc.SignerOuterClass.SignDescriptor parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static signrpc.SignerOuterClass.SignDescriptor parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static signrpc.SignerOuterClass.SignDescriptor parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static signrpc.SignerOuterClass.SignDescriptor parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static signrpc.SignerOuterClass.SignDescriptor parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static signrpc.SignerOuterClass.SignDescriptor parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static signrpc.SignerOuterClass.SignDescriptor parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(signrpc.SignerOuterClass.SignDescriptor prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * Protobuf type {@code signrpc.SignDescriptor}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:signrpc.SignDescriptor)
        signrpc.SignerOuterClass.SignDescriptorOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return signrpc.SignerOuterClass.internal_static_signrpc_SignDescriptor_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return signrpc.SignerOuterClass.internal_static_signrpc_SignDescriptor_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                signrpc.SignerOuterClass.SignDescriptor.class, signrpc.SignerOuterClass.SignDescriptor.Builder.class);
      }

      // Construct using signrpc.SignerOuterClass.SignDescriptor.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
          getKeyDescFieldBuilder();
          getOutputFieldBuilder();
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        keyDesc_ = null;
        if (keyDescBuilder_ != null) {
          keyDescBuilder_.dispose();
          keyDescBuilder_ = null;
        }
        singleTweak_ = com.google.protobuf.ByteString.EMPTY;
        doubleTweak_ = com.google.protobuf.ByteString.EMPTY;
        tapTweak_ = com.google.protobuf.ByteString.EMPTY;
        witnessScript_ = com.google.protobuf.ByteString.EMPTY;
        output_ = null;
        if (outputBuilder_ != null) {
          outputBuilder_.dispose();
          outputBuilder_ = null;
        }
        sighash_ = 0;
        inputIndex_ = 0;
        signMethod_ = 0;
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return signrpc.SignerOuterClass.internal_static_signrpc_SignDescriptor_descriptor;
      }

      @java.lang.Override
      public signrpc.SignerOuterClass.SignDescriptor getDefaultInstanceForType() {
        return signrpc.SignerOuterClass.SignDescriptor.getDefaultInstance();
      }

      @java.lang.Override
      public signrpc.SignerOuterClass.SignDescriptor build() {
        signrpc.SignerOuterClass.SignDescriptor result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public signrpc.SignerOuterClass.SignDescriptor buildPartial() {
        signrpc.SignerOuterClass.SignDescriptor result = new signrpc.SignerOuterClass.SignDescriptor(this);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartial0(signrpc.SignerOuterClass.SignDescriptor result) {
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.keyDesc_ = keyDescBuilder_ == null
              ? keyDesc_
              : keyDescBuilder_.build();
          to_bitField0_ |= 0x00000001;
        }
        if (((from_bitField0_ & 0x00000002) != 0)) {
          result.singleTweak_ = singleTweak_;
        }
        if (((from_bitField0_ & 0x00000004) != 0)) {
          result.doubleTweak_ = doubleTweak_;
        }
        if (((from_bitField0_ & 0x00000008) != 0)) {
          result.tapTweak_ = tapTweak_;
        }
        if (((from_bitField0_ & 0x00000010) != 0)) {
          result.witnessScript_ = witnessScript_;
        }
        if (((from_bitField0_ & 0x00000020) != 0)) {
          result.output_ = outputBuilder_ == null
              ? output_
              : outputBuilder_.build();
          to_bitField0_ |= 0x00000002;
        }
        if (((from_bitField0_ & 0x00000040) != 0)) {
          result.sighash_ = sighash_;
        }
        if (((from_bitField0_ & 0x00000080) != 0)) {
          result.inputIndex_ = inputIndex_;
        }
        if (((from_bitField0_ & 0x00000100) != 0)) {
          result.signMethod_ = signMethod_;
        }
        result.bitField0_ |= to_bitField0_;
      }

      @java.lang.Override
      public Builder clone() {
        return super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof signrpc.SignerOuterClass.SignDescriptor) {
          return mergeFrom((signrpc.SignerOuterClass.SignDescriptor)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(signrpc.SignerOuterClass.SignDescriptor other) {
        if (other == signrpc.SignerOuterClass.SignDescriptor.getDefaultInstance()) return this;
        if (other.hasKeyDesc()) {
          mergeKeyDesc(other.getKeyDesc());
        }
        if (other.getSingleTweak() != com.google.protobuf.ByteString.EMPTY) {
          setSingleTweak(other.getSingleTweak());
        }
        if (other.getDoubleTweak() != com.google.protobuf.ByteString.EMPTY) {
          setDoubleTweak(other.getDoubleTweak());
        }
        if (other.getTapTweak() != com.google.protobuf.ByteString.EMPTY) {
          setTapTweak(other.getTapTweak());
        }
        if (other.getWitnessScript() != com.google.protobuf.ByteString.EMPTY) {
          setWitnessScript(other.getWitnessScript());
        }
        if (other.hasOutput()) {
          mergeOutput(other.getOutput());
        }
        if (other.getSighash() != 0) {
          setSighash(other.getSighash());
        }
        if (other.getInputIndex() != 0) {
          setInputIndex(other.getInputIndex());
        }
        if (other.signMethod_ != 0) {
          setSignMethodValue(other.getSignMethodValue());
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10: {
                input.readMessage(
                    getKeyDescFieldBuilder().getBuilder(),
                    extensionRegistry);
                bitField0_ |= 0x00000001;
                break;
              } // case 10
              case 18: {
                singleTweak_ = input.readBytes();
                bitField0_ |= 0x00000002;
                break;
              } // case 18
              case 26: {
                doubleTweak_ = input.readBytes();
                bitField0_ |= 0x00000004;
                break;
              } // case 26
              case 34: {
                witnessScript_ = input.readBytes();
                bitField0_ |= 0x00000010;
                break;
              } // case 34
              case 42: {
                input.readMessage(
                    getOutputFieldBuilder().getBuilder(),
                    extensionRegistry);
                bitField0_ |= 0x00000020;
                break;
              } // case 42
              case 56: {
                sighash_ = input.readUInt32();
                bitField0_ |= 0x00000040;
                break;
              } // case 56
              case 64: {
                inputIndex_ = input.readInt32();
                bitField0_ |= 0x00000080;
                break;
              } // case 64
              case 72: {
                signMethod_ = input.readEnum();
                bitField0_ |= 0x00000100;
                break;
              } // case 72
              case 82: {
                tapTweak_ = input.readBytes();
                bitField0_ |= 0x00000008;
                break;
              } // case 82
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private signrpc.SignerOuterClass.KeyDescriptor keyDesc_;
      private com.google.protobuf.SingleFieldBuilderV3<
          signrpc.SignerOuterClass.KeyDescriptor, signrpc.SignerOuterClass.KeyDescriptor.Builder, signrpc.SignerOuterClass.KeyDescriptorOrBuilder> keyDescBuilder_;
      /**
       * <pre>
       *
       *A descriptor that precisely describes *which* key to use for signing. This
       *may provide the raw public key directly, or require the Signer to re-derive
       *the key according to the populated derivation path.
       *
       *Note that if the key descriptor was obtained through walletrpc.DeriveKey,
       *then the key locator MUST always be provided, since the derived keys are not
       *persisted unlike with DeriveNextKey.
       * </pre>
       *
       * <code>.signrpc.KeyDescriptor key_desc = 1;</code>
       * @return Whether the keyDesc field is set.
       */
      public boolean hasKeyDesc() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <pre>
       *
       *A descriptor that precisely describes *which* key to use for signing. This
       *may provide the raw public key directly, or require the Signer to re-derive
       *the key according to the populated derivation path.
       *
       *Note that if the key descriptor was obtained through walletrpc.DeriveKey,
       *then the key locator MUST always be provided, since the derived keys are not
       *persisted unlike with DeriveNextKey.
       * </pre>
       *
       * <code>.signrpc.KeyDescriptor key_desc = 1;</code>
       * @return The keyDesc.
       */
      public signrpc.SignerOuterClass.KeyDescriptor getKeyDesc() {
        if (keyDescBuilder_ == null) {
          return keyDesc_ == null ? signrpc.SignerOuterClass.KeyDescriptor.getDefaultInstance() : keyDesc_;
        } else {
          return keyDescBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       *
       *A descriptor that precisely describes *which* key to use for signing. This
       *may provide the raw public key directly, or require the Signer to re-derive
       *the key according to the populated derivation path.
       *
       *Note that if the key descriptor was obtained through walletrpc.DeriveKey,
       *then the key locator MUST always be provided, since the derived keys are not
       *persisted unlike with DeriveNextKey.
       * </pre>
       *
       * <code>.signrpc.KeyDescriptor key_desc = 1;</code>
       */
      public Builder setKeyDesc(signrpc.SignerOuterClass.KeyDescriptor value) {
        if (keyDescBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          keyDesc_ = value;
        } else {
          keyDescBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       *
       *A descriptor that precisely describes *which* key to use for signing. This
       *may provide the raw public key directly, or require the Signer to re-derive
       *the key according to the populated derivation path.
       *
       *Note that if the key descriptor was obtained through walletrpc.DeriveKey,
       *then the key locator MUST always be provided, since the derived keys are not
       *persisted unlike with DeriveNextKey.
       * </pre>
       *
       * <code>.signrpc.KeyDescriptor key_desc = 1;</code>
       */
      public Builder setKeyDesc(
          signrpc.SignerOuterClass.KeyDescriptor.Builder builderForValue) {
        if (keyDescBuilder_ == null) {
          keyDesc_ = builderForValue.build();
        } else {
          keyDescBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       *
       *A descriptor that precisely describes *which* key to use for signing. This
       *may provide the raw public key directly, or require the Signer to re-derive
       *the key according to the populated derivation path.
       *
       *Note that if the key descriptor was obtained through walletrpc.DeriveKey,
       *then the key locator MUST always be provided, since the derived keys are not
       *persisted unlike with DeriveNextKey.
       * </pre>
       *
       * <code>.signrpc.KeyDescriptor key_desc = 1;</code>
       */
      public Builder mergeKeyDesc(signrpc.SignerOuterClass.KeyDescriptor value) {
        if (keyDescBuilder_ == null) {
          if (((bitField0_ & 0x00000001) != 0) &&
            keyDesc_ != null &&
            keyDesc_ != signrpc.SignerOuterClass.KeyDescriptor.getDefaultInstance()) {
            getKeyDescBuilder().mergeFrom(value);
          } else {
            keyDesc_ = value;
          }
        } else {
          keyDescBuilder_.mergeFrom(value);
        }
        if (keyDesc_ != null) {
          bitField0_ |= 0x00000001;
          onChanged();
        }
        return this;
      }
      /**
       * <pre>
       *
       *A descriptor that precisely describes *which* key to use for signing. This
       *may provide the raw public key directly, or require the Signer to re-derive
       *the key according to the populated derivation path.
       *
       *Note that if the key descriptor was obtained through walletrpc.DeriveKey,
       *then the key locator MUST always be provided, since the derived keys are not
       *persisted unlike with DeriveNextKey.
       * </pre>
       *
       * <code>.signrpc.KeyDescriptor key_desc = 1;</code>
       */
      public Builder clearKeyDesc() {
        bitField0_ = (bitField0_ & ~0x00000001);
        keyDesc_ = null;
        if (keyDescBuilder_ != null) {
          keyDescBuilder_.dispose();
          keyDescBuilder_ = null;
        }
        onChanged();
        return this;
      }
      /**
       * <pre>
       *
       *A descriptor that precisely describes *which* key to use for signing. This
       *may provide the raw public key directly, or require the Signer to re-derive
       *the key according to the populated derivation path.
       *
       *Note that if the key descriptor was obtained through walletrpc.DeriveKey,
       *then the key locator MUST always be provided, since the derived keys are not
       *persisted unlike with DeriveNextKey.
       * </pre>
       *
       * <code>.signrpc.KeyDescriptor key_desc = 1;</code>
       */
      public signrpc.SignerOuterClass.KeyDescriptor.Builder getKeyDescBuilder() {
        bitField0_ |= 0x00000001;
        onChanged();
        return getKeyDescFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       *
       *A descriptor that precisely describes *which* key to use for signing. This
       *may provide the raw public key directly, or require the Signer to re-derive
       *the key according to the populated derivation path.
       *
       *Note that if the key descriptor was obtained through walletrpc.DeriveKey,
       *then the key locator MUST always be provided, since the derived keys are not
       *persisted unlike with DeriveNextKey.
       * </pre>
       *
       * <code>.signrpc.KeyDescriptor key_desc = 1;</code>
       */
      public signrpc.SignerOuterClass.KeyDescriptorOrBuilder getKeyDescOrBuilder() {
        if (keyDescBuilder_ != null) {
          return keyDescBuilder_.getMessageOrBuilder();
        } else {
          return keyDesc_ == null ?
              signrpc.SignerOuterClass.KeyDescriptor.getDefaultInstance() : keyDesc_;
        }
      }
      /**
       * <pre>
       *
       *A descriptor that precisely describes *which* key to use for signing. This
       *may provide the raw public key directly, or require the Signer to re-derive
       *the key according to the populated derivation path.
       *
       *Note that if the key descriptor was obtained through walletrpc.DeriveKey,
       *then the key locator MUST always be provided, since the derived keys are not
       *persisted unlike with DeriveNextKey.
       * </pre>
       *
       * <code>.signrpc.KeyDescriptor key_desc = 1;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          signrpc.SignerOuterClass.KeyDescriptor, signrpc.SignerOuterClass.KeyDescriptor.Builder, signrpc.SignerOuterClass.KeyDescriptorOrBuilder> 
          getKeyDescFieldBuilder() {
        if (keyDescBuilder_ == null) {
          keyDescBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              signrpc.SignerOuterClass.KeyDescriptor, signrpc.SignerOuterClass.KeyDescriptor.Builder, signrpc.SignerOuterClass.KeyDescriptorOrBuilder>(
                  getKeyDesc(),
                  getParentForChildren(),
                  isClean());
          keyDesc_ = null;
        }
        return keyDescBuilder_;
      }

      private com.google.protobuf.ByteString singleTweak_ = com.google.protobuf.ByteString.EMPTY;
      /**
       * <pre>
       *
       *A scalar value that will be added to the private key corresponding to the
       *above public key to obtain the private key to be used to sign this input.
       *This value is typically derived via the following computation:
       *
       * derivedKey = privkey + sha256(perCommitmentPoint || pubKey) mod N
       * </pre>
       *
       * <code>bytes single_tweak = 2;</code>
       * @return The singleTweak.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString getSingleTweak() {
        return singleTweak_;
      }
      /**
       * <pre>
       *
       *A scalar value that will be added to the private key corresponding to the
       *above public key to obtain the private key to be used to sign this input.
       *This value is typically derived via the following computation:
       *
       * derivedKey = privkey + sha256(perCommitmentPoint || pubKey) mod N
       * </pre>
       *
       * <code>bytes single_tweak = 2;</code>
       * @param value The singleTweak to set.
       * @return This builder for chaining.
       */
      public Builder setSingleTweak(com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        singleTweak_ = value;
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       *
       *A scalar value that will be added to the private key corresponding to the
       *above public key to obtain the private key to be used to sign this input.
       *This value is typically derived via the following computation:
       *
       * derivedKey = privkey + sha256(perCommitmentPoint || pubKey) mod N
       * </pre>
       *
       * <code>bytes single_tweak = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearSingleTweak() {
        bitField0_ = (bitField0_ & ~0x00000002);
        singleTweak_ = getDefaultInstance().getSingleTweak();
        onChanged();
        return this;
      }

      private com.google.protobuf.ByteString doubleTweak_ = com.google.protobuf.ByteString.EMPTY;
      /**
       * <pre>
       *
       *A private key that will be used in combination with its corresponding
       *private key to derive the private key that is to be used to sign the target
       *input. Within the Lightning protocol, this value is typically the
       *commitment secret from a previously revoked commitment transaction. This
       *value is in combination with two hash values, and the original private key
       *to derive the private key to be used when signing.
       *
       * k = (privKey*sha256(pubKey || tweakPub) +
       *tweakPriv*sha256(tweakPub || pubKey)) mod N
       * </pre>
       *
       * <code>bytes double_tweak = 3;</code>
       * @return The doubleTweak.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString getDoubleTweak() {
        return doubleTweak_;
      }
      /**
       * <pre>
       *
       *A private key that will be used in combination with its corresponding
       *private key to derive the private key that is to be used to sign the target
       *input. Within the Lightning protocol, this value is typically the
       *commitment secret from a previously revoked commitment transaction. This
       *value is in combination with two hash values, and the original private key
       *to derive the private key to be used when signing.
       *
       * k = (privKey*sha256(pubKey || tweakPub) +
       *tweakPriv*sha256(tweakPub || pubKey)) mod N
       * </pre>
       *
       * <code>bytes double_tweak = 3;</code>
       * @param value The doubleTweak to set.
       * @return This builder for chaining.
       */
      public Builder setDoubleTweak(com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        doubleTweak_ = value;
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }
      /**
       * <pre>
       *
       *A private key that will be used in combination with its corresponding
       *private key to derive the private key that is to be used to sign the target
       *input. Within the Lightning protocol, this value is typically the
       *commitment secret from a previously revoked commitment transaction. This
       *value is in combination with two hash values, and the original private key
       *to derive the private key to be used when signing.
       *
       * k = (privKey*sha256(pubKey || tweakPub) +
       *tweakPriv*sha256(tweakPub || pubKey)) mod N
       * </pre>
       *
       * <code>bytes double_tweak = 3;</code>
       * @return This builder for chaining.
       */
      public Builder clearDoubleTweak() {
        bitField0_ = (bitField0_ & ~0x00000004);
        doubleTweak_ = getDefaultInstance().getDoubleTweak();
        onChanged();
        return this;
      }

      private com.google.protobuf.ByteString tapTweak_ = com.google.protobuf.ByteString.EMPTY;
      /**
       * <pre>
       *
       *The 32 byte input to the taproot tweak derivation that is used to derive
       *the output key from an internal key: outputKey = internalKey +
       *tagged_hash("tapTweak", internalKey || tapTweak).
       *
       *When doing a BIP 86 spend, this field can be an empty byte slice.
       *
       *When doing a normal key path spend, with the output key committing to an
       *actual script root, then this field should be: the tapscript root hash.
       * </pre>
       *
       * <code>bytes tap_tweak = 10;</code>
       * @return The tapTweak.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString getTapTweak() {
        return tapTweak_;
      }
      /**
       * <pre>
       *
       *The 32 byte input to the taproot tweak derivation that is used to derive
       *the output key from an internal key: outputKey = internalKey +
       *tagged_hash("tapTweak", internalKey || tapTweak).
       *
       *When doing a BIP 86 spend, this field can be an empty byte slice.
       *
       *When doing a normal key path spend, with the output key committing to an
       *actual script root, then this field should be: the tapscript root hash.
       * </pre>
       *
       * <code>bytes tap_tweak = 10;</code>
       * @param value The tapTweak to set.
       * @return This builder for chaining.
       */
      public Builder setTapTweak(com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        tapTweak_ = value;
        bitField0_ |= 0x00000008;
        onChanged();
        return this;
      }
      /**
       * <pre>
       *
       *The 32 byte input to the taproot tweak derivation that is used to derive
       *the output key from an internal key: outputKey = internalKey +
       *tagged_hash("tapTweak", internalKey || tapTweak).
       *
       *When doing a BIP 86 spend, this field can be an empty byte slice.
       *
       *When doing a normal key path spend, with the output key committing to an
       *actual script root, then this field should be: the tapscript root hash.
       * </pre>
       *
       * <code>bytes tap_tweak = 10;</code>
       * @return This builder for chaining.
       */
      public Builder clearTapTweak() {
        bitField0_ = (bitField0_ & ~0x00000008);
        tapTweak_ = getDefaultInstance().getTapTweak();
        onChanged();
        return this;
      }

      private com.google.protobuf.ByteString witnessScript_ = com.google.protobuf.ByteString.EMPTY;
      /**
       * <pre>
       *
       *The full script required to properly redeem the output. This field will
       *only be populated if a p2tr, p2wsh or a p2sh output is being signed. If a
       *taproot script path spend is being attempted, then this should be the raw
       *leaf script.
       * </pre>
       *
       * <code>bytes witness_script = 4;</code>
       * @return The witnessScript.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString getWitnessScript() {
        return witnessScript_;
      }
      /**
       * <pre>
       *
       *The full script required to properly redeem the output. This field will
       *only be populated if a p2tr, p2wsh or a p2sh output is being signed. If a
       *taproot script path spend is being attempted, then this should be the raw
       *leaf script.
       * </pre>
       *
       * <code>bytes witness_script = 4;</code>
       * @param value The witnessScript to set.
       * @return This builder for chaining.
       */
      public Builder setWitnessScript(com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        witnessScript_ = value;
        bitField0_ |= 0x00000010;
        onChanged();
        return this;
      }
      /**
       * <pre>
       *
       *The full script required to properly redeem the output. This field will
       *only be populated if a p2tr, p2wsh or a p2sh output is being signed. If a
       *taproot script path spend is being attempted, then this should be the raw
       *leaf script.
       * </pre>
       *
       * <code>bytes witness_script = 4;</code>
       * @return This builder for chaining.
       */
      public Builder clearWitnessScript() {
        bitField0_ = (bitField0_ & ~0x00000010);
        witnessScript_ = getDefaultInstance().getWitnessScript();
        onChanged();
        return this;
      }

      private signrpc.SignerOuterClass.TxOut output_;
      private com.google.protobuf.SingleFieldBuilderV3<
          signrpc.SignerOuterClass.TxOut, signrpc.SignerOuterClass.TxOut.Builder, signrpc.SignerOuterClass.TxOutOrBuilder> outputBuilder_;
      /**
       * <pre>
       *
       *A description of the output being spent. The value and script MUST be
       *provided.
       * </pre>
       *
       * <code>.signrpc.TxOut output = 5;</code>
       * @return Whether the output field is set.
       */
      public boolean hasOutput() {
        return ((bitField0_ & 0x00000020) != 0);
      }
      /**
       * <pre>
       *
       *A description of the output being spent. The value and script MUST be
       *provided.
       * </pre>
       *
       * <code>.signrpc.TxOut output = 5;</code>
       * @return The output.
       */
      public signrpc.SignerOuterClass.TxOut getOutput() {
        if (outputBuilder_ == null) {
          return output_ == null ? signrpc.SignerOuterClass.TxOut.getDefaultInstance() : output_;
        } else {
          return outputBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       *
       *A description of the output being spent. The value and script MUST be
       *provided.
       * </pre>
       *
       * <code>.signrpc.TxOut output = 5;</code>
       */
      public Builder setOutput(signrpc.SignerOuterClass.TxOut value) {
        if (outputBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          output_ = value;
        } else {
          outputBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000020;
        onChanged();
        return this;
      }
      /**
       * <pre>
       *
       *A description of the output being spent. The value and script MUST be
       *provided.
       * </pre>
       *
       * <code>.signrpc.TxOut output = 5;</code>
       */
      public Builder setOutput(
          signrpc.SignerOuterClass.TxOut.Builder builderForValue) {
        if (outputBuilder_ == null) {
          output_ = builderForValue.build();
        } else {
          outputBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000020;
        onChanged();
        return this;
      }
      /**
       * <pre>
       *
       *A description of the output being spent. The value and script MUST be
       *provided.
       * </pre>
       *
       * <code>.signrpc.TxOut output = 5;</code>
       */
      public Builder mergeOutput(signrpc.SignerOuterClass.TxOut value) {
        if (outputBuilder_ == null) {
          if (((bitField0_ & 0x00000020) != 0) &&
            output_ != null &&
            output_ != signrpc.SignerOuterClass.TxOut.getDefaultInstance()) {
            getOutputBuilder().mergeFrom(value);
          } else {
            output_ = value;
          }
        } else {
          outputBuilder_.mergeFrom(value);
        }
        if (output_ != null) {
          bitField0_ |= 0x00000020;
          onChanged();
        }
        return this;
      }
      /**
       * <pre>
       *
       *A description of the output being spent. The value and script MUST be
       *provided.
       * </pre>
       *
       * <code>.signrpc.TxOut output = 5;</code>
       */
      public Builder clearOutput() {
        bitField0_ = (bitField0_ & ~0x00000020);
        output_ = null;
        if (outputBuilder_ != null) {
          outputBuilder_.dispose();
          outputBuilder_ = null;
        }
        onChanged();
        return this;
      }
      /**
       * <pre>
       *
       *A description of the output being spent. The value and script MUST be
       *provided.
       * </pre>
       *
       * <code>.signrpc.TxOut output = 5;</code>
       */
      public signrpc.SignerOuterClass.TxOut.Builder getOutputBuilder() {
        bitField0_ |= 0x00000020;
        onChanged();
        return getOutputFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       *
       *A description of the output being spent. The value and script MUST be
       *provided.
       * </pre>
       *
       * <code>.signrpc.TxOut output = 5;</code>
       */
      public signrpc.SignerOuterClass.TxOutOrBuilder getOutputOrBuilder() {
        if (outputBuilder_ != null) {
          return outputBuilder_.getMessageOrBuilder();
        } else {
          return output_ == null ?
              signrpc.SignerOuterClass.TxOut.getDefaultInstance() : output_;
        }
      }
      /**
       * <pre>
       *
       *A description of the output being spent. The value and script MUST be
       *provided.
       * </pre>
       *
       * <code>.signrpc.TxOut output = 5;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          signrpc.SignerOuterClass.TxOut, signrpc.SignerOuterClass.TxOut.Builder, signrpc.SignerOuterClass.TxOutOrBuilder> 
          getOutputFieldBuilder() {
        if (outputBuilder_ == null) {
          outputBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              signrpc.SignerOuterClass.TxOut, signrpc.SignerOuterClass.TxOut.Builder, signrpc.SignerOuterClass.TxOutOrBuilder>(
                  getOutput(),
                  getParentForChildren(),
                  isClean());
          output_ = null;
        }
        return outputBuilder_;
      }

      private int sighash_ ;
      /**
       * <pre>
       *
       *The target sighash type that should be used when generating the final
       *sighash, and signature.
       * </pre>
       *
       * <code>uint32 sighash = 7;</code>
       * @return The sighash.
       */
      @java.lang.Override
      public int getSighash() {
        return sighash_;
      }
      /**
       * <pre>
       *
       *The target sighash type that should be used when generating the final
       *sighash, and signature.
       * </pre>
       *
       * <code>uint32 sighash = 7;</code>
       * @param value The sighash to set.
       * @return This builder for chaining.
       */
      public Builder setSighash(int value) {

        sighash_ = value;
        bitField0_ |= 0x00000040;
        onChanged();
        return this;
      }
      /**
       * <pre>
       *
       *The target sighash type that should be used when generating the final
       *sighash, and signature.
       * </pre>
       *
       * <code>uint32 sighash = 7;</code>
       * @return This builder for chaining.
       */
      public Builder clearSighash() {
        bitField0_ = (bitField0_ & ~0x00000040);
        sighash_ = 0;
        onChanged();
        return this;
      }

      private int inputIndex_ ;
      /**
       * <pre>
       *
       *The target input within the transaction that should be signed.
       * </pre>
       *
       * <code>int32 input_index = 8;</code>
       * @return The inputIndex.
       */
      @java.lang.Override
      public int getInputIndex() {
        return inputIndex_;
      }
      /**
       * <pre>
       *
       *The target input within the transaction that should be signed.
       * </pre>
       *
       * <code>int32 input_index = 8;</code>
       * @param value The inputIndex to set.
       * @return This builder for chaining.
       */
      public Builder setInputIndex(int value) {

        inputIndex_ = value;
        bitField0_ |= 0x00000080;
        onChanged();
        return this;
      }
      /**
       * <pre>
       *
       *The target input within the transaction that should be signed.
       * </pre>
       *
       * <code>int32 input_index = 8;</code>
       * @return This builder for chaining.
       */
      public Builder clearInputIndex() {
        bitField0_ = (bitField0_ & ~0x00000080);
        inputIndex_ = 0;
        onChanged();
        return this;
      }

      private int signMethod_ = 0;
      /**
       * <pre>
       *
       *The sign method specifies how the input should be signed. Depending on the
       *method, either the tap_tweak, witness_script or both need to be specified.
       *Defaults to SegWit v0 signing to be backward compatible with older RPC
       *clients.
       * </pre>
       *
       * <code>.signrpc.SignMethod sign_method = 9;</code>
       * @return The enum numeric value on the wire for signMethod.
       */
      @java.lang.Override public int getSignMethodValue() {
        return signMethod_;
      }
      /**
       * <pre>
       *
       *The sign method specifies how the input should be signed. Depending on the
       *method, either the tap_tweak, witness_script or both need to be specified.
       *Defaults to SegWit v0 signing to be backward compatible with older RPC
       *clients.
       * </pre>
       *
       * <code>.signrpc.SignMethod sign_method = 9;</code>
       * @param value The enum numeric value on the wire for signMethod to set.
       * @return This builder for chaining.
       */
      public Builder setSignMethodValue(int value) {
        signMethod_ = value;
        bitField0_ |= 0x00000100;
        onChanged();
        return this;
      }
      /**
       * <pre>
       *
       *The sign method specifies how the input should be signed. Depending on the
       *method, either the tap_tweak, witness_script or both need to be specified.
       *Defaults to SegWit v0 signing to be backward compatible with older RPC
       *clients.
       * </pre>
       *
       * <code>.signrpc.SignMethod sign_method = 9;</code>
       * @return The signMethod.
       */
      @java.lang.Override
      public signrpc.SignerOuterClass.SignMethod getSignMethod() {
        signrpc.SignerOuterClass.SignMethod result = signrpc.SignerOuterClass.SignMethod.forNumber(signMethod_);
        return result == null ? signrpc.SignerOuterClass.SignMethod.UNRECOGNIZED : result;
      }
      /**
       * <pre>
       *
       *The sign method specifies how the input should be signed. Depending on the
       *method, either the tap_tweak, witness_script or both need to be specified.
       *Defaults to SegWit v0 signing to be backward compatible with older RPC
       *clients.
       * </pre>
       *
       * <code>.signrpc.SignMethod sign_method = 9;</code>
       * @param value The signMethod to set.
       * @return This builder for chaining.
       */
      public Builder setSignMethod(signrpc.SignerOuterClass.SignMethod value) {
        if (value == null) {
          throw new NullPointerException();
        }
        bitField0_ |= 0x00000100;
        signMethod_ = value.getNumber();
        onChanged();
        return this;
      }
      /**
       * <pre>
       *
       *The sign method specifies how the input should be signed. Depending on the
       *method, either the tap_tweak, witness_script or both need to be specified.
       *Defaults to SegWit v0 signing to be backward compatible with older RPC
       *clients.
       * </pre>
       *
       * <code>.signrpc.SignMethod sign_method = 9;</code>
       * @return This builder for chaining.
       */
      public Builder clearSignMethod() {
        bitField0_ = (bitField0_ & ~0x00000100);
        signMethod_ = 0;
        onChanged();
        return this;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:signrpc.SignDescriptor)
    }

    // @@protoc_insertion_point(class_scope:signrpc.SignDescriptor)
    private static final signrpc.SignerOuterClass.SignDescriptor DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new signrpc.SignerOuterClass.SignDescriptor();
    }

    public static signrpc.SignerOuterClass.SignDescriptor getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<SignDescriptor>
        PARSER = new com.google.protobuf.AbstractParser<SignDescriptor>() {
      @java.lang.Override
      public SignDescriptor parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<SignDescriptor> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<SignDescriptor> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public signrpc.SignerOuterClass.SignDescriptor getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface SignReqOrBuilder extends
      // @@protoc_insertion_point(interface_extends:signrpc.SignReq)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * The raw bytes of the transaction to be signed.
     * </pre>
     *
     * <code>bytes raw_tx_bytes = 1;</code>
     * @return The rawTxBytes.
     */
    com.google.protobuf.ByteString getRawTxBytes();

    /**
     * <pre>
     * A set of sign descriptors, for each input to be signed.
     * </pre>
     *
     * <code>repeated .signrpc.SignDescriptor sign_descs = 2;</code>
     */
    java.util.List<signrpc.SignerOuterClass.SignDescriptor> 
        getSignDescsList();
    /**
     * <pre>
     * A set of sign descriptors, for each input to be signed.
     * </pre>
     *
     * <code>repeated .signrpc.SignDescriptor sign_descs = 2;</code>
     */
    signrpc.SignerOuterClass.SignDescriptor getSignDescs(int index);
    /**
     * <pre>
     * A set of sign descriptors, for each input to be signed.
     * </pre>
     *
     * <code>repeated .signrpc.SignDescriptor sign_descs = 2;</code>
     */
    int getSignDescsCount();
    /**
     * <pre>
     * A set of sign descriptors, for each input to be signed.
     * </pre>
     *
     * <code>repeated .signrpc.SignDescriptor sign_descs = 2;</code>
     */
    java.util.List<? extends signrpc.SignerOuterClass.SignDescriptorOrBuilder> 
        getSignDescsOrBuilderList();
    /**
     * <pre>
     * A set of sign descriptors, for each input to be signed.
     * </pre>
     *
     * <code>repeated .signrpc.SignDescriptor sign_descs = 2;</code>
     */
    signrpc.SignerOuterClass.SignDescriptorOrBuilder getSignDescsOrBuilder(
        int index);

    /**
     * <pre>
     *
     *The full list of UTXO information for each of the inputs being spent. This
     *is required when spending one or more taproot (SegWit v1) outputs.
     * </pre>
     *
     * <code>repeated .signrpc.TxOut prev_outputs = 3;</code>
     */
    java.util.List<signrpc.SignerOuterClass.TxOut> 
        getPrevOutputsList();
    /**
     * <pre>
     *
     *The full list of UTXO information for each of the inputs being spent. This
     *is required when spending one or more taproot (SegWit v1) outputs.
     * </pre>
     *
     * <code>repeated .signrpc.TxOut prev_outputs = 3;</code>
     */
    signrpc.SignerOuterClass.TxOut getPrevOutputs(int index);
    /**
     * <pre>
     *
     *The full list of UTXO information for each of the inputs being spent. This
     *is required when spending one or more taproot (SegWit v1) outputs.
     * </pre>
     *
     * <code>repeated .signrpc.TxOut prev_outputs = 3;</code>
     */
    int getPrevOutputsCount();
    /**
     * <pre>
     *
     *The full list of UTXO information for each of the inputs being spent. This
     *is required when spending one or more taproot (SegWit v1) outputs.
     * </pre>
     *
     * <code>repeated .signrpc.TxOut prev_outputs = 3;</code>
     */
    java.util.List<? extends signrpc.SignerOuterClass.TxOutOrBuilder> 
        getPrevOutputsOrBuilderList();
    /**
     * <pre>
     *
     *The full list of UTXO information for each of the inputs being spent. This
     *is required when spending one or more taproot (SegWit v1) outputs.
     * </pre>
     *
     * <code>repeated .signrpc.TxOut prev_outputs = 3;</code>
     */
    signrpc.SignerOuterClass.TxOutOrBuilder getPrevOutputsOrBuilder(
        int index);
  }
  /**
   * Protobuf type {@code signrpc.SignReq}
   */
  public static final class SignReq extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:signrpc.SignReq)
      SignReqOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use SignReq.newBuilder() to construct.
    private SignReq(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private SignReq() {
      rawTxBytes_ = com.google.protobuf.ByteString.EMPTY;
      signDescs_ = java.util.Collections.emptyList();
      prevOutputs_ = java.util.Collections.emptyList();
    }

    @java.lang.Override
    @SuppressWarnings({"unused"})
    protected java.lang.Object newInstance(
        UnusedPrivateParameter unused) {
      return new SignReq();
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return signrpc.SignerOuterClass.internal_static_signrpc_SignReq_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return signrpc.SignerOuterClass.internal_static_signrpc_SignReq_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              signrpc.SignerOuterClass.SignReq.class, signrpc.SignerOuterClass.SignReq.Builder.class);
    }

    public static final int RAW_TX_BYTES_FIELD_NUMBER = 1;
    private com.google.protobuf.ByteString rawTxBytes_ = com.google.protobuf.ByteString.EMPTY;
    /**
     * <pre>
     * The raw bytes of the transaction to be signed.
     * </pre>
     *
     * <code>bytes raw_tx_bytes = 1;</code>
     * @return The rawTxBytes.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString getRawTxBytes() {
      return rawTxBytes_;
    }

    public static final int SIGN_DESCS_FIELD_NUMBER = 2;
    @SuppressWarnings("serial")
    private java.util.List<signrpc.SignerOuterClass.SignDescriptor> signDescs_;
    /**
     * <pre>
     * A set of sign descriptors, for each input to be signed.
     * </pre>
     *
     * <code>repeated .signrpc.SignDescriptor sign_descs = 2;</code>
     */
    @java.lang.Override
    public java.util.List<signrpc.SignerOuterClass.SignDescriptor> getSignDescsList() {
      return signDescs_;
    }
    /**
     * <pre>
     * A set of sign descriptors, for each input to be signed.
     * </pre>
     *
     * <code>repeated .signrpc.SignDescriptor sign_descs = 2;</code>
     */
    @java.lang.Override
    public java.util.List<? extends signrpc.SignerOuterClass.SignDescriptorOrBuilder> 
        getSignDescsOrBuilderList() {
      return signDescs_;
    }
    /**
     * <pre>
     * A set of sign descriptors, for each input to be signed.
     * </pre>
     *
     * <code>repeated .signrpc.SignDescriptor sign_descs = 2;</code>
     */
    @java.lang.Override
    public int getSignDescsCount() {
      return signDescs_.size();
    }
    /**
     * <pre>
     * A set of sign descriptors, for each input to be signed.
     * </pre>
     *
     * <code>repeated .signrpc.SignDescriptor sign_descs = 2;</code>
     */
    @java.lang.Override
    public signrpc.SignerOuterClass.SignDescriptor getSignDescs(int index) {
      return signDescs_.get(index);
    }
    /**
     * <pre>
     * A set of sign descriptors, for each input to be signed.
     * </pre>
     *
     * <code>repeated .signrpc.SignDescriptor sign_descs = 2;</code>
     */
    @java.lang.Override
    public signrpc.SignerOuterClass.SignDescriptorOrBuilder getSignDescsOrBuilder(
        int index) {
      return signDescs_.get(index);
    }

    public static final int PREV_OUTPUTS_FIELD_NUMBER = 3;
    @SuppressWarnings("serial")
    private java.util.List<signrpc.SignerOuterClass.TxOut> prevOutputs_;
    /**
     * <pre>
     *
     *The full list of UTXO information for each of the inputs being spent. This
     *is required when spending one or more taproot (SegWit v1) outputs.
     * </pre>
     *
     * <code>repeated .signrpc.TxOut prev_outputs = 3;</code>
     */
    @java.lang.Override
    public java.util.List<signrpc.SignerOuterClass.TxOut> getPrevOutputsList() {
      return prevOutputs_;
    }
    /**
     * <pre>
     *
     *The full list of UTXO information for each of the inputs being spent. This
     *is required when spending one or more taproot (SegWit v1) outputs.
     * </pre>
     *
     * <code>repeated .signrpc.TxOut prev_outputs = 3;</code>
     */
    @java.lang.Override
    public java.util.List<? extends signrpc.SignerOuterClass.TxOutOrBuilder> 
        getPrevOutputsOrBuilderList() {
      return prevOutputs_;
    }
    /**
     * <pre>
     *
     *The full list of UTXO information for each of the inputs being spent. This
     *is required when spending one or more taproot (SegWit v1) outputs.
     * </pre>
     *
     * <code>repeated .signrpc.TxOut prev_outputs = 3;</code>
     */
    @java.lang.Override
    public int getPrevOutputsCount() {
      return prevOutputs_.size();
    }
    /**
     * <pre>
     *
     *The full list of UTXO information for each of the inputs being spent. This
     *is required when spending one or more taproot (SegWit v1) outputs.
     * </pre>
     *
     * <code>repeated .signrpc.TxOut prev_outputs = 3;</code>
     */
    @java.lang.Override
    public signrpc.SignerOuterClass.TxOut getPrevOutputs(int index) {
      return prevOutputs_.get(index);
    }
    /**
     * <pre>
     *
     *The full list of UTXO information for each of the inputs being spent. This
     *is required when spending one or more taproot (SegWit v1) outputs.
     * </pre>
     *
     * <code>repeated .signrpc.TxOut prev_outputs = 3;</code>
     */
    @java.lang.Override
    public signrpc.SignerOuterClass.TxOutOrBuilder getPrevOutputsOrBuilder(
        int index) {
      return prevOutputs_.get(index);
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (!rawTxBytes_.isEmpty()) {
        output.writeBytes(1, rawTxBytes_);
      }
      for (int i = 0; i < signDescs_.size(); i++) {
        output.writeMessage(2, signDescs_.get(i));
      }
      for (int i = 0; i < prevOutputs_.size(); i++) {
        output.writeMessage(3, prevOutputs_.get(i));
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (!rawTxBytes_.isEmpty()) {
        size += com.google.protobuf.CodedOutputStream
          .computeBytesSize(1, rawTxBytes_);
      }
      for (int i = 0; i < signDescs_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(2, signDescs_.get(i));
      }
      for (int i = 0; i < prevOutputs_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(3, prevOutputs_.get(i));
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof signrpc.SignerOuterClass.SignReq)) {
        return super.equals(obj);
      }
      signrpc.SignerOuterClass.SignReq other = (signrpc.SignerOuterClass.SignReq) obj;

      if (!getRawTxBytes()
          .equals(other.getRawTxBytes())) return false;
      if (!getSignDescsList()
          .equals(other.getSignDescsList())) return false;
      if (!getPrevOutputsList()
          .equals(other.getPrevOutputsList())) return false;
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      hash = (37 * hash) + RAW_TX_BYTES_FIELD_NUMBER;
      hash = (53 * hash) + getRawTxBytes().hashCode();
      if (getSignDescsCount() > 0) {
        hash = (37 * hash) + SIGN_DESCS_FIELD_NUMBER;
        hash = (53 * hash) + getSignDescsList().hashCode();
      }
      if (getPrevOutputsCount() > 0) {
        hash = (37 * hash) + PREV_OUTPUTS_FIELD_NUMBER;
        hash = (53 * hash) + getPrevOutputsList().hashCode();
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static signrpc.SignerOuterClass.SignReq parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static signrpc.SignerOuterClass.SignReq parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static signrpc.SignerOuterClass.SignReq parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static signrpc.SignerOuterClass.SignReq parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static signrpc.SignerOuterClass.SignReq parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static signrpc.SignerOuterClass.SignReq parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static signrpc.SignerOuterClass.SignReq parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static signrpc.SignerOuterClass.SignReq parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static signrpc.SignerOuterClass.SignReq parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static signrpc.SignerOuterClass.SignReq parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static signrpc.SignerOuterClass.SignReq parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static signrpc.SignerOuterClass.SignReq parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(signrpc.SignerOuterClass.SignReq prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * Protobuf type {@code signrpc.SignReq}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:signrpc.SignReq)
        signrpc.SignerOuterClass.SignReqOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return signrpc.SignerOuterClass.internal_static_signrpc_SignReq_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return signrpc.SignerOuterClass.internal_static_signrpc_SignReq_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                signrpc.SignerOuterClass.SignReq.class, signrpc.SignerOuterClass.SignReq.Builder.class);
      }

      // Construct using signrpc.SignerOuterClass.SignReq.newBuilder()
      private Builder() {

      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);

      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        rawTxBytes_ = com.google.protobuf.ByteString.EMPTY;
        if (signDescsBuilder_ == null) {
          signDescs_ = java.util.Collections.emptyList();
        } else {
          signDescs_ = null;
          signDescsBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000002);
        if (prevOutputsBuilder_ == null) {
          prevOutputs_ = java.util.Collections.emptyList();
        } else {
          prevOutputs_ = null;
          prevOutputsBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000004);
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return signrpc.SignerOuterClass.internal_static_signrpc_SignReq_descriptor;
      }

      @java.lang.Override
      public signrpc.SignerOuterClass.SignReq getDefaultInstanceForType() {
        return signrpc.SignerOuterClass.SignReq.getDefaultInstance();
      }

      @java.lang.Override
      public signrpc.SignerOuterClass.SignReq build() {
        signrpc.SignerOuterClass.SignReq result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public signrpc.SignerOuterClass.SignReq buildPartial() {
        signrpc.SignerOuterClass.SignReq result = new signrpc.SignerOuterClass.SignReq(this);
        buildPartialRepeatedFields(result);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartialRepeatedFields(signrpc.SignerOuterClass.SignReq result) {
        if (signDescsBuilder_ == null) {
          if (((bitField0_ & 0x00000002) != 0)) {
            signDescs_ = java.util.Collections.unmodifiableList(signDescs_);
            bitField0_ = (bitField0_ & ~0x00000002);
          }
          result.signDescs_ = signDescs_;
        } else {
          result.signDescs_ = signDescsBuilder_.build();
        }
        if (prevOutputsBuilder_ == null) {
          if (((bitField0_ & 0x00000004) != 0)) {
            prevOutputs_ = java.util.Collections.unmodifiableList(prevOutputs_);
            bitField0_ = (bitField0_ & ~0x00000004);
          }
          result.prevOutputs_ = prevOutputs_;
        } else {
          result.prevOutputs_ = prevOutputsBuilder_.build();
        }
      }

      private void buildPartial0(signrpc.SignerOuterClass.SignReq result) {
        int from_bitField0_ = bitField0_;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.rawTxBytes_ = rawTxBytes_;
        }
      }

      @java.lang.Override
      public Builder clone() {
        return super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof signrpc.SignerOuterClass.SignReq) {
          return mergeFrom((signrpc.SignerOuterClass.SignReq)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(signrpc.SignerOuterClass.SignReq other) {
        if (other == signrpc.SignerOuterClass.SignReq.getDefaultInstance()) return this;
        if (other.getRawTxBytes() != com.google.protobuf.ByteString.EMPTY) {
          setRawTxBytes(other.getRawTxBytes());
        }
        if (signDescsBuilder_ == null) {
          if (!other.signDescs_.isEmpty()) {
            if (signDescs_.isEmpty()) {
              signDescs_ = other.signDescs_;
              bitField0_ = (bitField0_ & ~0x00000002);
            } else {
              ensureSignDescsIsMutable();
              signDescs_.addAll(other.signDescs_);
            }
            onChanged();
          }
        } else {
          if (!other.signDescs_.isEmpty()) {
            if (signDescsBuilder_.isEmpty()) {
              signDescsBuilder_.dispose();
              signDescsBuilder_ = null;
              signDescs_ = other.signDescs_;
              bitField0_ = (bitField0_ & ~0x00000002);
              signDescsBuilder_ = 
                com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
                   getSignDescsFieldBuilder() : null;
            } else {
              signDescsBuilder_.addAllMessages(other.signDescs_);
            }
          }
        }
        if (prevOutputsBuilder_ == null) {
          if (!other.prevOutputs_.isEmpty()) {
            if (prevOutputs_.isEmpty()) {
              prevOutputs_ = other.prevOutputs_;
              bitField0_ = (bitField0_ & ~0x00000004);
            } else {
              ensurePrevOutputsIsMutable();
              prevOutputs_.addAll(other.prevOutputs_);
            }
            onChanged();
          }
        } else {
          if (!other.prevOutputs_.isEmpty()) {
            if (prevOutputsBuilder_.isEmpty()) {
              prevOutputsBuilder_.dispose();
              prevOutputsBuilder_ = null;
              prevOutputs_ = other.prevOutputs_;
              bitField0_ = (bitField0_ & ~0x00000004);
              prevOutputsBuilder_ = 
                com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
                   getPrevOutputsFieldBuilder() : null;
            } else {
              prevOutputsBuilder_.addAllMessages(other.prevOutputs_);
            }
          }
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10: {
                rawTxBytes_ = input.readBytes();
                bitField0_ |= 0x00000001;
                break;
              } // case 10
              case 18: {
                signrpc.SignerOuterClass.SignDescriptor m =
                    input.readMessage(
                        signrpc.SignerOuterClass.SignDescriptor.parser(),
                        extensionRegistry);
                if (signDescsBuilder_ == null) {
                  ensureSignDescsIsMutable();
                  signDescs_.add(m);
                } else {
                  signDescsBuilder_.addMessage(m);
                }
                break;
              } // case 18
              case 26: {
                signrpc.SignerOuterClass.TxOut m =
                    input.readMessage(
                        signrpc.SignerOuterClass.TxOut.parser(),
                        extensionRegistry);
                if (prevOutputsBuilder_ == null) {
                  ensurePrevOutputsIsMutable();
                  prevOutputs_.add(m);
                } else {
                  prevOutputsBuilder_.addMessage(m);
                }
                break;
              } // case 26
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private com.google.protobuf.ByteString rawTxBytes_ = com.google.protobuf.ByteString.EMPTY;
      /**
       * <pre>
       * The raw bytes of the transaction to be signed.
       * </pre>
       *
       * <code>bytes raw_tx_bytes = 1;</code>
       * @return The rawTxBytes.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString getRawTxBytes() {
        return rawTxBytes_;
      }
      /**
       * <pre>
       * The raw bytes of the transaction to be signed.
       * </pre>
       *
       * <code>bytes raw_tx_bytes = 1;</code>
       * @param value The rawTxBytes to set.
       * @return This builder for chaining.
       */
      public Builder setRawTxBytes(com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        rawTxBytes_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The raw bytes of the transaction to be signed.
       * </pre>
       *
       * <code>bytes raw_tx_bytes = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearRawTxBytes() {
        bitField0_ = (bitField0_ & ~0x00000001);
        rawTxBytes_ = getDefaultInstance().getRawTxBytes();
        onChanged();
        return this;
      }

      private java.util.List<signrpc.SignerOuterClass.SignDescriptor> signDescs_ =
        java.util.Collections.emptyList();
      private void ensureSignDescsIsMutable() {
        if (!((bitField0_ & 0x00000002) != 0)) {
          signDescs_ = new java.util.ArrayList<signrpc.SignerOuterClass.SignDescriptor>(signDescs_);
          bitField0_ |= 0x00000002;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
          signrpc.SignerOuterClass.SignDescriptor, signrpc.SignerOuterClass.SignDescriptor.Builder, signrpc.SignerOuterClass.SignDescriptorOrBuilder> signDescsBuilder_;

      /**
       * <pre>
       * A set of sign descriptors, for each input to be signed.
       * </pre>
       *
       * <code>repeated .signrpc.SignDescriptor sign_descs = 2;</code>
       */
      public java.util.List<signrpc.SignerOuterClass.SignDescriptor> getSignDescsList() {
        if (signDescsBuilder_ == null) {
          return java.util.Collections.unmodifiableList(signDescs_);
        } else {
          return signDescsBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       * A set of sign descriptors, for each input to be signed.
       * </pre>
       *
       * <code>repeated .signrpc.SignDescriptor sign_descs = 2;</code>
       */
      public int getSignDescsCount() {
        if (signDescsBuilder_ == null) {
          return signDescs_.size();
        } else {
          return signDescsBuilder_.getCount();
        }
      }
      /**
       * <pre>
       * A set of sign descriptors, for each input to be signed.
       * </pre>
       *
       * <code>repeated .signrpc.SignDescriptor sign_descs = 2;</code>
       */
      public signrpc.SignerOuterClass.SignDescriptor getSignDescs(int index) {
        if (signDescsBuilder_ == null) {
          return signDescs_.get(index);
        } else {
          return signDescsBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       * A set of sign descriptors, for each input to be signed.
       * </pre>
       *
       * <code>repeated .signrpc.SignDescriptor sign_descs = 2;</code>
       */
      public Builder setSignDescs(
          int index, signrpc.SignerOuterClass.SignDescriptor value) {
        if (signDescsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureSignDescsIsMutable();
          signDescs_.set(index, value);
          onChanged();
        } else {
          signDescsBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * A set of sign descriptors, for each input to be signed.
       * </pre>
       *
       * <code>repeated .signrpc.SignDescriptor sign_descs = 2;</code>
       */
      public Builder setSignDescs(
          int index, signrpc.SignerOuterClass.SignDescriptor.Builder builderForValue) {
        if (signDescsBuilder_ == null) {
          ensureSignDescsIsMutable();
          signDescs_.set(index, builderForValue.build());
          onChanged();
        } else {
          signDescsBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * A set of sign descriptors, for each input to be signed.
       * </pre>
       *
       * <code>repeated .signrpc.SignDescriptor sign_descs = 2;</code>
       */
      public Builder addSignDescs(signrpc.SignerOuterClass.SignDescriptor value) {
        if (signDescsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureSignDescsIsMutable();
          signDescs_.add(value);
          onChanged();
        } else {
          signDescsBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       * A set of sign descriptors, for each input to be signed.
       * </pre>
       *
       * <code>repeated .signrpc.SignDescriptor sign_descs = 2;</code>
       */
      public Builder addSignDescs(
          int index, signrpc.SignerOuterClass.SignDescriptor value) {
        if (signDescsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureSignDescsIsMutable();
          signDescs_.add(index, value);
          onChanged();
        } else {
          signDescsBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * A set of sign descriptors, for each input to be signed.
       * </pre>
       *
       * <code>repeated .signrpc.SignDescriptor sign_descs = 2;</code>
       */
      public Builder addSignDescs(
          signrpc.SignerOuterClass.SignDescriptor.Builder builderForValue) {
        if (signDescsBuilder_ == null) {
          ensureSignDescsIsMutable();
          signDescs_.add(builderForValue.build());
          onChanged();
        } else {
          signDescsBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * A set of sign descriptors, for each input to be signed.
       * </pre>
       *
       * <code>repeated .signrpc.SignDescriptor sign_descs = 2;</code>
       */
      public Builder addSignDescs(
          int index, signrpc.SignerOuterClass.SignDescriptor.Builder builderForValue) {
        if (signDescsBuilder_ == null) {
          ensureSignDescsIsMutable();
          signDescs_.add(index, builderForValue.build());
          onChanged();
        } else {
          signDescsBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * A set of sign descriptors, for each input to be signed.
       * </pre>
       *
       * <code>repeated .signrpc.SignDescriptor sign_descs = 2;</code>
       */
      public Builder addAllSignDescs(
          java.lang.Iterable<? extends signrpc.SignerOuterClass.SignDescriptor> values) {
        if (signDescsBuilder_ == null) {
          ensureSignDescsIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, signDescs_);
          onChanged();
        } else {
          signDescsBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       * A set of sign descriptors, for each input to be signed.
       * </pre>
       *
       * <code>repeated .signrpc.SignDescriptor sign_descs = 2;</code>
       */
      public Builder clearSignDescs() {
        if (signDescsBuilder_ == null) {
          signDescs_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000002);
          onChanged();
        } else {
          signDescsBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * A set of sign descriptors, for each input to be signed.
       * </pre>
       *
       * <code>repeated .signrpc.SignDescriptor sign_descs = 2;</code>
       */
      public Builder removeSignDescs(int index) {
        if (signDescsBuilder_ == null) {
          ensureSignDescsIsMutable();
          signDescs_.remove(index);
          onChanged();
        } else {
          signDescsBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       * A set of sign descriptors, for each input to be signed.
       * </pre>
       *
       * <code>repeated .signrpc.SignDescriptor sign_descs = 2;</code>
       */
      public signrpc.SignerOuterClass.SignDescriptor.Builder getSignDescsBuilder(
          int index) {
        return getSignDescsFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       * A set of sign descriptors, for each input to be signed.
       * </pre>
       *
       * <code>repeated .signrpc.SignDescriptor sign_descs = 2;</code>
       */
      public signrpc.SignerOuterClass.SignDescriptorOrBuilder getSignDescsOrBuilder(
          int index) {
        if (signDescsBuilder_ == null) {
          return signDescs_.get(index);  } else {
          return signDescsBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       * A set of sign descriptors, for each input to be signed.
       * </pre>
       *
       * <code>repeated .signrpc.SignDescriptor sign_descs = 2;</code>
       */
      public java.util.List<? extends signrpc.SignerOuterClass.SignDescriptorOrBuilder> 
           getSignDescsOrBuilderList() {
        if (signDescsBuilder_ != null) {
          return signDescsBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(signDescs_);
        }
      }
      /**
       * <pre>
       * A set of sign descriptors, for each input to be signed.
       * </pre>
       *
       * <code>repeated .signrpc.SignDescriptor sign_descs = 2;</code>
       */
      public signrpc.SignerOuterClass.SignDescriptor.Builder addSignDescsBuilder() {
        return getSignDescsFieldBuilder().addBuilder(
            signrpc.SignerOuterClass.SignDescriptor.getDefaultInstance());
      }
      /**
       * <pre>
       * A set of sign descriptors, for each input to be signed.
       * </pre>
       *
       * <code>repeated .signrpc.SignDescriptor sign_descs = 2;</code>
       */
      public signrpc.SignerOuterClass.SignDescriptor.Builder addSignDescsBuilder(
          int index) {
        return getSignDescsFieldBuilder().addBuilder(
            index, signrpc.SignerOuterClass.SignDescriptor.getDefaultInstance());
      }
      /**
       * <pre>
       * A set of sign descriptors, for each input to be signed.
       * </pre>
       *
       * <code>repeated .signrpc.SignDescriptor sign_descs = 2;</code>
       */
      public java.util.List<signrpc.SignerOuterClass.SignDescriptor.Builder> 
           getSignDescsBuilderList() {
        return getSignDescsFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilderV3<
          signrpc.SignerOuterClass.SignDescriptor, signrpc.SignerOuterClass.SignDescriptor.Builder, signrpc.SignerOuterClass.SignDescriptorOrBuilder> 
          getSignDescsFieldBuilder() {
        if (signDescsBuilder_ == null) {
          signDescsBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<
              signrpc.SignerOuterClass.SignDescriptor, signrpc.SignerOuterClass.SignDescriptor.Builder, signrpc.SignerOuterClass.SignDescriptorOrBuilder>(
                  signDescs_,
                  ((bitField0_ & 0x00000002) != 0),
                  getParentForChildren(),
                  isClean());
          signDescs_ = null;
        }
        return signDescsBuilder_;
      }

      private java.util.List<signrpc.SignerOuterClass.TxOut> prevOutputs_ =
        java.util.Collections.emptyList();
      private void ensurePrevOutputsIsMutable() {
        if (!((bitField0_ & 0x00000004) != 0)) {
          prevOutputs_ = new java.util.ArrayList<signrpc.SignerOuterClass.TxOut>(prevOutputs_);
          bitField0_ |= 0x00000004;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
          signrpc.SignerOuterClass.TxOut, signrpc.SignerOuterClass.TxOut.Builder, signrpc.SignerOuterClass.TxOutOrBuilder> prevOutputsBuilder_;

      /**
       * <pre>
       *
       *The full list of UTXO information for each of the inputs being spent. This
       *is required when spending one or more taproot (SegWit v1) outputs.
       * </pre>
       *
       * <code>repeated .signrpc.TxOut prev_outputs = 3;</code>
       */
      public java.util.List<signrpc.SignerOuterClass.TxOut> getPrevOutputsList() {
        if (prevOutputsBuilder_ == null) {
          return java.util.Collections.unmodifiableList(prevOutputs_);
        } else {
          return prevOutputsBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       *
       *The full list of UTXO information for each of the inputs being spent. This
       *is required when spending one or more taproot (SegWit v1) outputs.
       * </pre>
       *
       * <code>repeated .signrpc.TxOut prev_outputs = 3;</code>
       */
      public int getPrevOutputsCount() {
        if (prevOutputsBuilder_ == null) {
          return prevOutputs_.size();
        } else {
          return prevOutputsBuilder_.getCount();
        }
      }
      /**
       * <pre>
       *
       *The full list of UTXO information for each of the inputs being spent. This
       *is required when spending one or more taproot (SegWit v1) outputs.
       * </pre>
       *
       * <code>repeated .signrpc.TxOut prev_outputs = 3;</code>
       */
      public signrpc.SignerOuterClass.TxOut getPrevOutputs(int index) {
        if (prevOutputsBuilder_ == null) {
          return prevOutputs_.get(index);
        } else {
          return prevOutputsBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       *
       *The full list of UTXO information for each of the inputs being spent. This
       *is required when spending one or more taproot (SegWit v1) outputs.
       * </pre>
       *
       * <code>repeated .signrpc.TxOut prev_outputs = 3;</code>
       */
      public Builder setPrevOutputs(
          int index, signrpc.SignerOuterClass.TxOut value) {
        if (prevOutputsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensurePrevOutputsIsMutable();
          prevOutputs_.set(index, value);
          onChanged();
        } else {
          prevOutputsBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       *
       *The full list of UTXO information for each of the inputs being spent. This
       *is required when spending one or more taproot (SegWit v1) outputs.
       * </pre>
       *
       * <code>repeated .signrpc.TxOut prev_outputs = 3;</code>
       */
      public Builder setPrevOutputs(
          int index, signrpc.SignerOuterClass.TxOut.Builder builderForValue) {
        if (prevOutputsBuilder_ == null) {
          ensurePrevOutputsIsMutable();
          prevOutputs_.set(index, builderForValue.build());
          onChanged();
        } else {
          prevOutputsBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       *
       *The full list of UTXO information for each of the inputs being spent. This
       *is required when spending one or more taproot (SegWit v1) outputs.
       * </pre>
       *
       * <code>repeated .signrpc.TxOut prev_outputs = 3;</code>
       */
      public Builder addPrevOutputs(signrpc.SignerOuterClass.TxOut value) {
        if (prevOutputsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensurePrevOutputsIsMutable();
          prevOutputs_.add(value);
          onChanged();
        } else {
          prevOutputsBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       *
       *The full list of UTXO information for each of the inputs being spent. This
       *is required when spending one or more taproot (SegWit v1) outputs.
       * </pre>
       *
       * <code>repeated .signrpc.TxOut prev_outputs = 3;</code>
       */
      public Builder addPrevOutputs(
          int index, signrpc.SignerOuterClass.TxOut value) {
        if (prevOutputsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensurePrevOutputsIsMutable();
          prevOutputs_.add(index, value);
          onChanged();
        } else {
          prevOutputsBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       *
       *The full list of UTXO information for each of the inputs being spent. This
       *is required when spending one or more taproot (SegWit v1) outputs.
       * </pre>
       *
       * <code>repeated .signrpc.TxOut prev_outputs = 3;</code>
       */
      public Builder addPrevOutputs(
          signrpc.SignerOuterClass.TxOut.Builder builderForValue) {
        if (prevOutputsBuilder_ == null) {
          ensurePrevOutputsIsMutable();
          prevOutputs_.add(builderForValue.build());
          onChanged();
        } else {
          prevOutputsBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       *
       *The full list of UTXO information for each of the inputs being spent. This
       *is required when spending one or more taproot (SegWit v1) outputs.
       * </pre>
       *
       * <code>repeated .signrpc.TxOut prev_outputs = 3;</code>
       */
      public Builder addPrevOutputs(
          int index, signrpc.SignerOuterClass.TxOut.Builder builderForValue) {
        if (prevOutputsBuilder_ == null) {
          ensurePrevOutputsIsMutable();
          prevOutputs_.add(index, builderForValue.build());
          onChanged();
        } else {
          prevOutputsBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       *
       *The full list of UTXO information for each of the inputs being spent. This
       *is required when spending one or more taproot (SegWit v1) outputs.
       * </pre>
       *
       * <code>repeated .signrpc.TxOut prev_outputs = 3;</code>
       */
      public Builder addAllPrevOutputs(
          java.lang.Iterable<? extends signrpc.SignerOuterClass.TxOut> values) {
        if (prevOutputsBuilder_ == null) {
          ensurePrevOutputsIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, prevOutputs_);
          onChanged();
        } else {
          prevOutputsBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       *
       *The full list of UTXO information for each of the inputs being spent. This
       *is required when spending one or more taproot (SegWit v1) outputs.
       * </pre>
       *
       * <code>repeated .signrpc.TxOut prev_outputs = 3;</code>
       */
      public Builder clearPrevOutputs() {
        if (prevOutputsBuilder_ == null) {
          prevOutputs_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000004);
          onChanged();
        } else {
          prevOutputsBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       *
       *The full list of UTXO information for each of the inputs being spent. This
       *is required when spending one or more taproot (SegWit v1) outputs.
       * </pre>
       *
       * <code>repeated .signrpc.TxOut prev_outputs = 3;</code>
       */
      public Builder removePrevOutputs(int index) {
        if (prevOutputsBuilder_ == null) {
          ensurePrevOutputsIsMutable();
          prevOutputs_.remove(index);
          onChanged();
        } else {
          prevOutputsBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       *
       *The full list of UTXO information for each of the inputs being spent. This
       *is required when spending one or more taproot (SegWit v1) outputs.
       * </pre>
       *
       * <code>repeated .signrpc.TxOut prev_outputs = 3;</code>
       */
      public signrpc.SignerOuterClass.TxOut.Builder getPrevOutputsBuilder(
          int index) {
        return getPrevOutputsFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       *
       *The full list of UTXO information for each of the inputs being spent. This
       *is required when spending one or more taproot (SegWit v1) outputs.
       * </pre>
       *
       * <code>repeated .signrpc.TxOut prev_outputs = 3;</code>
       */
      public signrpc.SignerOuterClass.TxOutOrBuilder getPrevOutputsOrBuilder(
          int index) {
        if (prevOutputsBuilder_ == null) {
          return prevOutputs_.get(index);  } else {
          return prevOutputsBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       *
       *The full list of UTXO information for each of the inputs being spent. This
       *is required when spending one or more taproot (SegWit v1) outputs.
       * </pre>
       *
       * <code>repeated .signrpc.TxOut prev_outputs = 3;</code>
       */
      public java.util.List<? extends signrpc.SignerOuterClass.TxOutOrBuilder> 
           getPrevOutputsOrBuilderList() {
        if (prevOutputsBuilder_ != null) {
          return prevOutputsBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(prevOutputs_);
        }
      }
      /**
       * <pre>
       *
       *The full list of UTXO information for each of the inputs being spent. This
       *is required when spending one or more taproot (SegWit v1) outputs.
       * </pre>
       *
       * <code>repeated .signrpc.TxOut prev_outputs = 3;</code>
       */
      public signrpc.SignerOuterClass.TxOut.Builder addPrevOutputsBuilder() {
        return getPrevOutputsFieldBuilder().addBuilder(
            signrpc.SignerOuterClass.TxOut.getDefaultInstance());
      }
      /**
       * <pre>
       *
       *The full list of UTXO information for each of the inputs being spent. This
       *is required when spending one or more taproot (SegWit v1) outputs.
       * </pre>
       *
       * <code>repeated .signrpc.TxOut prev_outputs = 3;</code>
       */
      public signrpc.SignerOuterClass.TxOut.Builder addPrevOutputsBuilder(
          int index) {
        return getPrevOutputsFieldBuilder().addBuilder(
            index, signrpc.SignerOuterClass.TxOut.getDefaultInstance());
      }
      /**
       * <pre>
       *
       *The full list of UTXO information for each of the inputs being spent. This
       *is required when spending one or more taproot (SegWit v1) outputs.
       * </pre>
       *
       * <code>repeated .signrpc.TxOut prev_outputs = 3;</code>
       */
      public java.util.List<signrpc.SignerOuterClass.TxOut.Builder> 
           getPrevOutputsBuilderList() {
        return getPrevOutputsFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilderV3<
          signrpc.SignerOuterClass.TxOut, signrpc.SignerOuterClass.TxOut.Builder, signrpc.SignerOuterClass.TxOutOrBuilder> 
          getPrevOutputsFieldBuilder() {
        if (prevOutputsBuilder_ == null) {
          prevOutputsBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<
              signrpc.SignerOuterClass.TxOut, signrpc.SignerOuterClass.TxOut.Builder, signrpc.SignerOuterClass.TxOutOrBuilder>(
                  prevOutputs_,
                  ((bitField0_ & 0x00000004) != 0),
                  getParentForChildren(),
                  isClean());
          prevOutputs_ = null;
        }
        return prevOutputsBuilder_;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:signrpc.SignReq)
    }

    // @@protoc_insertion_point(class_scope:signrpc.SignReq)
    private static final signrpc.SignerOuterClass.SignReq DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new signrpc.SignerOuterClass.SignReq();
    }

    public static signrpc.SignerOuterClass.SignReq getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<SignReq>
        PARSER = new com.google.protobuf.AbstractParser<SignReq>() {
      @java.lang.Override
      public SignReq parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<SignReq> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<SignReq> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public signrpc.SignerOuterClass.SignReq getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface SignRespOrBuilder extends
      // @@protoc_insertion_point(interface_extends:signrpc.SignResp)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     *
     *A set of signatures realized in a fixed 64-byte format ordered in ascending
     *input order.
     * </pre>
     *
     * <code>repeated bytes raw_sigs = 1;</code>
     * @return A list containing the rawSigs.
     */
    java.util.List<com.google.protobuf.ByteString> getRawSigsList();
    /**
     * <pre>
     *
     *A set of signatures realized in a fixed 64-byte format ordered in ascending
     *input order.
     * </pre>
     *
     * <code>repeated bytes raw_sigs = 1;</code>
     * @return The count of rawSigs.
     */
    int getRawSigsCount();
    /**
     * <pre>
     *
     *A set of signatures realized in a fixed 64-byte format ordered in ascending
     *input order.
     * </pre>
     *
     * <code>repeated bytes raw_sigs = 1;</code>
     * @param index The index of the element to return.
     * @return The rawSigs at the given index.
     */
    com.google.protobuf.ByteString getRawSigs(int index);
  }
  /**
   * Protobuf type {@code signrpc.SignResp}
   */
  public static final class SignResp extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:signrpc.SignResp)
      SignRespOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use SignResp.newBuilder() to construct.
    private SignResp(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private SignResp() {
      rawSigs_ = emptyList(com.google.protobuf.ByteString.class);
    }

    @java.lang.Override
    @SuppressWarnings({"unused"})
    protected java.lang.Object newInstance(
        UnusedPrivateParameter unused) {
      return new SignResp();
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return signrpc.SignerOuterClass.internal_static_signrpc_SignResp_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return signrpc.SignerOuterClass.internal_static_signrpc_SignResp_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              signrpc.SignerOuterClass.SignResp.class, signrpc.SignerOuterClass.SignResp.Builder.class);
    }

    public static final int RAW_SIGS_FIELD_NUMBER = 1;
    @SuppressWarnings("serial")
    private com.google.protobuf.Internal.ProtobufList<com.google.protobuf.ByteString> rawSigs_ =
        emptyList(com.google.protobuf.ByteString.class);
    /**
     * <pre>
     *
     *A set of signatures realized in a fixed 64-byte format ordered in ascending
     *input order.
     * </pre>
     *
     * <code>repeated bytes raw_sigs = 1;</code>
     * @return A list containing the rawSigs.
     */
    @java.lang.Override
    public java.util.List<com.google.protobuf.ByteString>
        getRawSigsList() {
      return rawSigs_;
    }
    /**
     * <pre>
     *
     *A set of signatures realized in a fixed 64-byte format ordered in ascending
     *input order.
     * </pre>
     *
     * <code>repeated bytes raw_sigs = 1;</code>
     * @return The count of rawSigs.
     */
    public int getRawSigsCount() {
      return rawSigs_.size();
    }
    /**
     * <pre>
     *
     *A set of signatures realized in a fixed 64-byte format ordered in ascending
     *input order.
     * </pre>
     *
     * <code>repeated bytes raw_sigs = 1;</code>
     * @param index The index of the element to return.
     * @return The rawSigs at the given index.
     */
    public com.google.protobuf.ByteString getRawSigs(int index) {
      return rawSigs_.get(index);
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      for (int i = 0; i < rawSigs_.size(); i++) {
        output.writeBytes(1, rawSigs_.get(i));
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      {
        int dataSize = 0;
        for (int i = 0; i < rawSigs_.size(); i++) {
          dataSize += com.google.protobuf.CodedOutputStream
            .computeBytesSizeNoTag(rawSigs_.get(i));
        }
        size += dataSize;
        size += 1 * getRawSigsList().size();
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof signrpc.SignerOuterClass.SignResp)) {
        return super.equals(obj);
      }
      signrpc.SignerOuterClass.SignResp other = (signrpc.SignerOuterClass.SignResp) obj;

      if (!getRawSigsList()
          .equals(other.getRawSigsList())) return false;
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (getRawSigsCount() > 0) {
        hash = (37 * hash) + RAW_SIGS_FIELD_NUMBER;
        hash = (53 * hash) + getRawSigsList().hashCode();
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static signrpc.SignerOuterClass.SignResp parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static signrpc.SignerOuterClass.SignResp parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static signrpc.SignerOuterClass.SignResp parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static signrpc.SignerOuterClass.SignResp parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static signrpc.SignerOuterClass.SignResp parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static signrpc.SignerOuterClass.SignResp parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static signrpc.SignerOuterClass.SignResp parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static signrpc.SignerOuterClass.SignResp parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static signrpc.SignerOuterClass.SignResp parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static signrpc.SignerOuterClass.SignResp parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static signrpc.SignerOuterClass.SignResp parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static signrpc.SignerOuterClass.SignResp parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(signrpc.SignerOuterClass.SignResp prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * Protobuf type {@code signrpc.SignResp}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:signrpc.SignResp)
        signrpc.SignerOuterClass.SignRespOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return signrpc.SignerOuterClass.internal_static_signrpc_SignResp_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return signrpc.SignerOuterClass.internal_static_signrpc_SignResp_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                signrpc.SignerOuterClass.SignResp.class, signrpc.SignerOuterClass.SignResp.Builder.class);
      }

      // Construct using signrpc.SignerOuterClass.SignResp.newBuilder()
      private Builder() {

      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);

      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        rawSigs_ = emptyList(com.google.protobuf.ByteString.class);
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return signrpc.SignerOuterClass.internal_static_signrpc_SignResp_descriptor;
      }

      @java.lang.Override
      public signrpc.SignerOuterClass.SignResp getDefaultInstanceForType() {
        return signrpc.SignerOuterClass.SignResp.getDefaultInstance();
      }

      @java.lang.Override
      public signrpc.SignerOuterClass.SignResp build() {
        signrpc.SignerOuterClass.SignResp result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public signrpc.SignerOuterClass.SignResp buildPartial() {
        signrpc.SignerOuterClass.SignResp result = new signrpc.SignerOuterClass.SignResp(this);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartial0(signrpc.SignerOuterClass.SignResp result) {
        int from_bitField0_ = bitField0_;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          rawSigs_.makeImmutable();
          result.rawSigs_ = rawSigs_;
        }
      }

      @java.lang.Override
      public Builder clone() {
        return super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof signrpc.SignerOuterClass.SignResp) {
          return mergeFrom((signrpc.SignerOuterClass.SignResp)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(signrpc.SignerOuterClass.SignResp other) {
        if (other == signrpc.SignerOuterClass.SignResp.getDefaultInstance()) return this;
        if (!other.rawSigs_.isEmpty()) {
          if (rawSigs_.isEmpty()) {
            rawSigs_ = other.rawSigs_;
            rawSigs_.makeImmutable();
            bitField0_ |= 0x00000001;
          } else {
            ensureRawSigsIsMutable();
            rawSigs_.addAll(other.rawSigs_);
          }
          onChanged();
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10: {
                com.google.protobuf.ByteString v = input.readBytes();
                ensureRawSigsIsMutable();
                rawSigs_.add(v);
                break;
              } // case 10
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private com.google.protobuf.Internal.ProtobufList<com.google.protobuf.ByteString> rawSigs_ = emptyList(com.google.protobuf.ByteString.class);
      private void ensureRawSigsIsMutable() {
        if (!rawSigs_.isModifiable()) {
          rawSigs_ = makeMutableCopy(rawSigs_);
        }
        bitField0_ |= 0x00000001;
      }
      /**
       * <pre>
       *
       *A set of signatures realized in a fixed 64-byte format ordered in ascending
       *input order.
       * </pre>
       *
       * <code>repeated bytes raw_sigs = 1;</code>
       * @return A list containing the rawSigs.
       */
      public java.util.List<com.google.protobuf.ByteString>
          getRawSigsList() {
        rawSigs_.makeImmutable();
        return rawSigs_;
      }
      /**
       * <pre>
       *
       *A set of signatures realized in a fixed 64-byte format ordered in ascending
       *input order.
       * </pre>
       *
       * <code>repeated bytes raw_sigs = 1;</code>
       * @return The count of rawSigs.
       */
      public int getRawSigsCount() {
        return rawSigs_.size();
      }
      /**
       * <pre>
       *
       *A set of signatures realized in a fixed 64-byte format ordered in ascending
       *input order.
       * </pre>
       *
       * <code>repeated bytes raw_sigs = 1;</code>
       * @param index The index of the element to return.
       * @return The rawSigs at the given index.
       */
      public com.google.protobuf.ByteString getRawSigs(int index) {
        return rawSigs_.get(index);
      }
      /**
       * <pre>
       *
       *A set of signatures realized in a fixed 64-byte format ordered in ascending
       *input order.
       * </pre>
       *
       * <code>repeated bytes raw_sigs = 1;</code>
       * @param index The index to set the value at.
       * @param value The rawSigs to set.
       * @return This builder for chaining.
       */
      public Builder setRawSigs(
          int index, com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        ensureRawSigsIsMutable();
        rawSigs_.set(index, value);
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       *
       *A set of signatures realized in a fixed 64-byte format ordered in ascending
       *input order.
       * </pre>
       *
       * <code>repeated bytes raw_sigs = 1;</code>
       * @param value The rawSigs to add.
       * @return This builder for chaining.
       */
      public Builder addRawSigs(com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        ensureRawSigsIsMutable();
        rawSigs_.add(value);
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       *
       *A set of signatures realized in a fixed 64-byte format ordered in ascending
       *input order.
       * </pre>
       *
       * <code>repeated bytes raw_sigs = 1;</code>
       * @param values The rawSigs to add.
       * @return This builder for chaining.
       */
      public Builder addAllRawSigs(
          java.lang.Iterable<? extends com.google.protobuf.ByteString> values) {
        ensureRawSigsIsMutable();
        com.google.protobuf.AbstractMessageLite.Builder.addAll(
            values, rawSigs_);
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       *
       *A set of signatures realized in a fixed 64-byte format ordered in ascending
       *input order.
       * </pre>
       *
       * <code>repeated bytes raw_sigs = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearRawSigs() {
        rawSigs_ = emptyList(com.google.protobuf.ByteString.class);
        bitField0_ = (bitField0_ & ~0x00000001);
        onChanged();
        return this;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:signrpc.SignResp)
    }

    // @@protoc_insertion_point(class_scope:signrpc.SignResp)
    private static final signrpc.SignerOuterClass.SignResp DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new signrpc.SignerOuterClass.SignResp();
    }

    public static signrpc.SignerOuterClass.SignResp getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<SignResp>
        PARSER = new com.google.protobuf.AbstractParser<SignResp>() {
      @java.lang.Override
      public SignResp parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<SignResp> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<SignResp> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public signrpc.SignerOuterClass.SignResp getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface InputScriptOrBuilder extends
      // @@protoc_insertion_point(interface_extends:signrpc.InputScript)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * The serializes witness stack for the specified input.
     * </pre>
     *
     * <code>repeated bytes witness = 1;</code>
     * @return A list containing the witness.
     */
    java.util.List<com.google.protobuf.ByteString> getWitnessList();
    /**
     * <pre>
     * The serializes witness stack for the specified input.
     * </pre>
     *
     * <code>repeated bytes witness = 1;</code>
     * @return The count of witness.
     */
    int getWitnessCount();
    /**
     * <pre>
     * The serializes witness stack for the specified input.
     * </pre>
     *
     * <code>repeated bytes witness = 1;</code>
     * @param index The index of the element to return.
     * @return The witness at the given index.
     */
    com.google.protobuf.ByteString getWitness(int index);

    /**
     * <pre>
     *
     *The optional sig script for the specified witness that will only be set if
     *the input specified is a nested p2sh witness program.
     * </pre>
     *
     * <code>bytes sig_script = 2;</code>
     * @return The sigScript.
     */
    com.google.protobuf.ByteString getSigScript();
  }
  /**
   * Protobuf type {@code signrpc.InputScript}
   */
  public static final class InputScript extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:signrpc.InputScript)
      InputScriptOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use InputScript.newBuilder() to construct.
    private InputScript(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private InputScript() {
      witness_ = emptyList(com.google.protobuf.ByteString.class);
      sigScript_ = com.google.protobuf.ByteString.EMPTY;
    }

    @java.lang.Override
    @SuppressWarnings({"unused"})
    protected java.lang.Object newInstance(
        UnusedPrivateParameter unused) {
      return new InputScript();
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return signrpc.SignerOuterClass.internal_static_signrpc_InputScript_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return signrpc.SignerOuterClass.internal_static_signrpc_InputScript_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              signrpc.SignerOuterClass.InputScript.class, signrpc.SignerOuterClass.InputScript.Builder.class);
    }

    public static final int WITNESS_FIELD_NUMBER = 1;
    @SuppressWarnings("serial")
    private com.google.protobuf.Internal.ProtobufList<com.google.protobuf.ByteString> witness_ =
        emptyList(com.google.protobuf.ByteString.class);
    /**
     * <pre>
     * The serializes witness stack for the specified input.
     * </pre>
     *
     * <code>repeated bytes witness = 1;</code>
     * @return A list containing the witness.
     */
    @java.lang.Override
    public java.util.List<com.google.protobuf.ByteString>
        getWitnessList() {
      return witness_;
    }
    /**
     * <pre>
     * The serializes witness stack for the specified input.
     * </pre>
     *
     * <code>repeated bytes witness = 1;</code>
     * @return The count of witness.
     */
    public int getWitnessCount() {
      return witness_.size();
    }
    /**
     * <pre>
     * The serializes witness stack for the specified input.
     * </pre>
     *
     * <code>repeated bytes witness = 1;</code>
     * @param index The index of the element to return.
     * @return The witness at the given index.
     */
    public com.google.protobuf.ByteString getWitness(int index) {
      return witness_.get(index);
    }

    public static final int SIG_SCRIPT_FIELD_NUMBER = 2;
    private com.google.protobuf.ByteString sigScript_ = com.google.protobuf.ByteString.EMPTY;
    /**
     * <pre>
     *
     *The optional sig script for the specified witness that will only be set if
     *the input specified is a nested p2sh witness program.
     * </pre>
     *
     * <code>bytes sig_script = 2;</code>
     * @return The sigScript.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString getSigScript() {
      return sigScript_;
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      for (int i = 0; i < witness_.size(); i++) {
        output.writeBytes(1, witness_.get(i));
      }
      if (!sigScript_.isEmpty()) {
        output.writeBytes(2, sigScript_);
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      {
        int dataSize = 0;
        for (int i = 0; i < witness_.size(); i++) {
          dataSize += com.google.protobuf.CodedOutputStream
            .computeBytesSizeNoTag(witness_.get(i));
        }
        size += dataSize;
        size += 1 * getWitnessList().size();
      }
      if (!sigScript_.isEmpty()) {
        size += com.google.protobuf.CodedOutputStream
          .computeBytesSize(2, sigScript_);
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof signrpc.SignerOuterClass.InputScript)) {
        return super.equals(obj);
      }
      signrpc.SignerOuterClass.InputScript other = (signrpc.SignerOuterClass.InputScript) obj;

      if (!getWitnessList()
          .equals(other.getWitnessList())) return false;
      if (!getSigScript()
          .equals(other.getSigScript())) return false;
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (getWitnessCount() > 0) {
        hash = (37 * hash) + WITNESS_FIELD_NUMBER;
        hash = (53 * hash) + getWitnessList().hashCode();
      }
      hash = (37 * hash) + SIG_SCRIPT_FIELD_NUMBER;
      hash = (53 * hash) + getSigScript().hashCode();
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static signrpc.SignerOuterClass.InputScript parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static signrpc.SignerOuterClass.InputScript parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static signrpc.SignerOuterClass.InputScript parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static signrpc.SignerOuterClass.InputScript parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static signrpc.SignerOuterClass.InputScript parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static signrpc.SignerOuterClass.InputScript parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static signrpc.SignerOuterClass.InputScript parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static signrpc.SignerOuterClass.InputScript parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static signrpc.SignerOuterClass.InputScript parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static signrpc.SignerOuterClass.InputScript parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static signrpc.SignerOuterClass.InputScript parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static signrpc.SignerOuterClass.InputScript parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(signrpc.SignerOuterClass.InputScript prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * Protobuf type {@code signrpc.InputScript}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:signrpc.InputScript)
        signrpc.SignerOuterClass.InputScriptOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return signrpc.SignerOuterClass.internal_static_signrpc_InputScript_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return signrpc.SignerOuterClass.internal_static_signrpc_InputScript_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                signrpc.SignerOuterClass.InputScript.class, signrpc.SignerOuterClass.InputScript.Builder.class);
      }

      // Construct using signrpc.SignerOuterClass.InputScript.newBuilder()
      private Builder() {

      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);

      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        witness_ = emptyList(com.google.protobuf.ByteString.class);
        sigScript_ = com.google.protobuf.ByteString.EMPTY;
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return signrpc.SignerOuterClass.internal_static_signrpc_InputScript_descriptor;
      }

      @java.lang.Override
      public signrpc.SignerOuterClass.InputScript getDefaultInstanceForType() {
        return signrpc.SignerOuterClass.InputScript.getDefaultInstance();
      }

      @java.lang.Override
      public signrpc.SignerOuterClass.InputScript build() {
        signrpc.SignerOuterClass.InputScript result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public signrpc.SignerOuterClass.InputScript buildPartial() {
        signrpc.SignerOuterClass.InputScript result = new signrpc.SignerOuterClass.InputScript(this);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartial0(signrpc.SignerOuterClass.InputScript result) {
        int from_bitField0_ = bitField0_;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          witness_.makeImmutable();
          result.witness_ = witness_;
        }
        if (((from_bitField0_ & 0x00000002) != 0)) {
          result.sigScript_ = sigScript_;
        }
      }

      @java.lang.Override
      public Builder clone() {
        return super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof signrpc.SignerOuterClass.InputScript) {
          return mergeFrom((signrpc.SignerOuterClass.InputScript)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(signrpc.SignerOuterClass.InputScript other) {
        if (other == signrpc.SignerOuterClass.InputScript.getDefaultInstance()) return this;
        if (!other.witness_.isEmpty()) {
          if (witness_.isEmpty()) {
            witness_ = other.witness_;
            witness_.makeImmutable();
            bitField0_ |= 0x00000001;
          } else {
            ensureWitnessIsMutable();
            witness_.addAll(other.witness_);
          }
          onChanged();
        }
        if (other.getSigScript() != com.google.protobuf.ByteString.EMPTY) {
          setSigScript(other.getSigScript());
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10: {
                com.google.protobuf.ByteString v = input.readBytes();
                ensureWitnessIsMutable();
                witness_.add(v);
                break;
              } // case 10
              case 18: {
                sigScript_ = input.readBytes();
                bitField0_ |= 0x00000002;
                break;
              } // case 18
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private com.google.protobuf.Internal.ProtobufList<com.google.protobuf.ByteString> witness_ = emptyList(com.google.protobuf.ByteString.class);
      private void ensureWitnessIsMutable() {
        if (!witness_.isModifiable()) {
          witness_ = makeMutableCopy(witness_);
        }
        bitField0_ |= 0x00000001;
      }
      /**
       * <pre>
       * The serializes witness stack for the specified input.
       * </pre>
       *
       * <code>repeated bytes witness = 1;</code>
       * @return A list containing the witness.
       */
      public java.util.List<com.google.protobuf.ByteString>
          getWitnessList() {
        witness_.makeImmutable();
        return witness_;
      }
      /**
       * <pre>
       * The serializes witness stack for the specified input.
       * </pre>
       *
       * <code>repeated bytes witness = 1;</code>
       * @return The count of witness.
       */
      public int getWitnessCount() {
        return witness_.size();
      }
      /**
       * <pre>
       * The serializes witness stack for the specified input.
       * </pre>
       *
       * <code>repeated bytes witness = 1;</code>
       * @param index The index of the element to return.
       * @return The witness at the given index.
       */
      public com.google.protobuf.ByteString getWitness(int index) {
        return witness_.get(index);
      }
      /**
       * <pre>
       * The serializes witness stack for the specified input.
       * </pre>
       *
       * <code>repeated bytes witness = 1;</code>
       * @param index The index to set the value at.
       * @param value The witness to set.
       * @return This builder for chaining.
       */
      public Builder setWitness(
          int index, com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        ensureWitnessIsMutable();
        witness_.set(index, value);
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The serializes witness stack for the specified input.
       * </pre>
       *
       * <code>repeated bytes witness = 1;</code>
       * @param value The witness to add.
       * @return This builder for chaining.
       */
      public Builder addWitness(com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        ensureWitnessIsMutable();
        witness_.add(value);
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The serializes witness stack for the specified input.
       * </pre>
       *
       * <code>repeated bytes witness = 1;</code>
       * @param values The witness to add.
       * @return This builder for chaining.
       */
      public Builder addAllWitness(
          java.lang.Iterable<? extends com.google.protobuf.ByteString> values) {
        ensureWitnessIsMutable();
        com.google.protobuf.AbstractMessageLite.Builder.addAll(
            values, witness_);
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The serializes witness stack for the specified input.
       * </pre>
       *
       * <code>repeated bytes witness = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearWitness() {
        witness_ = emptyList(com.google.protobuf.ByteString.class);
        bitField0_ = (bitField0_ & ~0x00000001);
        onChanged();
        return this;
      }

      private com.google.protobuf.ByteString sigScript_ = com.google.protobuf.ByteString.EMPTY;
      /**
       * <pre>
       *
       *The optional sig script for the specified witness that will only be set if
       *the input specified is a nested p2sh witness program.
       * </pre>
       *
       * <code>bytes sig_script = 2;</code>
       * @return The sigScript.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString getSigScript() {
        return sigScript_;
      }
      /**
       * <pre>
       *
       *The optional sig script for the specified witness that will only be set if
       *the input specified is a nested p2sh witness program.
       * </pre>
       *
       * <code>bytes sig_script = 2;</code>
       * @param value The sigScript to set.
       * @return This builder for chaining.
       */
      public Builder setSigScript(com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        sigScript_ = value;
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       *
       *The optional sig script for the specified witness that will only be set if
       *the input specified is a nested p2sh witness program.
       * </pre>
       *
       * <code>bytes sig_script = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearSigScript() {
        bitField0_ = (bitField0_ & ~0x00000002);
        sigScript_ = getDefaultInstance().getSigScript();
        onChanged();
        return this;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:signrpc.InputScript)
    }

    // @@protoc_insertion_point(class_scope:signrpc.InputScript)
    private static final signrpc.SignerOuterClass.InputScript DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new signrpc.SignerOuterClass.InputScript();
    }

    public static signrpc.SignerOuterClass.InputScript getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<InputScript>
        PARSER = new com.google.protobuf.AbstractParser<InputScript>() {
      @java.lang.Override
      public InputScript parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<InputScript> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<InputScript> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public signrpc.SignerOuterClass.InputScript getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface InputScriptRespOrBuilder extends
      // @@protoc_insertion_point(interface_extends:signrpc.InputScriptResp)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * The set of fully valid input scripts requested.
     * </pre>
     *
     * <code>repeated .signrpc.InputScript input_scripts = 1;</code>
     */
    java.util.List<signrpc.SignerOuterClass.InputScript> 
        getInputScriptsList();
    /**
     * <pre>
     * The set of fully valid input scripts requested.
     * </pre>
     *
     * <code>repeated .signrpc.InputScript input_scripts = 1;</code>
     */
    signrpc.SignerOuterClass.InputScript getInputScripts(int index);
    /**
     * <pre>
     * The set of fully valid input scripts requested.
     * </pre>
     *
     * <code>repeated .signrpc.InputScript input_scripts = 1;</code>
     */
    int getInputScriptsCount();
    /**
     * <pre>
     * The set of fully valid input scripts requested.
     * </pre>
     *
     * <code>repeated .signrpc.InputScript input_scripts = 1;</code>
     */
    java.util.List<? extends signrpc.SignerOuterClass.InputScriptOrBuilder> 
        getInputScriptsOrBuilderList();
    /**
     * <pre>
     * The set of fully valid input scripts requested.
     * </pre>
     *
     * <code>repeated .signrpc.InputScript input_scripts = 1;</code>
     */
    signrpc.SignerOuterClass.InputScriptOrBuilder getInputScriptsOrBuilder(
        int index);
  }
  /**
   * Protobuf type {@code signrpc.InputScriptResp}
   */
  public static final class InputScriptResp extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:signrpc.InputScriptResp)
      InputScriptRespOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use InputScriptResp.newBuilder() to construct.
    private InputScriptResp(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private InputScriptResp() {
      inputScripts_ = java.util.Collections.emptyList();
    }

    @java.lang.Override
    @SuppressWarnings({"unused"})
    protected java.lang.Object newInstance(
        UnusedPrivateParameter unused) {
      return new InputScriptResp();
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return signrpc.SignerOuterClass.internal_static_signrpc_InputScriptResp_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return signrpc.SignerOuterClass.internal_static_signrpc_InputScriptResp_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              signrpc.SignerOuterClass.InputScriptResp.class, signrpc.SignerOuterClass.InputScriptResp.Builder.class);
    }

    public static final int INPUT_SCRIPTS_FIELD_NUMBER = 1;
    @SuppressWarnings("serial")
    private java.util.List<signrpc.SignerOuterClass.InputScript> inputScripts_;
    /**
     * <pre>
     * The set of fully valid input scripts requested.
     * </pre>
     *
     * <code>repeated .signrpc.InputScript input_scripts = 1;</code>
     */
    @java.lang.Override
    public java.util.List<signrpc.SignerOuterClass.InputScript> getInputScriptsList() {
      return inputScripts_;
    }
    /**
     * <pre>
     * The set of fully valid input scripts requested.
     * </pre>
     *
     * <code>repeated .signrpc.InputScript input_scripts = 1;</code>
     */
    @java.lang.Override
    public java.util.List<? extends signrpc.SignerOuterClass.InputScriptOrBuilder> 
        getInputScriptsOrBuilderList() {
      return inputScripts_;
    }
    /**
     * <pre>
     * The set of fully valid input scripts requested.
     * </pre>
     *
     * <code>repeated .signrpc.InputScript input_scripts = 1;</code>
     */
    @java.lang.Override
    public int getInputScriptsCount() {
      return inputScripts_.size();
    }
    /**
     * <pre>
     * The set of fully valid input scripts requested.
     * </pre>
     *
     * <code>repeated .signrpc.InputScript input_scripts = 1;</code>
     */
    @java.lang.Override
    public signrpc.SignerOuterClass.InputScript getInputScripts(int index) {
      return inputScripts_.get(index);
    }
    /**
     * <pre>
     * The set of fully valid input scripts requested.
     * </pre>
     *
     * <code>repeated .signrpc.InputScript input_scripts = 1;</code>
     */
    @java.lang.Override
    public signrpc.SignerOuterClass.InputScriptOrBuilder getInputScriptsOrBuilder(
        int index) {
      return inputScripts_.get(index);
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      for (int i = 0; i < inputScripts_.size(); i++) {
        output.writeMessage(1, inputScripts_.get(i));
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      for (int i = 0; i < inputScripts_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(1, inputScripts_.get(i));
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof signrpc.SignerOuterClass.InputScriptResp)) {
        return super.equals(obj);
      }
      signrpc.SignerOuterClass.InputScriptResp other = (signrpc.SignerOuterClass.InputScriptResp) obj;

      if (!getInputScriptsList()
          .equals(other.getInputScriptsList())) return false;
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (getInputScriptsCount() > 0) {
        hash = (37 * hash) + INPUT_SCRIPTS_FIELD_NUMBER;
        hash = (53 * hash) + getInputScriptsList().hashCode();
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static signrpc.SignerOuterClass.InputScriptResp parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static signrpc.SignerOuterClass.InputScriptResp parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static signrpc.SignerOuterClass.InputScriptResp parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static signrpc.SignerOuterClass.InputScriptResp parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static signrpc.SignerOuterClass.InputScriptResp parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static signrpc.SignerOuterClass.InputScriptResp parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static signrpc.SignerOuterClass.InputScriptResp parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static signrpc.SignerOuterClass.InputScriptResp parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static signrpc.SignerOuterClass.InputScriptResp parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static signrpc.SignerOuterClass.InputScriptResp parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static signrpc.SignerOuterClass.InputScriptResp parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static signrpc.SignerOuterClass.InputScriptResp parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(signrpc.SignerOuterClass.InputScriptResp prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * Protobuf type {@code signrpc.InputScriptResp}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:signrpc.InputScriptResp)
        signrpc.SignerOuterClass.InputScriptRespOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return signrpc.SignerOuterClass.internal_static_signrpc_InputScriptResp_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return signrpc.SignerOuterClass.internal_static_signrpc_InputScriptResp_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                signrpc.SignerOuterClass.InputScriptResp.class, signrpc.SignerOuterClass.InputScriptResp.Builder.class);
      }

      // Construct using signrpc.SignerOuterClass.InputScriptResp.newBuilder()
      private Builder() {

      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);

      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        if (inputScriptsBuilder_ == null) {
          inputScripts_ = java.util.Collections.emptyList();
        } else {
          inputScripts_ = null;
          inputScriptsBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000001);
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return signrpc.SignerOuterClass.internal_static_signrpc_InputScriptResp_descriptor;
      }

      @java.lang.Override
      public signrpc.SignerOuterClass.InputScriptResp getDefaultInstanceForType() {
        return signrpc.SignerOuterClass.InputScriptResp.getDefaultInstance();
      }

      @java.lang.Override
      public signrpc.SignerOuterClass.InputScriptResp build() {
        signrpc.SignerOuterClass.InputScriptResp result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public signrpc.SignerOuterClass.InputScriptResp buildPartial() {
        signrpc.SignerOuterClass.InputScriptResp result = new signrpc.SignerOuterClass.InputScriptResp(this);
        buildPartialRepeatedFields(result);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartialRepeatedFields(signrpc.SignerOuterClass.InputScriptResp result) {
        if (inputScriptsBuilder_ == null) {
          if (((bitField0_ & 0x00000001) != 0)) {
            inputScripts_ = java.util.Collections.unmodifiableList(inputScripts_);
            bitField0_ = (bitField0_ & ~0x00000001);
          }
          result.inputScripts_ = inputScripts_;
        } else {
          result.inputScripts_ = inputScriptsBuilder_.build();
        }
      }

      private void buildPartial0(signrpc.SignerOuterClass.InputScriptResp result) {
        int from_bitField0_ = bitField0_;
      }

      @java.lang.Override
      public Builder clone() {
        return super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof signrpc.SignerOuterClass.InputScriptResp) {
          return mergeFrom((signrpc.SignerOuterClass.InputScriptResp)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(signrpc.SignerOuterClass.InputScriptResp other) {
        if (other == signrpc.SignerOuterClass.InputScriptResp.getDefaultInstance()) return this;
        if (inputScriptsBuilder_ == null) {
          if (!other.inputScripts_.isEmpty()) {
            if (inputScripts_.isEmpty()) {
              inputScripts_ = other.inputScripts_;
              bitField0_ = (bitField0_ & ~0x00000001);
            } else {
              ensureInputScriptsIsMutable();
              inputScripts_.addAll(other.inputScripts_);
            }
            onChanged();
          }
        } else {
          if (!other.inputScripts_.isEmpty()) {
            if (inputScriptsBuilder_.isEmpty()) {
              inputScriptsBuilder_.dispose();
              inputScriptsBuilder_ = null;
              inputScripts_ = other.inputScripts_;
              bitField0_ = (bitField0_ & ~0x00000001);
              inputScriptsBuilder_ = 
                com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
                   getInputScriptsFieldBuilder() : null;
            } else {
              inputScriptsBuilder_.addAllMessages(other.inputScripts_);
            }
          }
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10: {
                signrpc.SignerOuterClass.InputScript m =
                    input.readMessage(
                        signrpc.SignerOuterClass.InputScript.parser(),
                        extensionRegistry);
                if (inputScriptsBuilder_ == null) {
                  ensureInputScriptsIsMutable();
                  inputScripts_.add(m);
                } else {
                  inputScriptsBuilder_.addMessage(m);
                }
                break;
              } // case 10
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private java.util.List<signrpc.SignerOuterClass.InputScript> inputScripts_ =
        java.util.Collections.emptyList();
      private void ensureInputScriptsIsMutable() {
        if (!((bitField0_ & 0x00000001) != 0)) {
          inputScripts_ = new java.util.ArrayList<signrpc.SignerOuterClass.InputScript>(inputScripts_);
          bitField0_ |= 0x00000001;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
          signrpc.SignerOuterClass.InputScript, signrpc.SignerOuterClass.InputScript.Builder, signrpc.SignerOuterClass.InputScriptOrBuilder> inputScriptsBuilder_;

      /**
       * <pre>
       * The set of fully valid input scripts requested.
       * </pre>
       *
       * <code>repeated .signrpc.InputScript input_scripts = 1;</code>
       */
      public java.util.List<signrpc.SignerOuterClass.InputScript> getInputScriptsList() {
        if (inputScriptsBuilder_ == null) {
          return java.util.Collections.unmodifiableList(inputScripts_);
        } else {
          return inputScriptsBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       * The set of fully valid input scripts requested.
       * </pre>
       *
       * <code>repeated .signrpc.InputScript input_scripts = 1;</code>
       */
      public int getInputScriptsCount() {
        if (inputScriptsBuilder_ == null) {
          return inputScripts_.size();
        } else {
          return inputScriptsBuilder_.getCount();
        }
      }
      /**
       * <pre>
       * The set of fully valid input scripts requested.
       * </pre>
       *
       * <code>repeated .signrpc.InputScript input_scripts = 1;</code>
       */
      public signrpc.SignerOuterClass.InputScript getInputScripts(int index) {
        if (inputScriptsBuilder_ == null) {
          return inputScripts_.get(index);
        } else {
          return inputScriptsBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       * The set of fully valid input scripts requested.
       * </pre>
       *
       * <code>repeated .signrpc.InputScript input_scripts = 1;</code>
       */
      public Builder setInputScripts(
          int index, signrpc.SignerOuterClass.InputScript value) {
        if (inputScriptsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureInputScriptsIsMutable();
          inputScripts_.set(index, value);
          onChanged();
        } else {
          inputScriptsBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * The set of fully valid input scripts requested.
       * </pre>
       *
       * <code>repeated .signrpc.InputScript input_scripts = 1;</code>
       */
      public Builder setInputScripts(
          int index, signrpc.SignerOuterClass.InputScript.Builder builderForValue) {
        if (inputScriptsBuilder_ == null) {
          ensureInputScriptsIsMutable();
          inputScripts_.set(index, builderForValue.build());
          onChanged();
        } else {
          inputScriptsBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * The set of fully valid input scripts requested.
       * </pre>
       *
       * <code>repeated .signrpc.InputScript input_scripts = 1;</code>
       */
      public Builder addInputScripts(signrpc.SignerOuterClass.InputScript value) {
        if (inputScriptsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureInputScriptsIsMutable();
          inputScripts_.add(value);
          onChanged();
        } else {
          inputScriptsBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       * The set of fully valid input scripts requested.
       * </pre>
       *
       * <code>repeated .signrpc.InputScript input_scripts = 1;</code>
       */
      public Builder addInputScripts(
          int index, signrpc.SignerOuterClass.InputScript value) {
        if (inputScriptsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureInputScriptsIsMutable();
          inputScripts_.add(index, value);
          onChanged();
        } else {
          inputScriptsBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * The set of fully valid input scripts requested.
       * </pre>
       *
       * <code>repeated .signrpc.InputScript input_scripts = 1;</code>
       */
      public Builder addInputScripts(
          signrpc.SignerOuterClass.InputScript.Builder builderForValue) {
        if (inputScriptsBuilder_ == null) {
          ensureInputScriptsIsMutable();
          inputScripts_.add(builderForValue.build());
          onChanged();
        } else {
          inputScriptsBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * The set of fully valid input scripts requested.
       * </pre>
       *
       * <code>repeated .signrpc.InputScript input_scripts = 1;</code>
       */
      public Builder addInputScripts(
          int index, signrpc.SignerOuterClass.InputScript.Builder builderForValue) {
        if (inputScriptsBuilder_ == null) {
          ensureInputScriptsIsMutable();
          inputScripts_.add(index, builderForValue.build());
          onChanged();
        } else {
          inputScriptsBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * The set of fully valid input scripts requested.
       * </pre>
       *
       * <code>repeated .signrpc.InputScript input_scripts = 1;</code>
       */
      public Builder addAllInputScripts(
          java.lang.Iterable<? extends signrpc.SignerOuterClass.InputScript> values) {
        if (inputScriptsBuilder_ == null) {
          ensureInputScriptsIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, inputScripts_);
          onChanged();
        } else {
          inputScriptsBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       * The set of fully valid input scripts requested.
       * </pre>
       *
       * <code>repeated .signrpc.InputScript input_scripts = 1;</code>
       */
      public Builder clearInputScripts() {
        if (inputScriptsBuilder_ == null) {
          inputScripts_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000001);
          onChanged();
        } else {
          inputScriptsBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * The set of fully valid input scripts requested.
       * </pre>
       *
       * <code>repeated .signrpc.InputScript input_scripts = 1;</code>
       */
      public Builder removeInputScripts(int index) {
        if (inputScriptsBuilder_ == null) {
          ensureInputScriptsIsMutable();
          inputScripts_.remove(index);
          onChanged();
        } else {
          inputScriptsBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       * The set of fully valid input scripts requested.
       * </pre>
       *
       * <code>repeated .signrpc.InputScript input_scripts = 1;</code>
       */
      public signrpc.SignerOuterClass.InputScript.Builder getInputScriptsBuilder(
          int index) {
        return getInputScriptsFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       * The set of fully valid input scripts requested.
       * </pre>
       *
       * <code>repeated .signrpc.InputScript input_scripts = 1;</code>
       */
      public signrpc.SignerOuterClass.InputScriptOrBuilder getInputScriptsOrBuilder(
          int index) {
        if (inputScriptsBuilder_ == null) {
          return inputScripts_.get(index);  } else {
          return inputScriptsBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       * The set of fully valid input scripts requested.
       * </pre>
       *
       * <code>repeated .signrpc.InputScript input_scripts = 1;</code>
       */
      public java.util.List<? extends signrpc.SignerOuterClass.InputScriptOrBuilder> 
           getInputScriptsOrBuilderList() {
        if (inputScriptsBuilder_ != null) {
          return inputScriptsBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(inputScripts_);
        }
      }
      /**
       * <pre>
       * The set of fully valid input scripts requested.
       * </pre>
       *
       * <code>repeated .signrpc.InputScript input_scripts = 1;</code>
       */
      public signrpc.SignerOuterClass.InputScript.Builder addInputScriptsBuilder() {
        return getInputScriptsFieldBuilder().addBuilder(
            signrpc.SignerOuterClass.InputScript.getDefaultInstance());
      }
      /**
       * <pre>
       * The set of fully valid input scripts requested.
       * </pre>
       *
       * <code>repeated .signrpc.InputScript input_scripts = 1;</code>
       */
      public signrpc.SignerOuterClass.InputScript.Builder addInputScriptsBuilder(
          int index) {
        return getInputScriptsFieldBuilder().addBuilder(
            index, signrpc.SignerOuterClass.InputScript.getDefaultInstance());
      }
      /**
       * <pre>
       * The set of fully valid input scripts requested.
       * </pre>
       *
       * <code>repeated .signrpc.InputScript input_scripts = 1;</code>
       */
      public java.util.List<signrpc.SignerOuterClass.InputScript.Builder> 
           getInputScriptsBuilderList() {
        return getInputScriptsFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilderV3<
          signrpc.SignerOuterClass.InputScript, signrpc.SignerOuterClass.InputScript.Builder, signrpc.SignerOuterClass.InputScriptOrBuilder> 
          getInputScriptsFieldBuilder() {
        if (inputScriptsBuilder_ == null) {
          inputScriptsBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<
              signrpc.SignerOuterClass.InputScript, signrpc.SignerOuterClass.InputScript.Builder, signrpc.SignerOuterClass.InputScriptOrBuilder>(
                  inputScripts_,
                  ((bitField0_ & 0x00000001) != 0),
                  getParentForChildren(),
                  isClean());
          inputScripts_ = null;
        }
        return inputScriptsBuilder_;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:signrpc.InputScriptResp)
    }

    // @@protoc_insertion_point(class_scope:signrpc.InputScriptResp)
    private static final signrpc.SignerOuterClass.InputScriptResp DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new signrpc.SignerOuterClass.InputScriptResp();
    }

    public static signrpc.SignerOuterClass.InputScriptResp getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<InputScriptResp>
        PARSER = new com.google.protobuf.AbstractParser<InputScriptResp>() {
      @java.lang.Override
      public InputScriptResp parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<InputScriptResp> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<InputScriptResp> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public signrpc.SignerOuterClass.InputScriptResp getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface SignMessageReqOrBuilder extends
      // @@protoc_insertion_point(interface_extends:signrpc.SignMessageReq)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     *
     *The message to be signed. When using REST, this field must be encoded as
     *base64.
     * </pre>
     *
     * <code>bytes msg = 1;</code>
     * @return The msg.
     */
    com.google.protobuf.ByteString getMsg();

    /**
     * <pre>
     * The key locator that identifies which key to use for signing.
     * </pre>
     *
     * <code>.signrpc.KeyLocator key_loc = 2;</code>
     * @return Whether the keyLoc field is set.
     */
    boolean hasKeyLoc();
    /**
     * <pre>
     * The key locator that identifies which key to use for signing.
     * </pre>
     *
     * <code>.signrpc.KeyLocator key_loc = 2;</code>
     * @return The keyLoc.
     */
    signrpc.SignerOuterClass.KeyLocator getKeyLoc();
    /**
     * <pre>
     * The key locator that identifies which key to use for signing.
     * </pre>
     *
     * <code>.signrpc.KeyLocator key_loc = 2;</code>
     */
    signrpc.SignerOuterClass.KeyLocatorOrBuilder getKeyLocOrBuilder();

    /**
     * <pre>
     * Double-SHA256 hash instead of just the default single round.
     * </pre>
     *
     * <code>bool double_hash = 3;</code>
     * @return The doubleHash.
     */
    boolean getDoubleHash();

    /**
     * <pre>
     *
     *Use the compact (pubkey recoverable) format instead of the raw lnwire
     *format. This option cannot be used with Schnorr signatures.
     * </pre>
     *
     * <code>bool compact_sig = 4;</code>
     * @return The compactSig.
     */
    boolean getCompactSig();

    /**
     * <pre>
     *
     *Use Schnorr signature. This option cannot be used with compact format.
     * </pre>
     *
     * <code>bool schnorr_sig = 5;</code>
     * @return The schnorrSig.
     */
    boolean getSchnorrSig();

    /**
     * <pre>
     *
     *The optional Taproot tweak bytes to apply to the private key before creating
     *a Schnorr signature. The private key is tweaked as described in BIP-341:
     *privKey + h_tapTweak(internalKey || tapTweak)
     * </pre>
     *
     * <code>bytes schnorr_sig_tap_tweak = 6;</code>
     * @return The schnorrSigTapTweak.
     */
    com.google.protobuf.ByteString getSchnorrSigTapTweak();
  }
  /**
   * Protobuf type {@code signrpc.SignMessageReq}
   */
  public static final class SignMessageReq extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:signrpc.SignMessageReq)
      SignMessageReqOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use SignMessageReq.newBuilder() to construct.
    private SignMessageReq(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private SignMessageReq() {
      msg_ = com.google.protobuf.ByteString.EMPTY;
      schnorrSigTapTweak_ = com.google.protobuf.ByteString.EMPTY;
    }

    @java.lang.Override
    @SuppressWarnings({"unused"})
    protected java.lang.Object newInstance(
        UnusedPrivateParameter unused) {
      return new SignMessageReq();
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return signrpc.SignerOuterClass.internal_static_signrpc_SignMessageReq_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return signrpc.SignerOuterClass.internal_static_signrpc_SignMessageReq_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              signrpc.SignerOuterClass.SignMessageReq.class, signrpc.SignerOuterClass.SignMessageReq.Builder.class);
    }

    private int bitField0_;
    public static final int MSG_FIELD_NUMBER = 1;
    private com.google.protobuf.ByteString msg_ = com.google.protobuf.ByteString.EMPTY;
    /**
     * <pre>
     *
     *The message to be signed. When using REST, this field must be encoded as
     *base64.
     * </pre>
     *
     * <code>bytes msg = 1;</code>
     * @return The msg.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString getMsg() {
      return msg_;
    }

    public static final int KEY_LOC_FIELD_NUMBER = 2;
    private signrpc.SignerOuterClass.KeyLocator keyLoc_;
    /**
     * <pre>
     * The key locator that identifies which key to use for signing.
     * </pre>
     *
     * <code>.signrpc.KeyLocator key_loc = 2;</code>
     * @return Whether the keyLoc field is set.
     */
    @java.lang.Override
    public boolean hasKeyLoc() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * The key locator that identifies which key to use for signing.
     * </pre>
     *
     * <code>.signrpc.KeyLocator key_loc = 2;</code>
     * @return The keyLoc.
     */
    @java.lang.Override
    public signrpc.SignerOuterClass.KeyLocator getKeyLoc() {
      return keyLoc_ == null ? signrpc.SignerOuterClass.KeyLocator.getDefaultInstance() : keyLoc_;
    }
    /**
     * <pre>
     * The key locator that identifies which key to use for signing.
     * </pre>
     *
     * <code>.signrpc.KeyLocator key_loc = 2;</code>
     */
    @java.lang.Override
    public signrpc.SignerOuterClass.KeyLocatorOrBuilder getKeyLocOrBuilder() {
      return keyLoc_ == null ? signrpc.SignerOuterClass.KeyLocator.getDefaultInstance() : keyLoc_;
    }

    public static final int DOUBLE_HASH_FIELD_NUMBER = 3;
    private boolean doubleHash_ = false;
    /**
     * <pre>
     * Double-SHA256 hash instead of just the default single round.
     * </pre>
     *
     * <code>bool double_hash = 3;</code>
     * @return The doubleHash.
     */
    @java.lang.Override
    public boolean getDoubleHash() {
      return doubleHash_;
    }

    public static final int COMPACT_SIG_FIELD_NUMBER = 4;
    private boolean compactSig_ = false;
    /**
     * <pre>
     *
     *Use the compact (pubkey recoverable) format instead of the raw lnwire
     *format. This option cannot be used with Schnorr signatures.
     * </pre>
     *
     * <code>bool compact_sig = 4;</code>
     * @return The compactSig.
     */
    @java.lang.Override
    public boolean getCompactSig() {
      return compactSig_;
    }

    public static final int SCHNORR_SIG_FIELD_NUMBER = 5;
    private boolean schnorrSig_ = false;
    /**
     * <pre>
     *
     *Use Schnorr signature. This option cannot be used with compact format.
     * </pre>
     *
     * <code>bool schnorr_sig = 5;</code>
     * @return The schnorrSig.
     */
    @java.lang.Override
    public boolean getSchnorrSig() {
      return schnorrSig_;
    }

    public static final int SCHNORR_SIG_TAP_TWEAK_FIELD_NUMBER = 6;
    private com.google.protobuf.ByteString schnorrSigTapTweak_ = com.google.protobuf.ByteString.EMPTY;
    /**
     * <pre>
     *
     *The optional Taproot tweak bytes to apply to the private key before creating
     *a Schnorr signature. The private key is tweaked as described in BIP-341:
     *privKey + h_tapTweak(internalKey || tapTweak)
     * </pre>
     *
     * <code>bytes schnorr_sig_tap_tweak = 6;</code>
     * @return The schnorrSigTapTweak.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString getSchnorrSigTapTweak() {
      return schnorrSigTapTweak_;
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (!msg_.isEmpty()) {
        output.writeBytes(1, msg_);
      }
      if (((bitField0_ & 0x00000001) != 0)) {
        output.writeMessage(2, getKeyLoc());
      }
      if (doubleHash_ != false) {
        output.writeBool(3, doubleHash_);
      }
      if (compactSig_ != false) {
        output.writeBool(4, compactSig_);
      }
      if (schnorrSig_ != false) {
        output.writeBool(5, schnorrSig_);
      }
      if (!schnorrSigTapTweak_.isEmpty()) {
        output.writeBytes(6, schnorrSigTapTweak_);
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (!msg_.isEmpty()) {
        size += com.google.protobuf.CodedOutputStream
          .computeBytesSize(1, msg_);
      }
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(2, getKeyLoc());
      }
      if (doubleHash_ != false) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(3, doubleHash_);
      }
      if (compactSig_ != false) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(4, compactSig_);
      }
      if (schnorrSig_ != false) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(5, schnorrSig_);
      }
      if (!schnorrSigTapTweak_.isEmpty()) {
        size += com.google.protobuf.CodedOutputStream
          .computeBytesSize(6, schnorrSigTapTweak_);
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof signrpc.SignerOuterClass.SignMessageReq)) {
        return super.equals(obj);
      }
      signrpc.SignerOuterClass.SignMessageReq other = (signrpc.SignerOuterClass.SignMessageReq) obj;

      if (!getMsg()
          .equals(other.getMsg())) return false;
      if (hasKeyLoc() != other.hasKeyLoc()) return false;
      if (hasKeyLoc()) {
        if (!getKeyLoc()
            .equals(other.getKeyLoc())) return false;
      }
      if (getDoubleHash()
          != other.getDoubleHash()) return false;
      if (getCompactSig()
          != other.getCompactSig()) return false;
      if (getSchnorrSig()
          != other.getSchnorrSig()) return false;
      if (!getSchnorrSigTapTweak()
          .equals(other.getSchnorrSigTapTweak())) return false;
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      hash = (37 * hash) + MSG_FIELD_NUMBER;
      hash = (53 * hash) + getMsg().hashCode();
      if (hasKeyLoc()) {
        hash = (37 * hash) + KEY_LOC_FIELD_NUMBER;
        hash = (53 * hash) + getKeyLoc().hashCode();
      }
      hash = (37 * hash) + DOUBLE_HASH_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
          getDoubleHash());
      hash = (37 * hash) + COMPACT_SIG_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
          getCompactSig());
      hash = (37 * hash) + SCHNORR_SIG_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
          getSchnorrSig());
      hash = (37 * hash) + SCHNORR_SIG_TAP_TWEAK_FIELD_NUMBER;
      hash = (53 * hash) + getSchnorrSigTapTweak().hashCode();
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static signrpc.SignerOuterClass.SignMessageReq parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static signrpc.SignerOuterClass.SignMessageReq parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static signrpc.SignerOuterClass.SignMessageReq parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static signrpc.SignerOuterClass.SignMessageReq parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static signrpc.SignerOuterClass.SignMessageReq parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static signrpc.SignerOuterClass.SignMessageReq parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static signrpc.SignerOuterClass.SignMessageReq parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static signrpc.SignerOuterClass.SignMessageReq parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static signrpc.SignerOuterClass.SignMessageReq parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static signrpc.SignerOuterClass.SignMessageReq parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static signrpc.SignerOuterClass.SignMessageReq parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static signrpc.SignerOuterClass.SignMessageReq parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(signrpc.SignerOuterClass.SignMessageReq prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * Protobuf type {@code signrpc.SignMessageReq}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:signrpc.SignMessageReq)
        signrpc.SignerOuterClass.SignMessageReqOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return signrpc.SignerOuterClass.internal_static_signrpc_SignMessageReq_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return signrpc.SignerOuterClass.internal_static_signrpc_SignMessageReq_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                signrpc.SignerOuterClass.SignMessageReq.class, signrpc.SignerOuterClass.SignMessageReq.Builder.class);
      }

      // Construct using signrpc.SignerOuterClass.SignMessageReq.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
          getKeyLocFieldBuilder();
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        msg_ = com.google.protobuf.ByteString.EMPTY;
        keyLoc_ = null;
        if (keyLocBuilder_ != null) {
          keyLocBuilder_.dispose();
          keyLocBuilder_ = null;
        }
        doubleHash_ = false;
        compactSig_ = false;
        schnorrSig_ = false;
        schnorrSigTapTweak_ = com.google.protobuf.ByteString.EMPTY;
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return signrpc.SignerOuterClass.internal_static_signrpc_SignMessageReq_descriptor;
      }

      @java.lang.Override
      public signrpc.SignerOuterClass.SignMessageReq getDefaultInstanceForType() {
        return signrpc.SignerOuterClass.SignMessageReq.getDefaultInstance();
      }

      @java.lang.Override
      public signrpc.SignerOuterClass.SignMessageReq build() {
        signrpc.SignerOuterClass.SignMessageReq result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public signrpc.SignerOuterClass.SignMessageReq buildPartial() {
        signrpc.SignerOuterClass.SignMessageReq result = new signrpc.SignerOuterClass.SignMessageReq(this);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartial0(signrpc.SignerOuterClass.SignMessageReq result) {
        int from_bitField0_ = bitField0_;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.msg_ = msg_;
        }
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000002) != 0)) {
          result.keyLoc_ = keyLocBuilder_ == null
              ? keyLoc_
              : keyLocBuilder_.build();
          to_bitField0_ |= 0x00000001;
        }
        if (((from_bitField0_ & 0x00000004) != 0)) {
          result.doubleHash_ = doubleHash_;
        }
        if (((from_bitField0_ & 0x00000008) != 0)) {
          result.compactSig_ = compactSig_;
        }
        if (((from_bitField0_ & 0x00000010) != 0)) {
          result.schnorrSig_ = schnorrSig_;
        }
        if (((from_bitField0_ & 0x00000020) != 0)) {
          result.schnorrSigTapTweak_ = schnorrSigTapTweak_;
        }
        result.bitField0_ |= to_bitField0_;
      }

      @java.lang.Override
      public Builder clone() {
        return super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof signrpc.SignerOuterClass.SignMessageReq) {
          return mergeFrom((signrpc.SignerOuterClass.SignMessageReq)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(signrpc.SignerOuterClass.SignMessageReq other) {
        if (other == signrpc.SignerOuterClass.SignMessageReq.getDefaultInstance()) return this;
        if (other.getMsg() != com.google.protobuf.ByteString.EMPTY) {
          setMsg(other.getMsg());
        }
        if (other.hasKeyLoc()) {
          mergeKeyLoc(other.getKeyLoc());
        }
        if (other.getDoubleHash() != false) {
          setDoubleHash(other.getDoubleHash());
        }
        if (other.getCompactSig() != false) {
          setCompactSig(other.getCompactSig());
        }
        if (other.getSchnorrSig() != false) {
          setSchnorrSig(other.getSchnorrSig());
        }
        if (other.getSchnorrSigTapTweak() != com.google.protobuf.ByteString.EMPTY) {
          setSchnorrSigTapTweak(other.getSchnorrSigTapTweak());
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10: {
                msg_ = input.readBytes();
                bitField0_ |= 0x00000001;
                break;
              } // case 10
              case 18: {
                input.readMessage(
                    getKeyLocFieldBuilder().getBuilder(),
                    extensionRegistry);
                bitField0_ |= 0x00000002;
                break;
              } // case 18
              case 24: {
                doubleHash_ = input.readBool();
                bitField0_ |= 0x00000004;
                break;
              } // case 24
              case 32: {
                compactSig_ = input.readBool();
                bitField0_ |= 0x00000008;
                break;
              } // case 32
              case 40: {
                schnorrSig_ = input.readBool();
                bitField0_ |= 0x00000010;
                break;
              } // case 40
              case 50: {
                schnorrSigTapTweak_ = input.readBytes();
                bitField0_ |= 0x00000020;
                break;
              } // case 50
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private com.google.protobuf.ByteString msg_ = com.google.protobuf.ByteString.EMPTY;
      /**
       * <pre>
       *
       *The message to be signed. When using REST, this field must be encoded as
       *base64.
       * </pre>
       *
       * <code>bytes msg = 1;</code>
       * @return The msg.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString getMsg() {
        return msg_;
      }
      /**
       * <pre>
       *
       *The message to be signed. When using REST, this field must be encoded as
       *base64.
       * </pre>
       *
       * <code>bytes msg = 1;</code>
       * @param value The msg to set.
       * @return This builder for chaining.
       */
      public Builder setMsg(com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        msg_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       *
       *The message to be signed. When using REST, this field must be encoded as
       *base64.
       * </pre>
       *
       * <code>bytes msg = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearMsg() {
        bitField0_ = (bitField0_ & ~0x00000001);
        msg_ = getDefaultInstance().getMsg();
        onChanged();
        return this;
      }

      private signrpc.SignerOuterClass.KeyLocator keyLoc_;
      private com.google.protobuf.SingleFieldBuilderV3<
          signrpc.SignerOuterClass.KeyLocator, signrpc.SignerOuterClass.KeyLocator.Builder, signrpc.SignerOuterClass.KeyLocatorOrBuilder> keyLocBuilder_;
      /**
       * <pre>
       * The key locator that identifies which key to use for signing.
       * </pre>
       *
       * <code>.signrpc.KeyLocator key_loc = 2;</code>
       * @return Whether the keyLoc field is set.
       */
      public boolean hasKeyLoc() {
        return ((bitField0_ & 0x00000002) != 0);
      }
      /**
       * <pre>
       * The key locator that identifies which key to use for signing.
       * </pre>
       *
       * <code>.signrpc.KeyLocator key_loc = 2;</code>
       * @return The keyLoc.
       */
      public signrpc.SignerOuterClass.KeyLocator getKeyLoc() {
        if (keyLocBuilder_ == null) {
          return keyLoc_ == null ? signrpc.SignerOuterClass.KeyLocator.getDefaultInstance() : keyLoc_;
        } else {
          return keyLocBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * The key locator that identifies which key to use for signing.
       * </pre>
       *
       * <code>.signrpc.KeyLocator key_loc = 2;</code>
       */
      public Builder setKeyLoc(signrpc.SignerOuterClass.KeyLocator value) {
        if (keyLocBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          keyLoc_ = value;
        } else {
          keyLocBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The key locator that identifies which key to use for signing.
       * </pre>
       *
       * <code>.signrpc.KeyLocator key_loc = 2;</code>
       */
      public Builder setKeyLoc(
          signrpc.SignerOuterClass.KeyLocator.Builder builderForValue) {
        if (keyLocBuilder_ == null) {
          keyLoc_ = builderForValue.build();
        } else {
          keyLocBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The key locator that identifies which key to use for signing.
       * </pre>
       *
       * <code>.signrpc.KeyLocator key_loc = 2;</code>
       */
      public Builder mergeKeyLoc(signrpc.SignerOuterClass.KeyLocator value) {
        if (keyLocBuilder_ == null) {
          if (((bitField0_ & 0x00000002) != 0) &&
            keyLoc_ != null &&
            keyLoc_ != signrpc.SignerOuterClass.KeyLocator.getDefaultInstance()) {
            getKeyLocBuilder().mergeFrom(value);
          } else {
            keyLoc_ = value;
          }
        } else {
          keyLocBuilder_.mergeFrom(value);
        }
        if (keyLoc_ != null) {
          bitField0_ |= 0x00000002;
          onChanged();
        }
        return this;
      }
      /**
       * <pre>
       * The key locator that identifies which key to use for signing.
       * </pre>
       *
       * <code>.signrpc.KeyLocator key_loc = 2;</code>
       */
      public Builder clearKeyLoc() {
        bitField0_ = (bitField0_ & ~0x00000002);
        keyLoc_ = null;
        if (keyLocBuilder_ != null) {
          keyLocBuilder_.dispose();
          keyLocBuilder_ = null;
        }
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The key locator that identifies which key to use for signing.
       * </pre>
       *
       * <code>.signrpc.KeyLocator key_loc = 2;</code>
       */
      public signrpc.SignerOuterClass.KeyLocator.Builder getKeyLocBuilder() {
        bitField0_ |= 0x00000002;
        onChanged();
        return getKeyLocFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * The key locator that identifies which key to use for signing.
       * </pre>
       *
       * <code>.signrpc.KeyLocator key_loc = 2;</code>
       */
      public signrpc.SignerOuterClass.KeyLocatorOrBuilder getKeyLocOrBuilder() {
        if (keyLocBuilder_ != null) {
          return keyLocBuilder_.getMessageOrBuilder();
        } else {
          return keyLoc_ == null ?
              signrpc.SignerOuterClass.KeyLocator.getDefaultInstance() : keyLoc_;
        }
      }
      /**
       * <pre>
       * The key locator that identifies which key to use for signing.
       * </pre>
       *
       * <code>.signrpc.KeyLocator key_loc = 2;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          signrpc.SignerOuterClass.KeyLocator, signrpc.SignerOuterClass.KeyLocator.Builder, signrpc.SignerOuterClass.KeyLocatorOrBuilder> 
          getKeyLocFieldBuilder() {
        if (keyLocBuilder_ == null) {
          keyLocBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              signrpc.SignerOuterClass.KeyLocator, signrpc.SignerOuterClass.KeyLocator.Builder, signrpc.SignerOuterClass.KeyLocatorOrBuilder>(
                  getKeyLoc(),
                  getParentForChildren(),
                  isClean());
          keyLoc_ = null;
        }
        return keyLocBuilder_;
      }

      private boolean doubleHash_ ;
      /**
       * <pre>
       * Double-SHA256 hash instead of just the default single round.
       * </pre>
       *
       * <code>bool double_hash = 3;</code>
       * @return The doubleHash.
       */
      @java.lang.Override
      public boolean getDoubleHash() {
        return doubleHash_;
      }
      /**
       * <pre>
       * Double-SHA256 hash instead of just the default single round.
       * </pre>
       *
       * <code>bool double_hash = 3;</code>
       * @param value The doubleHash to set.
       * @return This builder for chaining.
       */
      public Builder setDoubleHash(boolean value) {

        doubleHash_ = value;
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Double-SHA256 hash instead of just the default single round.
       * </pre>
       *
       * <code>bool double_hash = 3;</code>
       * @return This builder for chaining.
       */
      public Builder clearDoubleHash() {
        bitField0_ = (bitField0_ & ~0x00000004);
        doubleHash_ = false;
        onChanged();
        return this;
      }

      private boolean compactSig_ ;
      /**
       * <pre>
       *
       *Use the compact (pubkey recoverable) format instead of the raw lnwire
       *format. This option cannot be used with Schnorr signatures.
       * </pre>
       *
       * <code>bool compact_sig = 4;</code>
       * @return The compactSig.
       */
      @java.lang.Override
      public boolean getCompactSig() {
        return compactSig_;
      }
      /**
       * <pre>
       *
       *Use the compact (pubkey recoverable) format instead of the raw lnwire
       *format. This option cannot be used with Schnorr signatures.
       * </pre>
       *
       * <code>bool compact_sig = 4;</code>
       * @param value The compactSig to set.
       * @return This builder for chaining.
       */
      public Builder setCompactSig(boolean value) {

        compactSig_ = value;
        bitField0_ |= 0x00000008;
        onChanged();
        return this;
      }
      /**
       * <pre>
       *
       *Use the compact (pubkey recoverable) format instead of the raw lnwire
       *format. This option cannot be used with Schnorr signatures.
       * </pre>
       *
       * <code>bool compact_sig = 4;</code>
       * @return This builder for chaining.
       */
      public Builder clearCompactSig() {
        bitField0_ = (bitField0_ & ~0x00000008);
        compactSig_ = false;
        onChanged();
        return this;
      }

      private boolean schnorrSig_ ;
      /**
       * <pre>
       *
       *Use Schnorr signature. This option cannot be used with compact format.
       * </pre>
       *
       * <code>bool schnorr_sig = 5;</code>
       * @return The schnorrSig.
       */
      @java.lang.Override
      public boolean getSchnorrSig() {
        return schnorrSig_;
      }
      /**
       * <pre>
       *
       *Use Schnorr signature. This option cannot be used with compact format.
       * </pre>
       *
       * <code>bool schnorr_sig = 5;</code>
       * @param value The schnorrSig to set.
       * @return This builder for chaining.
       */
      public Builder setSchnorrSig(boolean value) {

        schnorrSig_ = value;
        bitField0_ |= 0x00000010;
        onChanged();
        return this;
      }
      /**
       * <pre>
       *
       *Use Schnorr signature. This option cannot be used with compact format.
       * </pre>
       *
       * <code>bool schnorr_sig = 5;</code>
       * @return This builder for chaining.
       */
      public Builder clearSchnorrSig() {
        bitField0_ = (bitField0_ & ~0x00000010);
        schnorrSig_ = false;
        onChanged();
        return this;
      }

      private com.google.protobuf.ByteString schnorrSigTapTweak_ = com.google.protobuf.ByteString.EMPTY;
      /**
       * <pre>
       *
       *The optional Taproot tweak bytes to apply to the private key before creating
       *a Schnorr signature. The private key is tweaked as described in BIP-341:
       *privKey + h_tapTweak(internalKey || tapTweak)
       * </pre>
       *
       * <code>bytes schnorr_sig_tap_tweak = 6;</code>
       * @return The schnorrSigTapTweak.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString getSchnorrSigTapTweak() {
        return schnorrSigTapTweak_;
      }
      /**
       * <pre>
       *
       *The optional Taproot tweak bytes to apply to the private key before creating
       *a Schnorr signature. The private key is tweaked as described in BIP-341:
       *privKey + h_tapTweak(internalKey || tapTweak)
       * </pre>
       *
       * <code>bytes schnorr_sig_tap_tweak = 6;</code>
       * @param value The schnorrSigTapTweak to set.
       * @return This builder for chaining.
       */
      public Builder setSchnorrSigTapTweak(com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        schnorrSigTapTweak_ = value;
        bitField0_ |= 0x00000020;
        onChanged();
        return this;
      }
      /**
       * <pre>
       *
       *The optional Taproot tweak bytes to apply to the private key before creating
       *a Schnorr signature. The private key is tweaked as described in BIP-341:
       *privKey + h_tapTweak(internalKey || tapTweak)
       * </pre>
       *
       * <code>bytes schnorr_sig_tap_tweak = 6;</code>
       * @return This builder for chaining.
       */
      public Builder clearSchnorrSigTapTweak() {
        bitField0_ = (bitField0_ & ~0x00000020);
        schnorrSigTapTweak_ = getDefaultInstance().getSchnorrSigTapTweak();
        onChanged();
        return this;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:signrpc.SignMessageReq)
    }

    // @@protoc_insertion_point(class_scope:signrpc.SignMessageReq)
    private static final signrpc.SignerOuterClass.SignMessageReq DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new signrpc.SignerOuterClass.SignMessageReq();
    }

    public static signrpc.SignerOuterClass.SignMessageReq getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<SignMessageReq>
        PARSER = new com.google.protobuf.AbstractParser<SignMessageReq>() {
      @java.lang.Override
      public SignMessageReq parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<SignMessageReq> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<SignMessageReq> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public signrpc.SignerOuterClass.SignMessageReq getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface SignMessageRespOrBuilder extends
      // @@protoc_insertion_point(interface_extends:signrpc.SignMessageResp)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     *
     *The signature for the given message in the fixed-size LN wire format.
     * </pre>
     *
     * <code>bytes signature = 1;</code>
     * @return The signature.
     */
    com.google.protobuf.ByteString getSignature();
  }
  /**
   * Protobuf type {@code signrpc.SignMessageResp}
   */
  public static final class SignMessageResp extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:signrpc.SignMessageResp)
      SignMessageRespOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use SignMessageResp.newBuilder() to construct.
    private SignMessageResp(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private SignMessageResp() {
      signature_ = com.google.protobuf.ByteString.EMPTY;
    }

    @java.lang.Override
    @SuppressWarnings({"unused"})
    protected java.lang.Object newInstance(
        UnusedPrivateParameter unused) {
      return new SignMessageResp();
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return signrpc.SignerOuterClass.internal_static_signrpc_SignMessageResp_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return signrpc.SignerOuterClass.internal_static_signrpc_SignMessageResp_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              signrpc.SignerOuterClass.SignMessageResp.class, signrpc.SignerOuterClass.SignMessageResp.Builder.class);
    }

    public static final int SIGNATURE_FIELD_NUMBER = 1;
    private com.google.protobuf.ByteString signature_ = com.google.protobuf.ByteString.EMPTY;
    /**
     * <pre>
     *
     *The signature for the given message in the fixed-size LN wire format.
     * </pre>
     *
     * <code>bytes signature = 1;</code>
     * @return The signature.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString getSignature() {
      return signature_;
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (!signature_.isEmpty()) {
        output.writeBytes(1, signature_);
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (!signature_.isEmpty()) {
        size += com.google.protobuf.CodedOutputStream
          .computeBytesSize(1, signature_);
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof signrpc.SignerOuterClass.SignMessageResp)) {
        return super.equals(obj);
      }
      signrpc.SignerOuterClass.SignMessageResp other = (signrpc.SignerOuterClass.SignMessageResp) obj;

      if (!getSignature()
          .equals(other.getSignature())) return false;
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      hash = (37 * hash) + SIGNATURE_FIELD_NUMBER;
      hash = (53 * hash) + getSignature().hashCode();
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static signrpc.SignerOuterClass.SignMessageResp parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static signrpc.SignerOuterClass.SignMessageResp parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static signrpc.SignerOuterClass.SignMessageResp parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static signrpc.SignerOuterClass.SignMessageResp parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static signrpc.SignerOuterClass.SignMessageResp parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static signrpc.SignerOuterClass.SignMessageResp parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static signrpc.SignerOuterClass.SignMessageResp parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static signrpc.SignerOuterClass.SignMessageResp parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static signrpc.SignerOuterClass.SignMessageResp parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static signrpc.SignerOuterClass.SignMessageResp parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static signrpc.SignerOuterClass.SignMessageResp parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static signrpc.SignerOuterClass.SignMessageResp parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(signrpc.SignerOuterClass.SignMessageResp prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * Protobuf type {@code signrpc.SignMessageResp}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:signrpc.SignMessageResp)
        signrpc.SignerOuterClass.SignMessageRespOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return signrpc.SignerOuterClass.internal_static_signrpc_SignMessageResp_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return signrpc.SignerOuterClass.internal_static_signrpc_SignMessageResp_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                signrpc.SignerOuterClass.SignMessageResp.class, signrpc.SignerOuterClass.SignMessageResp.Builder.class);
      }

      // Construct using signrpc.SignerOuterClass.SignMessageResp.newBuilder()
      private Builder() {

      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);

      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        signature_ = com.google.protobuf.ByteString.EMPTY;
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return signrpc.SignerOuterClass.internal_static_signrpc_SignMessageResp_descriptor;
      }

      @java.lang.Override
      public signrpc.SignerOuterClass.SignMessageResp getDefaultInstanceForType() {
        return signrpc.SignerOuterClass.SignMessageResp.getDefaultInstance();
      }

      @java.lang.Override
      public signrpc.SignerOuterClass.SignMessageResp build() {
        signrpc.SignerOuterClass.SignMessageResp result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public signrpc.SignerOuterClass.SignMessageResp buildPartial() {
        signrpc.SignerOuterClass.SignMessageResp result = new signrpc.SignerOuterClass.SignMessageResp(this);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartial0(signrpc.SignerOuterClass.SignMessageResp result) {
        int from_bitField0_ = bitField0_;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.signature_ = signature_;
        }
      }

      @java.lang.Override
      public Builder clone() {
        return super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof signrpc.SignerOuterClass.SignMessageResp) {
          return mergeFrom((signrpc.SignerOuterClass.SignMessageResp)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(signrpc.SignerOuterClass.SignMessageResp other) {
        if (other == signrpc.SignerOuterClass.SignMessageResp.getDefaultInstance()) return this;
        if (other.getSignature() != com.google.protobuf.ByteString.EMPTY) {
          setSignature(other.getSignature());
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10: {
                signature_ = input.readBytes();
                bitField0_ |= 0x00000001;
                break;
              } // case 10
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private com.google.protobuf.ByteString signature_ = com.google.protobuf.ByteString.EMPTY;
      /**
       * <pre>
       *
       *The signature for the given message in the fixed-size LN wire format.
       * </pre>
       *
       * <code>bytes signature = 1;</code>
       * @return The signature.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString getSignature() {
        return signature_;
      }
      /**
       * <pre>
       *
       *The signature for the given message in the fixed-size LN wire format.
       * </pre>
       *
       * <code>bytes signature = 1;</code>
       * @param value The signature to set.
       * @return This builder for chaining.
       */
      public Builder setSignature(com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        signature_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       *
       *The signature for the given message in the fixed-size LN wire format.
       * </pre>
       *
       * <code>bytes signature = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearSignature() {
        bitField0_ = (bitField0_ & ~0x00000001);
        signature_ = getDefaultInstance().getSignature();
        onChanged();
        return this;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:signrpc.SignMessageResp)
    }

    // @@protoc_insertion_point(class_scope:signrpc.SignMessageResp)
    private static final signrpc.SignerOuterClass.SignMessageResp DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new signrpc.SignerOuterClass.SignMessageResp();
    }

    public static signrpc.SignerOuterClass.SignMessageResp getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<SignMessageResp>
        PARSER = new com.google.protobuf.AbstractParser<SignMessageResp>() {
      @java.lang.Override
      public SignMessageResp parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<SignMessageResp> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<SignMessageResp> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public signrpc.SignerOuterClass.SignMessageResp getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface VerifyMessageReqOrBuilder extends
      // @@protoc_insertion_point(interface_extends:signrpc.VerifyMessageReq)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * The message over which the signature is to be verified. When using
     * REST, this field must be encoded as base64.
     * </pre>
     *
     * <code>bytes msg = 1;</code>
     * @return The msg.
     */
    com.google.protobuf.ByteString getMsg();

    /**
     * <pre>
     *
     *The fixed-size LN wire encoded signature to be verified over the given
     *message. When using REST, this field must be encoded as base64.
     * </pre>
     *
     * <code>bytes signature = 2;</code>
     * @return The signature.
     */
    com.google.protobuf.ByteString getSignature();

    /**
     * <pre>
     *
     *The public key the signature has to be valid for. When using REST, this
     *field must be encoded as base64. If the is_schnorr_sig option is true, then
     *the public key is expected to be in the 32-byte x-only serialization
     *according to BIP-340.
     * </pre>
     *
     * <code>bytes pubkey = 3;</code>
     * @return The pubkey.
     */
    com.google.protobuf.ByteString getPubkey();

    /**
     * <pre>
     *
     *Specifies if the signature is a Schnorr signature.
     * </pre>
     *
     * <code>bool is_schnorr_sig = 4;</code>
     * @return The isSchnorrSig.
     */
    boolean getIsSchnorrSig();
  }
  /**
   * Protobuf type {@code signrpc.VerifyMessageReq}
   */
  public static final class VerifyMessageReq extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:signrpc.VerifyMessageReq)
      VerifyMessageReqOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use VerifyMessageReq.newBuilder() to construct.
    private VerifyMessageReq(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private VerifyMessageReq() {
      msg_ = com.google.protobuf.ByteString.EMPTY;
      signature_ = com.google.protobuf.ByteString.EMPTY;
      pubkey_ = com.google.protobuf.ByteString.EMPTY;
    }

    @java.lang.Override
    @SuppressWarnings({"unused"})
    protected java.lang.Object newInstance(
        UnusedPrivateParameter unused) {
      return new VerifyMessageReq();
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return signrpc.SignerOuterClass.internal_static_signrpc_VerifyMessageReq_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return signrpc.SignerOuterClass.internal_static_signrpc_VerifyMessageReq_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              signrpc.SignerOuterClass.VerifyMessageReq.class, signrpc.SignerOuterClass.VerifyMessageReq.Builder.class);
    }

    public static final int MSG_FIELD_NUMBER = 1;
    private com.google.protobuf.ByteString msg_ = com.google.protobuf.ByteString.EMPTY;
    /**
     * <pre>
     * The message over which the signature is to be verified. When using
     * REST, this field must be encoded as base64.
     * </pre>
     *
     * <code>bytes msg = 1;</code>
     * @return The msg.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString getMsg() {
      return msg_;
    }

    public static final int SIGNATURE_FIELD_NUMBER = 2;
    private com.google.protobuf.ByteString signature_ = com.google.protobuf.ByteString.EMPTY;
    /**
     * <pre>
     *
     *The fixed-size LN wire encoded signature to be verified over the given
     *message. When using REST, this field must be encoded as base64.
     * </pre>
     *
     * <code>bytes signature = 2;</code>
     * @return The signature.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString getSignature() {
      return signature_;
    }

    public static final int PUBKEY_FIELD_NUMBER = 3;
    private com.google.protobuf.ByteString pubkey_ = com.google.protobuf.ByteString.EMPTY;
    /**
     * <pre>
     *
     *The public key the signature has to be valid for. When using REST, this
     *field must be encoded as base64. If the is_schnorr_sig option is true, then
     *the public key is expected to be in the 32-byte x-only serialization
     *according to BIP-340.
     * </pre>
     *
     * <code>bytes pubkey = 3;</code>
     * @return The pubkey.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString getPubkey() {
      return pubkey_;
    }

    public static final int IS_SCHNORR_SIG_FIELD_NUMBER = 4;
    private boolean isSchnorrSig_ = false;
    /**
     * <pre>
     *
     *Specifies if the signature is a Schnorr signature.
     * </pre>
     *
     * <code>bool is_schnorr_sig = 4;</code>
     * @return The isSchnorrSig.
     */
    @java.lang.Override
    public boolean getIsSchnorrSig() {
      return isSchnorrSig_;
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (!msg_.isEmpty()) {
        output.writeBytes(1, msg_);
      }
      if (!signature_.isEmpty()) {
        output.writeBytes(2, signature_);
      }
      if (!pubkey_.isEmpty()) {
        output.writeBytes(3, pubkey_);
      }
      if (isSchnorrSig_ != false) {
        output.writeBool(4, isSchnorrSig_);
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (!msg_.isEmpty()) {
        size += com.google.protobuf.CodedOutputStream
          .computeBytesSize(1, msg_);
      }
      if (!signature_.isEmpty()) {
        size += com.google.protobuf.CodedOutputStream
          .computeBytesSize(2, signature_);
      }
      if (!pubkey_.isEmpty()) {
        size += com.google.protobuf.CodedOutputStream
          .computeBytesSize(3, pubkey_);
      }
      if (isSchnorrSig_ != false) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(4, isSchnorrSig_);
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof signrpc.SignerOuterClass.VerifyMessageReq)) {
        return super.equals(obj);
      }
      signrpc.SignerOuterClass.VerifyMessageReq other = (signrpc.SignerOuterClass.VerifyMessageReq) obj;

      if (!getMsg()
          .equals(other.getMsg())) return false;
      if (!getSignature()
          .equals(other.getSignature())) return false;
      if (!getPubkey()
          .equals(other.getPubkey())) return false;
      if (getIsSchnorrSig()
          != other.getIsSchnorrSig()) return false;
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      hash = (37 * hash) + MSG_FIELD_NUMBER;
      hash = (53 * hash) + getMsg().hashCode();
      hash = (37 * hash) + SIGNATURE_FIELD_NUMBER;
      hash = (53 * hash) + getSignature().hashCode();
      hash = (37 * hash) + PUBKEY_FIELD_NUMBER;
      hash = (53 * hash) + getPubkey().hashCode();
      hash = (37 * hash) + IS_SCHNORR_SIG_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
          getIsSchnorrSig());
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static signrpc.SignerOuterClass.VerifyMessageReq parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static signrpc.SignerOuterClass.VerifyMessageReq parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static signrpc.SignerOuterClass.VerifyMessageReq parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static signrpc.SignerOuterClass.VerifyMessageReq parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static signrpc.SignerOuterClass.VerifyMessageReq parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static signrpc.SignerOuterClass.VerifyMessageReq parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static signrpc.SignerOuterClass.VerifyMessageReq parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static signrpc.SignerOuterClass.VerifyMessageReq parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static signrpc.SignerOuterClass.VerifyMessageReq parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static signrpc.SignerOuterClass.VerifyMessageReq parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static signrpc.SignerOuterClass.VerifyMessageReq parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static signrpc.SignerOuterClass.VerifyMessageReq parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(signrpc.SignerOuterClass.VerifyMessageReq prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * Protobuf type {@code signrpc.VerifyMessageReq}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:signrpc.VerifyMessageReq)
        signrpc.SignerOuterClass.VerifyMessageReqOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return signrpc.SignerOuterClass.internal_static_signrpc_VerifyMessageReq_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return signrpc.SignerOuterClass.internal_static_signrpc_VerifyMessageReq_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                signrpc.SignerOuterClass.VerifyMessageReq.class, signrpc.SignerOuterClass.VerifyMessageReq.Builder.class);
      }

      // Construct using signrpc.SignerOuterClass.VerifyMessageReq.newBuilder()
      private Builder() {

      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);

      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        msg_ = com.google.protobuf.ByteString.EMPTY;
        signature_ = com.google.protobuf.ByteString.EMPTY;
        pubkey_ = com.google.protobuf.ByteString.EMPTY;
        isSchnorrSig_ = false;
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return signrpc.SignerOuterClass.internal_static_signrpc_VerifyMessageReq_descriptor;
      }

      @java.lang.Override
      public signrpc.SignerOuterClass.VerifyMessageReq getDefaultInstanceForType() {
        return signrpc.SignerOuterClass.VerifyMessageReq.getDefaultInstance();
      }

      @java.lang.Override
      public signrpc.SignerOuterClass.VerifyMessageReq build() {
        signrpc.SignerOuterClass.VerifyMessageReq result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public signrpc.SignerOuterClass.VerifyMessageReq buildPartial() {
        signrpc.SignerOuterClass.VerifyMessageReq result = new signrpc.SignerOuterClass.VerifyMessageReq(this);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartial0(signrpc.SignerOuterClass.VerifyMessageReq result) {
        int from_bitField0_ = bitField0_;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.msg_ = msg_;
        }
        if (((from_bitField0_ & 0x00000002) != 0)) {
          result.signature_ = signature_;
        }
        if (((from_bitField0_ & 0x00000004) != 0)) {
          result.pubkey_ = pubkey_;
        }
        if (((from_bitField0_ & 0x00000008) != 0)) {
          result.isSchnorrSig_ = isSchnorrSig_;
        }
      }

      @java.lang.Override
      public Builder clone() {
        return super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof signrpc.SignerOuterClass.VerifyMessageReq) {
          return mergeFrom((signrpc.SignerOuterClass.VerifyMessageReq)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(signrpc.SignerOuterClass.VerifyMessageReq other) {
        if (other == signrpc.SignerOuterClass.VerifyMessageReq.getDefaultInstance()) return this;
        if (other.getMsg() != com.google.protobuf.ByteString.EMPTY) {
          setMsg(other.getMsg());
        }
        if (other.getSignature() != com.google.protobuf.ByteString.EMPTY) {
          setSignature(other.getSignature());
        }
        if (other.getPubkey() != com.google.protobuf.ByteString.EMPTY) {
          setPubkey(other.getPubkey());
        }
        if (other.getIsSchnorrSig() != false) {
          setIsSchnorrSig(other.getIsSchnorrSig());
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10: {
                msg_ = input.readBytes();
                bitField0_ |= 0x00000001;
                break;
              } // case 10
              case 18: {
                signature_ = input.readBytes();
                bitField0_ |= 0x00000002;
                break;
              } // case 18
              case 26: {
                pubkey_ = input.readBytes();
                bitField0_ |= 0x00000004;
                break;
              } // case 26
              case 32: {
                isSchnorrSig_ = input.readBool();
                bitField0_ |= 0x00000008;
                break;
              } // case 32
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private com.google.protobuf.ByteString msg_ = com.google.protobuf.ByteString.EMPTY;
      /**
       * <pre>
       * The message over which the signature is to be verified. When using
       * REST, this field must be encoded as base64.
       * </pre>
       *
       * <code>bytes msg = 1;</code>
       * @return The msg.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString getMsg() {
        return msg_;
      }
      /**
       * <pre>
       * The message over which the signature is to be verified. When using
       * REST, this field must be encoded as base64.
       * </pre>
       *
       * <code>bytes msg = 1;</code>
       * @param value The msg to set.
       * @return This builder for chaining.
       */
      public Builder setMsg(com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        msg_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The message over which the signature is to be verified. When using
       * REST, this field must be encoded as base64.
       * </pre>
       *
       * <code>bytes msg = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearMsg() {
        bitField0_ = (bitField0_ & ~0x00000001);
        msg_ = getDefaultInstance().getMsg();
        onChanged();
        return this;
      }

      private com.google.protobuf.ByteString signature_ = com.google.protobuf.ByteString.EMPTY;
      /**
       * <pre>
       *
       *The fixed-size LN wire encoded signature to be verified over the given
       *message. When using REST, this field must be encoded as base64.
       * </pre>
       *
       * <code>bytes signature = 2;</code>
       * @return The signature.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString getSignature() {
        return signature_;
      }
      /**
       * <pre>
       *
       *The fixed-size LN wire encoded signature to be verified over the given
       *message. When using REST, this field must be encoded as base64.
       * </pre>
       *
       * <code>bytes signature = 2;</code>
       * @param value The signature to set.
       * @return This builder for chaining.
       */
      public Builder setSignature(com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        signature_ = value;
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       *
       *The fixed-size LN wire encoded signature to be verified over the given
       *message. When using REST, this field must be encoded as base64.
       * </pre>
       *
       * <code>bytes signature = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearSignature() {
        bitField0_ = (bitField0_ & ~0x00000002);
        signature_ = getDefaultInstance().getSignature();
        onChanged();
        return this;
      }

      private com.google.protobuf.ByteString pubkey_ = com.google.protobuf.ByteString.EMPTY;
      /**
       * <pre>
       *
       *The public key the signature has to be valid for. When using REST, this
       *field must be encoded as base64. If the is_schnorr_sig option is true, then
       *the public key is expected to be in the 32-byte x-only serialization
       *according to BIP-340.
       * </pre>
       *
       * <code>bytes pubkey = 3;</code>
       * @return The pubkey.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString getPubkey() {
        return pubkey_;
      }
      /**
       * <pre>
       *
       *The public key the signature has to be valid for. When using REST, this
       *field must be encoded as base64. If the is_schnorr_sig option is true, then
       *the public key is expected to be in the 32-byte x-only serialization
       *according to BIP-340.
       * </pre>
       *
       * <code>bytes pubkey = 3;</code>
       * @param value The pubkey to set.
       * @return This builder for chaining.
       */
      public Builder setPubkey(com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        pubkey_ = value;
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }
      /**
       * <pre>
       *
       *The public key the signature has to be valid for. When using REST, this
       *field must be encoded as base64. If the is_schnorr_sig option is true, then
       *the public key is expected to be in the 32-byte x-only serialization
       *according to BIP-340.
       * </pre>
       *
       * <code>bytes pubkey = 3;</code>
       * @return This builder for chaining.
       */
      public Builder clearPubkey() {
        bitField0_ = (bitField0_ & ~0x00000004);
        pubkey_ = getDefaultInstance().getPubkey();
        onChanged();
        return this;
      }

      private boolean isSchnorrSig_ ;
      /**
       * <pre>
       *
       *Specifies if the signature is a Schnorr signature.
       * </pre>
       *
       * <code>bool is_schnorr_sig = 4;</code>
       * @return The isSchnorrSig.
       */
      @java.lang.Override
      public boolean getIsSchnorrSig() {
        return isSchnorrSig_;
      }
      /**
       * <pre>
       *
       *Specifies if the signature is a Schnorr signature.
       * </pre>
       *
       * <code>bool is_schnorr_sig = 4;</code>
       * @param value The isSchnorrSig to set.
       * @return This builder for chaining.
       */
      public Builder setIsSchnorrSig(boolean value) {

        isSchnorrSig_ = value;
        bitField0_ |= 0x00000008;
        onChanged();
        return this;
      }
      /**
       * <pre>
       *
       *Specifies if the signature is a Schnorr signature.
       * </pre>
       *
       * <code>bool is_schnorr_sig = 4;</code>
       * @return This builder for chaining.
       */
      public Builder clearIsSchnorrSig() {
        bitField0_ = (bitField0_ & ~0x00000008);
        isSchnorrSig_ = false;
        onChanged();
        return this;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:signrpc.VerifyMessageReq)
    }

    // @@protoc_insertion_point(class_scope:signrpc.VerifyMessageReq)
    private static final signrpc.SignerOuterClass.VerifyMessageReq DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new signrpc.SignerOuterClass.VerifyMessageReq();
    }

    public static signrpc.SignerOuterClass.VerifyMessageReq getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<VerifyMessageReq>
        PARSER = new com.google.protobuf.AbstractParser<VerifyMessageReq>() {
      @java.lang.Override
      public VerifyMessageReq parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<VerifyMessageReq> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<VerifyMessageReq> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public signrpc.SignerOuterClass.VerifyMessageReq getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface VerifyMessageRespOrBuilder extends
      // @@protoc_insertion_point(interface_extends:signrpc.VerifyMessageResp)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * Whether the signature was valid over the given message.
     * </pre>
     *
     * <code>bool valid = 1;</code>
     * @return The valid.
     */
    boolean getValid();
  }
  /**
   * Protobuf type {@code signrpc.VerifyMessageResp}
   */
  public static final class VerifyMessageResp extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:signrpc.VerifyMessageResp)
      VerifyMessageRespOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use VerifyMessageResp.newBuilder() to construct.
    private VerifyMessageResp(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private VerifyMessageResp() {
    }

    @java.lang.Override
    @SuppressWarnings({"unused"})
    protected java.lang.Object newInstance(
        UnusedPrivateParameter unused) {
      return new VerifyMessageResp();
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return signrpc.SignerOuterClass.internal_static_signrpc_VerifyMessageResp_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return signrpc.SignerOuterClass.internal_static_signrpc_VerifyMessageResp_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              signrpc.SignerOuterClass.VerifyMessageResp.class, signrpc.SignerOuterClass.VerifyMessageResp.Builder.class);
    }

    public static final int VALID_FIELD_NUMBER = 1;
    private boolean valid_ = false;
    /**
     * <pre>
     * Whether the signature was valid over the given message.
     * </pre>
     *
     * <code>bool valid = 1;</code>
     * @return The valid.
     */
    @java.lang.Override
    public boolean getValid() {
      return valid_;
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (valid_ != false) {
        output.writeBool(1, valid_);
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (valid_ != false) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(1, valid_);
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof signrpc.SignerOuterClass.VerifyMessageResp)) {
        return super.equals(obj);
      }
      signrpc.SignerOuterClass.VerifyMessageResp other = (signrpc.SignerOuterClass.VerifyMessageResp) obj;

      if (getValid()
          != other.getValid()) return false;
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      hash = (37 * hash) + VALID_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
          getValid());
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static signrpc.SignerOuterClass.VerifyMessageResp parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static signrpc.SignerOuterClass.VerifyMessageResp parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static signrpc.SignerOuterClass.VerifyMessageResp parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static signrpc.SignerOuterClass.VerifyMessageResp parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static signrpc.SignerOuterClass.VerifyMessageResp parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static signrpc.SignerOuterClass.VerifyMessageResp parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static signrpc.SignerOuterClass.VerifyMessageResp parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static signrpc.SignerOuterClass.VerifyMessageResp parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static signrpc.SignerOuterClass.VerifyMessageResp parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static signrpc.SignerOuterClass.VerifyMessageResp parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static signrpc.SignerOuterClass.VerifyMessageResp parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static signrpc.SignerOuterClass.VerifyMessageResp parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(signrpc.SignerOuterClass.VerifyMessageResp prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * Protobuf type {@code signrpc.VerifyMessageResp}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:signrpc.VerifyMessageResp)
        signrpc.SignerOuterClass.VerifyMessageRespOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return signrpc.SignerOuterClass.internal_static_signrpc_VerifyMessageResp_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return signrpc.SignerOuterClass.internal_static_signrpc_VerifyMessageResp_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                signrpc.SignerOuterClass.VerifyMessageResp.class, signrpc.SignerOuterClass.VerifyMessageResp.Builder.class);
      }

      // Construct using signrpc.SignerOuterClass.VerifyMessageResp.newBuilder()
      private Builder() {

      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);

      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        valid_ = false;
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return signrpc.SignerOuterClass.internal_static_signrpc_VerifyMessageResp_descriptor;
      }

      @java.lang.Override
      public signrpc.SignerOuterClass.VerifyMessageResp getDefaultInstanceForType() {
        return signrpc.SignerOuterClass.VerifyMessageResp.getDefaultInstance();
      }

      @java.lang.Override
      public signrpc.SignerOuterClass.VerifyMessageResp build() {
        signrpc.SignerOuterClass.VerifyMessageResp result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public signrpc.SignerOuterClass.VerifyMessageResp buildPartial() {
        signrpc.SignerOuterClass.VerifyMessageResp result = new signrpc.SignerOuterClass.VerifyMessageResp(this);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartial0(signrpc.SignerOuterClass.VerifyMessageResp result) {
        int from_bitField0_ = bitField0_;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.valid_ = valid_;
        }
      }

      @java.lang.Override
      public Builder clone() {
        return super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof signrpc.SignerOuterClass.VerifyMessageResp) {
          return mergeFrom((signrpc.SignerOuterClass.VerifyMessageResp)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(signrpc.SignerOuterClass.VerifyMessageResp other) {
        if (other == signrpc.SignerOuterClass.VerifyMessageResp.getDefaultInstance()) return this;
        if (other.getValid() != false) {
          setValid(other.getValid());
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 8: {
                valid_ = input.readBool();
                bitField0_ |= 0x00000001;
                break;
              } // case 8
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private boolean valid_ ;
      /**
       * <pre>
       * Whether the signature was valid over the given message.
       * </pre>
       *
       * <code>bool valid = 1;</code>
       * @return The valid.
       */
      @java.lang.Override
      public boolean getValid() {
        return valid_;
      }
      /**
       * <pre>
       * Whether the signature was valid over the given message.
       * </pre>
       *
       * <code>bool valid = 1;</code>
       * @param value The valid to set.
       * @return This builder for chaining.
       */
      public Builder setValid(boolean value) {

        valid_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Whether the signature was valid over the given message.
       * </pre>
       *
       * <code>bool valid = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearValid() {
        bitField0_ = (bitField0_ & ~0x00000001);
        valid_ = false;
        onChanged();
        return this;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:signrpc.VerifyMessageResp)
    }

    // @@protoc_insertion_point(class_scope:signrpc.VerifyMessageResp)
    private static final signrpc.SignerOuterClass.VerifyMessageResp DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new signrpc.SignerOuterClass.VerifyMessageResp();
    }

    public static signrpc.SignerOuterClass.VerifyMessageResp getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<VerifyMessageResp>
        PARSER = new com.google.protobuf.AbstractParser<VerifyMessageResp>() {
      @java.lang.Override
      public VerifyMessageResp parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<VerifyMessageResp> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<VerifyMessageResp> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public signrpc.SignerOuterClass.VerifyMessageResp getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface SharedKeyRequestOrBuilder extends
      // @@protoc_insertion_point(interface_extends:signrpc.SharedKeyRequest)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * The ephemeral public key to use for the DH key derivation.
     * </pre>
     *
     * <code>bytes ephemeral_pubkey = 1;</code>
     * @return The ephemeralPubkey.
     */
    com.google.protobuf.ByteString getEphemeralPubkey();

    /**
     * <pre>
     *
     *Deprecated. The optional key locator of the local key that should be used.
     *If this parameter is not set then the node's identity private key will be
     *used.
     * </pre>
     *
     * <code>.signrpc.KeyLocator key_loc = 2 [deprecated = true];</code>
     * @deprecated signrpc.SharedKeyRequest.key_loc is deprecated.
     *     See signrpc/signer.proto;l=398
     * @return Whether the keyLoc field is set.
     */
    @java.lang.Deprecated boolean hasKeyLoc();
    /**
     * <pre>
     *
     *Deprecated. The optional key locator of the local key that should be used.
     *If this parameter is not set then the node's identity private key will be
     *used.
     * </pre>
     *
     * <code>.signrpc.KeyLocator key_loc = 2 [deprecated = true];</code>
     * @deprecated signrpc.SharedKeyRequest.key_loc is deprecated.
     *     See signrpc/signer.proto;l=398
     * @return The keyLoc.
     */
    @java.lang.Deprecated signrpc.SignerOuterClass.KeyLocator getKeyLoc();
    /**
     * <pre>
     *
     *Deprecated. The optional key locator of the local key that should be used.
     *If this parameter is not set then the node's identity private key will be
     *used.
     * </pre>
     *
     * <code>.signrpc.KeyLocator key_loc = 2 [deprecated = true];</code>
     */
    @java.lang.Deprecated signrpc.SignerOuterClass.KeyLocatorOrBuilder getKeyLocOrBuilder();

    /**
     * <pre>
     *
     *A key descriptor describes the key used for performing ECDH. Either a key
     *locator or a raw public key is expected, if neither is supplied, defaults to
     *the node's identity private key.
     * </pre>
     *
     * <code>.signrpc.KeyDescriptor key_desc = 3;</code>
     * @return Whether the keyDesc field is set.
     */
    boolean hasKeyDesc();
    /**
     * <pre>
     *
     *A key descriptor describes the key used for performing ECDH. Either a key
     *locator or a raw public key is expected, if neither is supplied, defaults to
     *the node's identity private key.
     * </pre>
     *
     * <code>.signrpc.KeyDescriptor key_desc = 3;</code>
     * @return The keyDesc.
     */
    signrpc.SignerOuterClass.KeyDescriptor getKeyDesc();
    /**
     * <pre>
     *
     *A key descriptor describes the key used for performing ECDH. Either a key
     *locator or a raw public key is expected, if neither is supplied, defaults to
     *the node's identity private key.
     * </pre>
     *
     * <code>.signrpc.KeyDescriptor key_desc = 3;</code>
     */
    signrpc.SignerOuterClass.KeyDescriptorOrBuilder getKeyDescOrBuilder();
  }
  /**
   * Protobuf type {@code signrpc.SharedKeyRequest}
   */
  public static final class SharedKeyRequest extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:signrpc.SharedKeyRequest)
      SharedKeyRequestOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use SharedKeyRequest.newBuilder() to construct.
    private SharedKeyRequest(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private SharedKeyRequest() {
      ephemeralPubkey_ = com.google.protobuf.ByteString.EMPTY;
    }

    @java.lang.Override
    @SuppressWarnings({"unused"})
    protected java.lang.Object newInstance(
        UnusedPrivateParameter unused) {
      return new SharedKeyRequest();
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return signrpc.SignerOuterClass.internal_static_signrpc_SharedKeyRequest_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return signrpc.SignerOuterClass.internal_static_signrpc_SharedKeyRequest_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              signrpc.SignerOuterClass.SharedKeyRequest.class, signrpc.SignerOuterClass.SharedKeyRequest.Builder.class);
    }

    private int bitField0_;
    public static final int EPHEMERAL_PUBKEY_FIELD_NUMBER = 1;
    private com.google.protobuf.ByteString ephemeralPubkey_ = com.google.protobuf.ByteString.EMPTY;
    /**
     * <pre>
     * The ephemeral public key to use for the DH key derivation.
     * </pre>
     *
     * <code>bytes ephemeral_pubkey = 1;</code>
     * @return The ephemeralPubkey.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString getEphemeralPubkey() {
      return ephemeralPubkey_;
    }

    public static final int KEY_LOC_FIELD_NUMBER = 2;
    private signrpc.SignerOuterClass.KeyLocator keyLoc_;
    /**
     * <pre>
     *
     *Deprecated. The optional key locator of the local key that should be used.
     *If this parameter is not set then the node's identity private key will be
     *used.
     * </pre>
     *
     * <code>.signrpc.KeyLocator key_loc = 2 [deprecated = true];</code>
     * @deprecated signrpc.SharedKeyRequest.key_loc is deprecated.
     *     See signrpc/signer.proto;l=398
     * @return Whether the keyLoc field is set.
     */
    @java.lang.Override
    @java.lang.Deprecated public boolean hasKeyLoc() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     *
     *Deprecated. The optional key locator of the local key that should be used.
     *If this parameter is not set then the node's identity private key will be
     *used.
     * </pre>
     *
     * <code>.signrpc.KeyLocator key_loc = 2 [deprecated = true];</code>
     * @deprecated signrpc.SharedKeyRequest.key_loc is deprecated.
     *     See signrpc/signer.proto;l=398
     * @return The keyLoc.
     */
    @java.lang.Override
    @java.lang.Deprecated public signrpc.SignerOuterClass.KeyLocator getKeyLoc() {
      return keyLoc_ == null ? signrpc.SignerOuterClass.KeyLocator.getDefaultInstance() : keyLoc_;
    }
    /**
     * <pre>
     *
     *Deprecated. The optional key locator of the local key that should be used.
     *If this parameter is not set then the node's identity private key will be
     *used.
     * </pre>
     *
     * <code>.signrpc.KeyLocator key_loc = 2 [deprecated = true];</code>
     */
    @java.lang.Override
    @java.lang.Deprecated public signrpc.SignerOuterClass.KeyLocatorOrBuilder getKeyLocOrBuilder() {
      return keyLoc_ == null ? signrpc.SignerOuterClass.KeyLocator.getDefaultInstance() : keyLoc_;
    }

    public static final int KEY_DESC_FIELD_NUMBER = 3;
    private signrpc.SignerOuterClass.KeyDescriptor keyDesc_;
    /**
     * <pre>
     *
     *A key descriptor describes the key used for performing ECDH. Either a key
     *locator or a raw public key is expected, if neither is supplied, defaults to
     *the node's identity private key.
     * </pre>
     *
     * <code>.signrpc.KeyDescriptor key_desc = 3;</code>
     * @return Whether the keyDesc field is set.
     */
    @java.lang.Override
    public boolean hasKeyDesc() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <pre>
     *
     *A key descriptor describes the key used for performing ECDH. Either a key
     *locator or a raw public key is expected, if neither is supplied, defaults to
     *the node's identity private key.
     * </pre>
     *
     * <code>.signrpc.KeyDescriptor key_desc = 3;</code>
     * @return The keyDesc.
     */
    @java.lang.Override
    public signrpc.SignerOuterClass.KeyDescriptor getKeyDesc() {
      return keyDesc_ == null ? signrpc.SignerOuterClass.KeyDescriptor.getDefaultInstance() : keyDesc_;
    }
    /**
     * <pre>
     *
     *A key descriptor describes the key used for performing ECDH. Either a key
     *locator or a raw public key is expected, if neither is supplied, defaults to
     *the node's identity private key.
     * </pre>
     *
     * <code>.signrpc.KeyDescriptor key_desc = 3;</code>
     */
    @java.lang.Override
    public signrpc.SignerOuterClass.KeyDescriptorOrBuilder getKeyDescOrBuilder() {
      return keyDesc_ == null ? signrpc.SignerOuterClass.KeyDescriptor.getDefaultInstance() : keyDesc_;
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (!ephemeralPubkey_.isEmpty()) {
        output.writeBytes(1, ephemeralPubkey_);
      }
      if (((bitField0_ & 0x00000001) != 0)) {
        output.writeMessage(2, getKeyLoc());
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        output.writeMessage(3, getKeyDesc());
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (!ephemeralPubkey_.isEmpty()) {
        size += com.google.protobuf.CodedOutputStream
          .computeBytesSize(1, ephemeralPubkey_);
      }
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(2, getKeyLoc());
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(3, getKeyDesc());
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof signrpc.SignerOuterClass.SharedKeyRequest)) {
        return super.equals(obj);
      }
      signrpc.SignerOuterClass.SharedKeyRequest other = (signrpc.SignerOuterClass.SharedKeyRequest) obj;

      if (!getEphemeralPubkey()
          .equals(other.getEphemeralPubkey())) return false;
      if (hasKeyLoc() != other.hasKeyLoc()) return false;
      if (hasKeyLoc()) {
        if (!getKeyLoc()
            .equals(other.getKeyLoc())) return false;
      }
      if (hasKeyDesc() != other.hasKeyDesc()) return false;
      if (hasKeyDesc()) {
        if (!getKeyDesc()
            .equals(other.getKeyDesc())) return false;
      }
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      hash = (37 * hash) + EPHEMERAL_PUBKEY_FIELD_NUMBER;
      hash = (53 * hash) + getEphemeralPubkey().hashCode();
      if (hasKeyLoc()) {
        hash = (37 * hash) + KEY_LOC_FIELD_NUMBER;
        hash = (53 * hash) + getKeyLoc().hashCode();
      }
      if (hasKeyDesc()) {
        hash = (37 * hash) + KEY_DESC_FIELD_NUMBER;
        hash = (53 * hash) + getKeyDesc().hashCode();
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static signrpc.SignerOuterClass.SharedKeyRequest parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static signrpc.SignerOuterClass.SharedKeyRequest parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static signrpc.SignerOuterClass.SharedKeyRequest parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static signrpc.SignerOuterClass.SharedKeyRequest parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static signrpc.SignerOuterClass.SharedKeyRequest parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static signrpc.SignerOuterClass.SharedKeyRequest parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static signrpc.SignerOuterClass.SharedKeyRequest parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static signrpc.SignerOuterClass.SharedKeyRequest parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static signrpc.SignerOuterClass.SharedKeyRequest parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static signrpc.SignerOuterClass.SharedKeyRequest parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static signrpc.SignerOuterClass.SharedKeyRequest parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static signrpc.SignerOuterClass.SharedKeyRequest parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(signrpc.SignerOuterClass.SharedKeyRequest prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * Protobuf type {@code signrpc.SharedKeyRequest}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:signrpc.SharedKeyRequest)
        signrpc.SignerOuterClass.SharedKeyRequestOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return signrpc.SignerOuterClass.internal_static_signrpc_SharedKeyRequest_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return signrpc.SignerOuterClass.internal_static_signrpc_SharedKeyRequest_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                signrpc.SignerOuterClass.SharedKeyRequest.class, signrpc.SignerOuterClass.SharedKeyRequest.Builder.class);
      }

      // Construct using signrpc.SignerOuterClass.SharedKeyRequest.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
          getKeyLocFieldBuilder();
          getKeyDescFieldBuilder();
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        ephemeralPubkey_ = com.google.protobuf.ByteString.EMPTY;
        keyLoc_ = null;
        if (keyLocBuilder_ != null) {
          keyLocBuilder_.dispose();
          keyLocBuilder_ = null;
        }
        keyDesc_ = null;
        if (keyDescBuilder_ != null) {
          keyDescBuilder_.dispose();
          keyDescBuilder_ = null;
        }
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return signrpc.SignerOuterClass.internal_static_signrpc_SharedKeyRequest_descriptor;
      }

      @java.lang.Override
      public signrpc.SignerOuterClass.SharedKeyRequest getDefaultInstanceForType() {
        return signrpc.SignerOuterClass.SharedKeyRequest.getDefaultInstance();
      }

      @java.lang.Override
      public signrpc.SignerOuterClass.SharedKeyRequest build() {
        signrpc.SignerOuterClass.SharedKeyRequest result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public signrpc.SignerOuterClass.SharedKeyRequest buildPartial() {
        signrpc.SignerOuterClass.SharedKeyRequest result = new signrpc.SignerOuterClass.SharedKeyRequest(this);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartial0(signrpc.SignerOuterClass.SharedKeyRequest result) {
        int from_bitField0_ = bitField0_;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.ephemeralPubkey_ = ephemeralPubkey_;
        }
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000002) != 0)) {
          result.keyLoc_ = keyLocBuilder_ == null
              ? keyLoc_
              : keyLocBuilder_.build();
          to_bitField0_ |= 0x00000001;
        }
        if (((from_bitField0_ & 0x00000004) != 0)) {
          result.keyDesc_ = keyDescBuilder_ == null
              ? keyDesc_
              : keyDescBuilder_.build();
          to_bitField0_ |= 0x00000002;
        }
        result.bitField0_ |= to_bitField0_;
      }

      @java.lang.Override
      public Builder clone() {
        return super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof signrpc.SignerOuterClass.SharedKeyRequest) {
          return mergeFrom((signrpc.SignerOuterClass.SharedKeyRequest)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(signrpc.SignerOuterClass.SharedKeyRequest other) {
        if (other == signrpc.SignerOuterClass.SharedKeyRequest.getDefaultInstance()) return this;
        if (other.getEphemeralPubkey() != com.google.protobuf.ByteString.EMPTY) {
          setEphemeralPubkey(other.getEphemeralPubkey());
        }
        if (other.hasKeyLoc()) {
          mergeKeyLoc(other.getKeyLoc());
        }
        if (other.hasKeyDesc()) {
          mergeKeyDesc(other.getKeyDesc());
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10: {
                ephemeralPubkey_ = input.readBytes();
                bitField0_ |= 0x00000001;
                break;
              } // case 10
              case 18: {
                input.readMessage(
                    getKeyLocFieldBuilder().getBuilder(),
                    extensionRegistry);
                bitField0_ |= 0x00000002;
                break;
              } // case 18
              case 26: {
                input.readMessage(
                    getKeyDescFieldBuilder().getBuilder(),
                    extensionRegistry);
                bitField0_ |= 0x00000004;
                break;
              } // case 26
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private com.google.protobuf.ByteString ephemeralPubkey_ = com.google.protobuf.ByteString.EMPTY;
      /**
       * <pre>
       * The ephemeral public key to use for the DH key derivation.
       * </pre>
       *
       * <code>bytes ephemeral_pubkey = 1;</code>
       * @return The ephemeralPubkey.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString getEphemeralPubkey() {
        return ephemeralPubkey_;
      }
      /**
       * <pre>
       * The ephemeral public key to use for the DH key derivation.
       * </pre>
       *
       * <code>bytes ephemeral_pubkey = 1;</code>
       * @param value The ephemeralPubkey to set.
       * @return This builder for chaining.
       */
      public Builder setEphemeralPubkey(com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        ephemeralPubkey_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The ephemeral public key to use for the DH key derivation.
       * </pre>
       *
       * <code>bytes ephemeral_pubkey = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearEphemeralPubkey() {
        bitField0_ = (bitField0_ & ~0x00000001);
        ephemeralPubkey_ = getDefaultInstance().getEphemeralPubkey();
        onChanged();
        return this;
      }

      private signrpc.SignerOuterClass.KeyLocator keyLoc_;
      private com.google.protobuf.SingleFieldBuilderV3<
          signrpc.SignerOuterClass.KeyLocator, signrpc.SignerOuterClass.KeyLocator.Builder, signrpc.SignerOuterClass.KeyLocatorOrBuilder> keyLocBuilder_;
      /**
       * <pre>
       *
       *Deprecated. The optional key locator of the local key that should be used.
       *If this parameter is not set then the node's identity private key will be
       *used.
       * </pre>
       *
       * <code>.signrpc.KeyLocator key_loc = 2 [deprecated = true];</code>
       * @deprecated signrpc.SharedKeyRequest.key_loc is deprecated.
       *     See signrpc/signer.proto;l=398
       * @return Whether the keyLoc field is set.
       */
      @java.lang.Deprecated public boolean hasKeyLoc() {
        return ((bitField0_ & 0x00000002) != 0);
      }
      /**
       * <pre>
       *
       *Deprecated. The optional key locator of the local key that should be used.
       *If this parameter is not set then the node's identity private key will be
       *used.
       * </pre>
       *
       * <code>.signrpc.KeyLocator key_loc = 2 [deprecated = true];</code>
       * @deprecated signrpc.SharedKeyRequest.key_loc is deprecated.
       *     See signrpc/signer.proto;l=398
       * @return The keyLoc.
       */
      @java.lang.Deprecated public signrpc.SignerOuterClass.KeyLocator getKeyLoc() {
        if (keyLocBuilder_ == null) {
          return keyLoc_ == null ? signrpc.SignerOuterClass.KeyLocator.getDefaultInstance() : keyLoc_;
        } else {
          return keyLocBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       *
       *Deprecated. The optional key locator of the local key that should be used.
       *If this parameter is not set then the node's identity private key will be
       *used.
       * </pre>
       *
       * <code>.signrpc.KeyLocator key_loc = 2 [deprecated = true];</code>
       */
      @java.lang.Deprecated public Builder setKeyLoc(signrpc.SignerOuterClass.KeyLocator value) {
        if (keyLocBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          keyLoc_ = value;
        } else {
          keyLocBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       *
       *Deprecated. The optional key locator of the local key that should be used.
       *If this parameter is not set then the node's identity private key will be
       *used.
       * </pre>
       *
       * <code>.signrpc.KeyLocator key_loc = 2 [deprecated = true];</code>
       */
      @java.lang.Deprecated public Builder setKeyLoc(
          signrpc.SignerOuterClass.KeyLocator.Builder builderForValue) {
        if (keyLocBuilder_ == null) {
          keyLoc_ = builderForValue.build();
        } else {
          keyLocBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       *
       *Deprecated. The optional key locator of the local key that should be used.
       *If this parameter is not set then the node's identity private key will be
       *used.
       * </pre>
       *
       * <code>.signrpc.KeyLocator key_loc = 2 [deprecated = true];</code>
       */
      @java.lang.Deprecated public Builder mergeKeyLoc(signrpc.SignerOuterClass.KeyLocator value) {
        if (keyLocBuilder_ == null) {
          if (((bitField0_ & 0x00000002) != 0) &&
            keyLoc_ != null &&
            keyLoc_ != signrpc.SignerOuterClass.KeyLocator.getDefaultInstance()) {
            getKeyLocBuilder().mergeFrom(value);
          } else {
            keyLoc_ = value;
          }
        } else {
          keyLocBuilder_.mergeFrom(value);
        }
        if (keyLoc_ != null) {
          bitField0_ |= 0x00000002;
          onChanged();
        }
        return this;
      }
      /**
       * <pre>
       *
       *Deprecated. The optional key locator of the local key that should be used.
       *If this parameter is not set then the node's identity private key will be
       *used.
       * </pre>
       *
       * <code>.signrpc.KeyLocator key_loc = 2 [deprecated = true];</code>
       */
      @java.lang.Deprecated public Builder clearKeyLoc() {
        bitField0_ = (bitField0_ & ~0x00000002);
        keyLoc_ = null;
        if (keyLocBuilder_ != null) {
          keyLocBuilder_.dispose();
          keyLocBuilder_ = null;
        }
        onChanged();
        return this;
      }
      /**
       * <pre>
       *
       *Deprecated. The optional key locator of the local key that should be used.
       *If this parameter is not set then the node's identity private key will be
       *used.
       * </pre>
       *
       * <code>.signrpc.KeyLocator key_loc = 2 [deprecated = true];</code>
       */
      @java.lang.Deprecated public signrpc.SignerOuterClass.KeyLocator.Builder getKeyLocBuilder() {
        bitField0_ |= 0x00000002;
        onChanged();
        return getKeyLocFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       *
       *Deprecated. The optional key locator of the local key that should be used.
       *If this parameter is not set then the node's identity private key will be
       *used.
       * </pre>
       *
       * <code>.signrpc.KeyLocator key_loc = 2 [deprecated = true];</code>
       */
      @java.lang.Deprecated public signrpc.SignerOuterClass.KeyLocatorOrBuilder getKeyLocOrBuilder() {
        if (keyLocBuilder_ != null) {
          return keyLocBuilder_.getMessageOrBuilder();
        } else {
          return keyLoc_ == null ?
              signrpc.SignerOuterClass.KeyLocator.getDefaultInstance() : keyLoc_;
        }
      }
      /**
       * <pre>
       *
       *Deprecated. The optional key locator of the local key that should be used.
       *If this parameter is not set then the node's identity private key will be
       *used.
       * </pre>
       *
       * <code>.signrpc.KeyLocator key_loc = 2 [deprecated = true];</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          signrpc.SignerOuterClass.KeyLocator, signrpc.SignerOuterClass.KeyLocator.Builder, signrpc.SignerOuterClass.KeyLocatorOrBuilder> 
          getKeyLocFieldBuilder() {
        if (keyLocBuilder_ == null) {
          keyLocBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              signrpc.SignerOuterClass.KeyLocator, signrpc.SignerOuterClass.KeyLocator.Builder, signrpc.SignerOuterClass.KeyLocatorOrBuilder>(
                  getKeyLoc(),
                  getParentForChildren(),
                  isClean());
          keyLoc_ = null;
        }
        return keyLocBuilder_;
      }

      private signrpc.SignerOuterClass.KeyDescriptor keyDesc_;
      private com.google.protobuf.SingleFieldBuilderV3<
          signrpc.SignerOuterClass.KeyDescriptor, signrpc.SignerOuterClass.KeyDescriptor.Builder, signrpc.SignerOuterClass.KeyDescriptorOrBuilder> keyDescBuilder_;
      /**
       * <pre>
       *
       *A key descriptor describes the key used for performing ECDH. Either a key
       *locator or a raw public key is expected, if neither is supplied, defaults to
       *the node's identity private key.
       * </pre>
       *
       * <code>.signrpc.KeyDescriptor key_desc = 3;</code>
       * @return Whether the keyDesc field is set.
       */
      public boolean hasKeyDesc() {
        return ((bitField0_ & 0x00000004) != 0);
      }
      /**
       * <pre>
       *
       *A key descriptor describes the key used for performing ECDH. Either a key
       *locator or a raw public key is expected, if neither is supplied, defaults to
       *the node's identity private key.
       * </pre>
       *
       * <code>.signrpc.KeyDescriptor key_desc = 3;</code>
       * @return The keyDesc.
       */
      public signrpc.SignerOuterClass.KeyDescriptor getKeyDesc() {
        if (keyDescBuilder_ == null) {
          return keyDesc_ == null ? signrpc.SignerOuterClass.KeyDescriptor.getDefaultInstance() : keyDesc_;
        } else {
          return keyDescBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       *
       *A key descriptor describes the key used for performing ECDH. Either a key
       *locator or a raw public key is expected, if neither is supplied, defaults to
       *the node's identity private key.
       * </pre>
       *
       * <code>.signrpc.KeyDescriptor key_desc = 3;</code>
       */
      public Builder setKeyDesc(signrpc.SignerOuterClass.KeyDescriptor value) {
        if (keyDescBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          keyDesc_ = value;
        } else {
          keyDescBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }
      /**
       * <pre>
       *
       *A key descriptor describes the key used for performing ECDH. Either a key
       *locator or a raw public key is expected, if neither is supplied, defaults to
       *the node's identity private key.
       * </pre>
       *
       * <code>.signrpc.KeyDescriptor key_desc = 3;</code>
       */
      public Builder setKeyDesc(
          signrpc.SignerOuterClass.KeyDescriptor.Builder builderForValue) {
        if (keyDescBuilder_ == null) {
          keyDesc_ = builderForValue.build();
        } else {
          keyDescBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }
      /**
       * <pre>
       *
       *A key descriptor describes the key used for performing ECDH. Either a key
       *locator or a raw public key is expected, if neither is supplied, defaults to
       *the node's identity private key.
       * </pre>
       *
       * <code>.signrpc.KeyDescriptor key_desc = 3;</code>
       */
      public Builder mergeKeyDesc(signrpc.SignerOuterClass.KeyDescriptor value) {
        if (keyDescBuilder_ == null) {
          if (((bitField0_ & 0x00000004) != 0) &&
            keyDesc_ != null &&
            keyDesc_ != signrpc.SignerOuterClass.KeyDescriptor.getDefaultInstance()) {
            getKeyDescBuilder().mergeFrom(value);
          } else {
            keyDesc_ = value;
          }
        } else {
          keyDescBuilder_.mergeFrom(value);
        }
        if (keyDesc_ != null) {
          bitField0_ |= 0x00000004;
          onChanged();
        }
        return this;
      }
      /**
       * <pre>
       *
       *A key descriptor describes the key used for performing ECDH. Either a key
       *locator or a raw public key is expected, if neither is supplied, defaults to
       *the node's identity private key.
       * </pre>
       *
       * <code>.signrpc.KeyDescriptor key_desc = 3;</code>
       */
      public Builder clearKeyDesc() {
        bitField0_ = (bitField0_ & ~0x00000004);
        keyDesc_ = null;
        if (keyDescBuilder_ != null) {
          keyDescBuilder_.dispose();
          keyDescBuilder_ = null;
        }
        onChanged();
        return this;
      }
      /**
       * <pre>
       *
       *A key descriptor describes the key used for performing ECDH. Either a key
       *locator or a raw public key is expected, if neither is supplied, defaults to
       *the node's identity private key.
       * </pre>
       *
       * <code>.signrpc.KeyDescriptor key_desc = 3;</code>
       */
      public signrpc.SignerOuterClass.KeyDescriptor.Builder getKeyDescBuilder() {
        bitField0_ |= 0x00000004;
        onChanged();
        return getKeyDescFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       *
       *A key descriptor describes the key used for performing ECDH. Either a key
       *locator or a raw public key is expected, if neither is supplied, defaults to
       *the node's identity private key.
       * </pre>
       *
       * <code>.signrpc.KeyDescriptor key_desc = 3;</code>
       */
      public signrpc.SignerOuterClass.KeyDescriptorOrBuilder getKeyDescOrBuilder() {
        if (keyDescBuilder_ != null) {
          return keyDescBuilder_.getMessageOrBuilder();
        } else {
          return keyDesc_ == null ?
              signrpc.SignerOuterClass.KeyDescriptor.getDefaultInstance() : keyDesc_;
        }
      }
      /**
       * <pre>
       *
       *A key descriptor describes the key used for performing ECDH. Either a key
       *locator or a raw public key is expected, if neither is supplied, defaults to
       *the node's identity private key.
       * </pre>
       *
       * <code>.signrpc.KeyDescriptor key_desc = 3;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          signrpc.SignerOuterClass.KeyDescriptor, signrpc.SignerOuterClass.KeyDescriptor.Builder, signrpc.SignerOuterClass.KeyDescriptorOrBuilder> 
          getKeyDescFieldBuilder() {
        if (keyDescBuilder_ == null) {
          keyDescBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              signrpc.SignerOuterClass.KeyDescriptor, signrpc.SignerOuterClass.KeyDescriptor.Builder, signrpc.SignerOuterClass.KeyDescriptorOrBuilder>(
                  getKeyDesc(),
                  getParentForChildren(),
                  isClean());
          keyDesc_ = null;
        }
        return keyDescBuilder_;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:signrpc.SharedKeyRequest)
    }

    // @@protoc_insertion_point(class_scope:signrpc.SharedKeyRequest)
    private static final signrpc.SignerOuterClass.SharedKeyRequest DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new signrpc.SignerOuterClass.SharedKeyRequest();
    }

    public static signrpc.SignerOuterClass.SharedKeyRequest getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<SharedKeyRequest>
        PARSER = new com.google.protobuf.AbstractParser<SharedKeyRequest>() {
      @java.lang.Override
      public SharedKeyRequest parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<SharedKeyRequest> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<SharedKeyRequest> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public signrpc.SignerOuterClass.SharedKeyRequest getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface SharedKeyResponseOrBuilder extends
      // @@protoc_insertion_point(interface_extends:signrpc.SharedKeyResponse)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * The shared public key, hashed with sha256.
     * </pre>
     *
     * <code>bytes shared_key = 1;</code>
     * @return The sharedKey.
     */
    com.google.protobuf.ByteString getSharedKey();
  }
  /**
   * Protobuf type {@code signrpc.SharedKeyResponse}
   */
  public static final class SharedKeyResponse extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:signrpc.SharedKeyResponse)
      SharedKeyResponseOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use SharedKeyResponse.newBuilder() to construct.
    private SharedKeyResponse(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private SharedKeyResponse() {
      sharedKey_ = com.google.protobuf.ByteString.EMPTY;
    }

    @java.lang.Override
    @SuppressWarnings({"unused"})
    protected java.lang.Object newInstance(
        UnusedPrivateParameter unused) {
      return new SharedKeyResponse();
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return signrpc.SignerOuterClass.internal_static_signrpc_SharedKeyResponse_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return signrpc.SignerOuterClass.internal_static_signrpc_SharedKeyResponse_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              signrpc.SignerOuterClass.SharedKeyResponse.class, signrpc.SignerOuterClass.SharedKeyResponse.Builder.class);
    }

    public static final int SHARED_KEY_FIELD_NUMBER = 1;
    private com.google.protobuf.ByteString sharedKey_ = com.google.protobuf.ByteString.EMPTY;
    /**
     * <pre>
     * The shared public key, hashed with sha256.
     * </pre>
     *
     * <code>bytes shared_key = 1;</code>
     * @return The sharedKey.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString getSharedKey() {
      return sharedKey_;
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (!sharedKey_.isEmpty()) {
        output.writeBytes(1, sharedKey_);
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (!sharedKey_.isEmpty()) {
        size += com.google.protobuf.CodedOutputStream
          .computeBytesSize(1, sharedKey_);
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof signrpc.SignerOuterClass.SharedKeyResponse)) {
        return super.equals(obj);
      }
      signrpc.SignerOuterClass.SharedKeyResponse other = (signrpc.SignerOuterClass.SharedKeyResponse) obj;

      if (!getSharedKey()
          .equals(other.getSharedKey())) return false;
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      hash = (37 * hash) + SHARED_KEY_FIELD_NUMBER;
      hash = (53 * hash) + getSharedKey().hashCode();
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static signrpc.SignerOuterClass.SharedKeyResponse parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static signrpc.SignerOuterClass.SharedKeyResponse parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static signrpc.SignerOuterClass.SharedKeyResponse parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static signrpc.SignerOuterClass.SharedKeyResponse parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static signrpc.SignerOuterClass.SharedKeyResponse parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static signrpc.SignerOuterClass.SharedKeyResponse parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static signrpc.SignerOuterClass.SharedKeyResponse parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static signrpc.SignerOuterClass.SharedKeyResponse parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static signrpc.SignerOuterClass.SharedKeyResponse parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static signrpc.SignerOuterClass.SharedKeyResponse parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static signrpc.SignerOuterClass.SharedKeyResponse parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static signrpc.SignerOuterClass.SharedKeyResponse parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(signrpc.SignerOuterClass.SharedKeyResponse prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * Protobuf type {@code signrpc.SharedKeyResponse}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:signrpc.SharedKeyResponse)
        signrpc.SignerOuterClass.SharedKeyResponseOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return signrpc.SignerOuterClass.internal_static_signrpc_SharedKeyResponse_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return signrpc.SignerOuterClass.internal_static_signrpc_SharedKeyResponse_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                signrpc.SignerOuterClass.SharedKeyResponse.class, signrpc.SignerOuterClass.SharedKeyResponse.Builder.class);
      }

      // Construct using signrpc.SignerOuterClass.SharedKeyResponse.newBuilder()
      private Builder() {

      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);

      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        sharedKey_ = com.google.protobuf.ByteString.EMPTY;
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return signrpc.SignerOuterClass.internal_static_signrpc_SharedKeyResponse_descriptor;
      }

      @java.lang.Override
      public signrpc.SignerOuterClass.SharedKeyResponse getDefaultInstanceForType() {
        return signrpc.SignerOuterClass.SharedKeyResponse.getDefaultInstance();
      }

      @java.lang.Override
      public signrpc.SignerOuterClass.SharedKeyResponse build() {
        signrpc.SignerOuterClass.SharedKeyResponse result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public signrpc.SignerOuterClass.SharedKeyResponse buildPartial() {
        signrpc.SignerOuterClass.SharedKeyResponse result = new signrpc.SignerOuterClass.SharedKeyResponse(this);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartial0(signrpc.SignerOuterClass.SharedKeyResponse result) {
        int from_bitField0_ = bitField0_;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.sharedKey_ = sharedKey_;
        }
      }

      @java.lang.Override
      public Builder clone() {
        return super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof signrpc.SignerOuterClass.SharedKeyResponse) {
          return mergeFrom((signrpc.SignerOuterClass.SharedKeyResponse)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(signrpc.SignerOuterClass.SharedKeyResponse other) {
        if (other == signrpc.SignerOuterClass.SharedKeyResponse.getDefaultInstance()) return this;
        if (other.getSharedKey() != com.google.protobuf.ByteString.EMPTY) {
          setSharedKey(other.getSharedKey());
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10: {
                sharedKey_ = input.readBytes();
                bitField0_ |= 0x00000001;
                break;
              } // case 10
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private com.google.protobuf.ByteString sharedKey_ = com.google.protobuf.ByteString.EMPTY;
      /**
       * <pre>
       * The shared public key, hashed with sha256.
       * </pre>
       *
       * <code>bytes shared_key = 1;</code>
       * @return The sharedKey.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString getSharedKey() {
        return sharedKey_;
      }
      /**
       * <pre>
       * The shared public key, hashed with sha256.
       * </pre>
       *
       * <code>bytes shared_key = 1;</code>
       * @param value The sharedKey to set.
       * @return This builder for chaining.
       */
      public Builder setSharedKey(com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        sharedKey_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The shared public key, hashed with sha256.
       * </pre>
       *
       * <code>bytes shared_key = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearSharedKey() {
        bitField0_ = (bitField0_ & ~0x00000001);
        sharedKey_ = getDefaultInstance().getSharedKey();
        onChanged();
        return this;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:signrpc.SharedKeyResponse)
    }

    // @@protoc_insertion_point(class_scope:signrpc.SharedKeyResponse)
    private static final signrpc.SignerOuterClass.SharedKeyResponse DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new signrpc.SignerOuterClass.SharedKeyResponse();
    }

    public static signrpc.SignerOuterClass.SharedKeyResponse getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<SharedKeyResponse>
        PARSER = new com.google.protobuf.AbstractParser<SharedKeyResponse>() {
      @java.lang.Override
      public SharedKeyResponse parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<SharedKeyResponse> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<SharedKeyResponse> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public signrpc.SignerOuterClass.SharedKeyResponse getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface TweakDescOrBuilder extends
      // @@protoc_insertion_point(interface_extends:signrpc.TweakDesc)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     *
     *Tweak is the 32-byte value that will modify the public key.
     * </pre>
     *
     * <code>bytes tweak = 1;</code>
     * @return The tweak.
     */
    com.google.protobuf.ByteString getTweak();

    /**
     * <pre>
     *
     *Specifies if the target key should be converted to an x-only public key
     *before tweaking. If true, then the public key will be mapped to an x-only
     *key before the tweaking operation is applied.
     * </pre>
     *
     * <code>bool is_x_only = 2;</code>
     * @return The isXOnly.
     */
    boolean getIsXOnly();
  }
  /**
   * Protobuf type {@code signrpc.TweakDesc}
   */
  public static final class TweakDesc extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:signrpc.TweakDesc)
      TweakDescOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use TweakDesc.newBuilder() to construct.
    private TweakDesc(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private TweakDesc() {
      tweak_ = com.google.protobuf.ByteString.EMPTY;
    }

    @java.lang.Override
    @SuppressWarnings({"unused"})
    protected java.lang.Object newInstance(
        UnusedPrivateParameter unused) {
      return new TweakDesc();
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return signrpc.SignerOuterClass.internal_static_signrpc_TweakDesc_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return signrpc.SignerOuterClass.internal_static_signrpc_TweakDesc_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              signrpc.SignerOuterClass.TweakDesc.class, signrpc.SignerOuterClass.TweakDesc.Builder.class);
    }

    public static final int TWEAK_FIELD_NUMBER = 1;
    private com.google.protobuf.ByteString tweak_ = com.google.protobuf.ByteString.EMPTY;
    /**
     * <pre>
     *
     *Tweak is the 32-byte value that will modify the public key.
     * </pre>
     *
     * <code>bytes tweak = 1;</code>
     * @return The tweak.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString getTweak() {
      return tweak_;
    }

    public static final int IS_X_ONLY_FIELD_NUMBER = 2;
    private boolean isXOnly_ = false;
    /**
     * <pre>
     *
     *Specifies if the target key should be converted to an x-only public key
     *before tweaking. If true, then the public key will be mapped to an x-only
     *key before the tweaking operation is applied.
     * </pre>
     *
     * <code>bool is_x_only = 2;</code>
     * @return The isXOnly.
     */
    @java.lang.Override
    public boolean getIsXOnly() {
      return isXOnly_;
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (!tweak_.isEmpty()) {
        output.writeBytes(1, tweak_);
      }
      if (isXOnly_ != false) {
        output.writeBool(2, isXOnly_);
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (!tweak_.isEmpty()) {
        size += com.google.protobuf.CodedOutputStream
          .computeBytesSize(1, tweak_);
      }
      if (isXOnly_ != false) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(2, isXOnly_);
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof signrpc.SignerOuterClass.TweakDesc)) {
        return super.equals(obj);
      }
      signrpc.SignerOuterClass.TweakDesc other = (signrpc.SignerOuterClass.TweakDesc) obj;

      if (!getTweak()
          .equals(other.getTweak())) return false;
      if (getIsXOnly()
          != other.getIsXOnly()) return false;
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      hash = (37 * hash) + TWEAK_FIELD_NUMBER;
      hash = (53 * hash) + getTweak().hashCode();
      hash = (37 * hash) + IS_X_ONLY_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
          getIsXOnly());
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static signrpc.SignerOuterClass.TweakDesc parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static signrpc.SignerOuterClass.TweakDesc parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static signrpc.SignerOuterClass.TweakDesc parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static signrpc.SignerOuterClass.TweakDesc parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static signrpc.SignerOuterClass.TweakDesc parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static signrpc.SignerOuterClass.TweakDesc parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static signrpc.SignerOuterClass.TweakDesc parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static signrpc.SignerOuterClass.TweakDesc parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static signrpc.SignerOuterClass.TweakDesc parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static signrpc.SignerOuterClass.TweakDesc parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static signrpc.SignerOuterClass.TweakDesc parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static signrpc.SignerOuterClass.TweakDesc parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(signrpc.SignerOuterClass.TweakDesc prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * Protobuf type {@code signrpc.TweakDesc}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:signrpc.TweakDesc)
        signrpc.SignerOuterClass.TweakDescOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return signrpc.SignerOuterClass.internal_static_signrpc_TweakDesc_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return signrpc.SignerOuterClass.internal_static_signrpc_TweakDesc_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                signrpc.SignerOuterClass.TweakDesc.class, signrpc.SignerOuterClass.TweakDesc.Builder.class);
      }

      // Construct using signrpc.SignerOuterClass.TweakDesc.newBuilder()
      private Builder() {

      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);

      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        tweak_ = com.google.protobuf.ByteString.EMPTY;
        isXOnly_ = false;
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return signrpc.SignerOuterClass.internal_static_signrpc_TweakDesc_descriptor;
      }

      @java.lang.Override
      public signrpc.SignerOuterClass.TweakDesc getDefaultInstanceForType() {
        return signrpc.SignerOuterClass.TweakDesc.getDefaultInstance();
      }

      @java.lang.Override
      public signrpc.SignerOuterClass.TweakDesc build() {
        signrpc.SignerOuterClass.TweakDesc result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public signrpc.SignerOuterClass.TweakDesc buildPartial() {
        signrpc.SignerOuterClass.TweakDesc result = new signrpc.SignerOuterClass.TweakDesc(this);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartial0(signrpc.SignerOuterClass.TweakDesc result) {
        int from_bitField0_ = bitField0_;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.tweak_ = tweak_;
        }
        if (((from_bitField0_ & 0x00000002) != 0)) {
          result.isXOnly_ = isXOnly_;
        }
      }

      @java.lang.Override
      public Builder clone() {
        return super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof signrpc.SignerOuterClass.TweakDesc) {
          return mergeFrom((signrpc.SignerOuterClass.TweakDesc)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(signrpc.SignerOuterClass.TweakDesc other) {
        if (other == signrpc.SignerOuterClass.TweakDesc.getDefaultInstance()) return this;
        if (other.getTweak() != com.google.protobuf.ByteString.EMPTY) {
          setTweak(other.getTweak());
        }
        if (other.getIsXOnly() != false) {
          setIsXOnly(other.getIsXOnly());
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10: {
                tweak_ = input.readBytes();
                bitField0_ |= 0x00000001;
                break;
              } // case 10
              case 16: {
                isXOnly_ = input.readBool();
                bitField0_ |= 0x00000002;
                break;
              } // case 16
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private com.google.protobuf.ByteString tweak_ = com.google.protobuf.ByteString.EMPTY;
      /**
       * <pre>
       *
       *Tweak is the 32-byte value that will modify the public key.
       * </pre>
       *
       * <code>bytes tweak = 1;</code>
       * @return The tweak.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString getTweak() {
        return tweak_;
      }
      /**
       * <pre>
       *
       *Tweak is the 32-byte value that will modify the public key.
       * </pre>
       *
       * <code>bytes tweak = 1;</code>
       * @param value The tweak to set.
       * @return This builder for chaining.
       */
      public Builder setTweak(com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        tweak_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       *
       *Tweak is the 32-byte value that will modify the public key.
       * </pre>
       *
       * <code>bytes tweak = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearTweak() {
        bitField0_ = (bitField0_ & ~0x00000001);
        tweak_ = getDefaultInstance().getTweak();
        onChanged();
        return this;
      }

      private boolean isXOnly_ ;
      /**
       * <pre>
       *
       *Specifies if the target key should be converted to an x-only public key
       *before tweaking. If true, then the public key will be mapped to an x-only
       *key before the tweaking operation is applied.
       * </pre>
       *
       * <code>bool is_x_only = 2;</code>
       * @return The isXOnly.
       */
      @java.lang.Override
      public boolean getIsXOnly() {
        return isXOnly_;
      }
      /**
       * <pre>
       *
       *Specifies if the target key should be converted to an x-only public key
       *before tweaking. If true, then the public key will be mapped to an x-only
       *key before the tweaking operation is applied.
       * </pre>
       *
       * <code>bool is_x_only = 2;</code>
       * @param value The isXOnly to set.
       * @return This builder for chaining.
       */
      public Builder setIsXOnly(boolean value) {

        isXOnly_ = value;
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       *
       *Specifies if the target key should be converted to an x-only public key
       *before tweaking. If true, then the public key will be mapped to an x-only
       *key before the tweaking operation is applied.
       * </pre>
       *
       * <code>bool is_x_only = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearIsXOnly() {
        bitField0_ = (bitField0_ & ~0x00000002);
        isXOnly_ = false;
        onChanged();
        return this;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:signrpc.TweakDesc)
    }

    // @@protoc_insertion_point(class_scope:signrpc.TweakDesc)
    private static final signrpc.SignerOuterClass.TweakDesc DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new signrpc.SignerOuterClass.TweakDesc();
    }

    public static signrpc.SignerOuterClass.TweakDesc getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<TweakDesc>
        PARSER = new com.google.protobuf.AbstractParser<TweakDesc>() {
      @java.lang.Override
      public TweakDesc parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<TweakDesc> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<TweakDesc> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public signrpc.SignerOuterClass.TweakDesc getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface TaprootTweakDescOrBuilder extends
      // @@protoc_insertion_point(interface_extends:signrpc.TaprootTweakDesc)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     *
     *The root hash of the tapscript tree if a script path is committed to. If
     *the MuSig2 key put on chain doesn't also commit to a script path (BIP-0086
     *key spend only), then this needs to be empty and the key_spend_only field
     *below must be set to true. This is required because gRPC cannot
     *differentiate between a zero-size byte slice and a nil byte slice (both
     *would be serialized the same way). So the extra boolean is required.
     * </pre>
     *
     * <code>bytes script_root = 1;</code>
     * @return The scriptRoot.
     */
    com.google.protobuf.ByteString getScriptRoot();

    /**
     * <pre>
     *
     *Indicates that the above script_root is expected to be empty because this
     *is a BIP-0086 key spend only commitment where only the internal key is
     *committed to instead of also including a script root hash.
     * </pre>
     *
     * <code>bool key_spend_only = 2;</code>
     * @return The keySpendOnly.
     */
    boolean getKeySpendOnly();
  }
  /**
   * Protobuf type {@code signrpc.TaprootTweakDesc}
   */
  public static final class TaprootTweakDesc extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:signrpc.TaprootTweakDesc)
      TaprootTweakDescOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use TaprootTweakDesc.newBuilder() to construct.
    private TaprootTweakDesc(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private TaprootTweakDesc() {
      scriptRoot_ = com.google.protobuf.ByteString.EMPTY;
    }

    @java.lang.Override
    @SuppressWarnings({"unused"})
    protected java.lang.Object newInstance(
        UnusedPrivateParameter unused) {
      return new TaprootTweakDesc();
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return signrpc.SignerOuterClass.internal_static_signrpc_TaprootTweakDesc_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return signrpc.SignerOuterClass.internal_static_signrpc_TaprootTweakDesc_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              signrpc.SignerOuterClass.TaprootTweakDesc.class, signrpc.SignerOuterClass.TaprootTweakDesc.Builder.class);
    }

    public static final int SCRIPT_ROOT_FIELD_NUMBER = 1;
    private com.google.protobuf.ByteString scriptRoot_ = com.google.protobuf.ByteString.EMPTY;
    /**
     * <pre>
     *
     *The root hash of the tapscript tree if a script path is committed to. If
     *the MuSig2 key put on chain doesn't also commit to a script path (BIP-0086
     *key spend only), then this needs to be empty and the key_spend_only field
     *below must be set to true. This is required because gRPC cannot
     *differentiate between a zero-size byte slice and a nil byte slice (both
     *would be serialized the same way). So the extra boolean is required.
     * </pre>
     *
     * <code>bytes script_root = 1;</code>
     * @return The scriptRoot.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString getScriptRoot() {
      return scriptRoot_;
    }

    public static final int KEY_SPEND_ONLY_FIELD_NUMBER = 2;
    private boolean keySpendOnly_ = false;
    /**
     * <pre>
     *
     *Indicates that the above script_root is expected to be empty because this
     *is a BIP-0086 key spend only commitment where only the internal key is
     *committed to instead of also including a script root hash.
     * </pre>
     *
     * <code>bool key_spend_only = 2;</code>
     * @return The keySpendOnly.
     */
    @java.lang.Override
    public boolean getKeySpendOnly() {
      return keySpendOnly_;
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (!scriptRoot_.isEmpty()) {
        output.writeBytes(1, scriptRoot_);
      }
      if (keySpendOnly_ != false) {
        output.writeBool(2, keySpendOnly_);
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (!scriptRoot_.isEmpty()) {
        size += com.google.protobuf.CodedOutputStream
          .computeBytesSize(1, scriptRoot_);
      }
      if (keySpendOnly_ != false) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(2, keySpendOnly_);
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof signrpc.SignerOuterClass.TaprootTweakDesc)) {
        return super.equals(obj);
      }
      signrpc.SignerOuterClass.TaprootTweakDesc other = (signrpc.SignerOuterClass.TaprootTweakDesc) obj;

      if (!getScriptRoot()
          .equals(other.getScriptRoot())) return false;
      if (getKeySpendOnly()
          != other.getKeySpendOnly()) return false;
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      hash = (37 * hash) + SCRIPT_ROOT_FIELD_NUMBER;
      hash = (53 * hash) + getScriptRoot().hashCode();
      hash = (37 * hash) + KEY_SPEND_ONLY_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
          getKeySpendOnly());
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static signrpc.SignerOuterClass.TaprootTweakDesc parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static signrpc.SignerOuterClass.TaprootTweakDesc parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static signrpc.SignerOuterClass.TaprootTweakDesc parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static signrpc.SignerOuterClass.TaprootTweakDesc parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static signrpc.SignerOuterClass.TaprootTweakDesc parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static signrpc.SignerOuterClass.TaprootTweakDesc parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static signrpc.SignerOuterClass.TaprootTweakDesc parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static signrpc.SignerOuterClass.TaprootTweakDesc parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static signrpc.SignerOuterClass.TaprootTweakDesc parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static signrpc.SignerOuterClass.TaprootTweakDesc parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static signrpc.SignerOuterClass.TaprootTweakDesc parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static signrpc.SignerOuterClass.TaprootTweakDesc parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(signrpc.SignerOuterClass.TaprootTweakDesc prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * Protobuf type {@code signrpc.TaprootTweakDesc}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:signrpc.TaprootTweakDesc)
        signrpc.SignerOuterClass.TaprootTweakDescOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return signrpc.SignerOuterClass.internal_static_signrpc_TaprootTweakDesc_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return signrpc.SignerOuterClass.internal_static_signrpc_TaprootTweakDesc_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                signrpc.SignerOuterClass.TaprootTweakDesc.class, signrpc.SignerOuterClass.TaprootTweakDesc.Builder.class);
      }

      // Construct using signrpc.SignerOuterClass.TaprootTweakDesc.newBuilder()
      private Builder() {

      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);

      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        scriptRoot_ = com.google.protobuf.ByteString.EMPTY;
        keySpendOnly_ = false;
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return signrpc.SignerOuterClass.internal_static_signrpc_TaprootTweakDesc_descriptor;
      }

      @java.lang.Override
      public signrpc.SignerOuterClass.TaprootTweakDesc getDefaultInstanceForType() {
        return signrpc.SignerOuterClass.TaprootTweakDesc.getDefaultInstance();
      }

      @java.lang.Override
      public signrpc.SignerOuterClass.TaprootTweakDesc build() {
        signrpc.SignerOuterClass.TaprootTweakDesc result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public signrpc.SignerOuterClass.TaprootTweakDesc buildPartial() {
        signrpc.SignerOuterClass.TaprootTweakDesc result = new signrpc.SignerOuterClass.TaprootTweakDesc(this);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartial0(signrpc.SignerOuterClass.TaprootTweakDesc result) {
        int from_bitField0_ = bitField0_;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.scriptRoot_ = scriptRoot_;
        }
        if (((from_bitField0_ & 0x00000002) != 0)) {
          result.keySpendOnly_ = keySpendOnly_;
        }
      }

      @java.lang.Override
      public Builder clone() {
        return super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof signrpc.SignerOuterClass.TaprootTweakDesc) {
          return mergeFrom((signrpc.SignerOuterClass.TaprootTweakDesc)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(signrpc.SignerOuterClass.TaprootTweakDesc other) {
        if (other == signrpc.SignerOuterClass.TaprootTweakDesc.getDefaultInstance()) return this;
        if (other.getScriptRoot() != com.google.protobuf.ByteString.EMPTY) {
          setScriptRoot(other.getScriptRoot());
        }
        if (other.getKeySpendOnly() != false) {
          setKeySpendOnly(other.getKeySpendOnly());
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10: {
                scriptRoot_ = input.readBytes();
                bitField0_ |= 0x00000001;
                break;
              } // case 10
              case 16: {
                keySpendOnly_ = input.readBool();
                bitField0_ |= 0x00000002;
                break;
              } // case 16
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private com.google.protobuf.ByteString scriptRoot_ = com.google.protobuf.ByteString.EMPTY;
      /**
       * <pre>
       *
       *The root hash of the tapscript tree if a script path is committed to. If
       *the MuSig2 key put on chain doesn't also commit to a script path (BIP-0086
       *key spend only), then this needs to be empty and the key_spend_only field
       *below must be set to true. This is required because gRPC cannot
       *differentiate between a zero-size byte slice and a nil byte slice (both
       *would be serialized the same way). So the extra boolean is required.
       * </pre>
       *
       * <code>bytes script_root = 1;</code>
       * @return The scriptRoot.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString getScriptRoot() {
        return scriptRoot_;
      }
      /**
       * <pre>
       *
       *The root hash of the tapscript tree if a script path is committed to. If
       *the MuSig2 key put on chain doesn't also commit to a script path (BIP-0086
       *key spend only), then this needs to be empty and the key_spend_only field
       *below must be set to true. This is required because gRPC cannot
       *differentiate between a zero-size byte slice and a nil byte slice (both
       *would be serialized the same way). So the extra boolean is required.
       * </pre>
       *
       * <code>bytes script_root = 1;</code>
       * @param value The scriptRoot to set.
       * @return This builder for chaining.
       */
      public Builder setScriptRoot(com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        scriptRoot_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       *
       *The root hash of the tapscript tree if a script path is committed to. If
       *the MuSig2 key put on chain doesn't also commit to a script path (BIP-0086
       *key spend only), then this needs to be empty and the key_spend_only field
       *below must be set to true. This is required because gRPC cannot
       *differentiate between a zero-size byte slice and a nil byte slice (both
       *would be serialized the same way). So the extra boolean is required.
       * </pre>
       *
       * <code>bytes script_root = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearScriptRoot() {
        bitField0_ = (bitField0_ & ~0x00000001);
        scriptRoot_ = getDefaultInstance().getScriptRoot();
        onChanged();
        return this;
      }

      private boolean keySpendOnly_ ;
      /**
       * <pre>
       *
       *Indicates that the above script_root is expected to be empty because this
       *is a BIP-0086 key spend only commitment where only the internal key is
       *committed to instead of also including a script root hash.
       * </pre>
       *
       * <code>bool key_spend_only = 2;</code>
       * @return The keySpendOnly.
       */
      @java.lang.Override
      public boolean getKeySpendOnly() {
        return keySpendOnly_;
      }
      /**
       * <pre>
       *
       *Indicates that the above script_root is expected to be empty because this
       *is a BIP-0086 key spend only commitment where only the internal key is
       *committed to instead of also including a script root hash.
       * </pre>
       *
       * <code>bool key_spend_only = 2;</code>
       * @param value The keySpendOnly to set.
       * @return This builder for chaining.
       */
      public Builder setKeySpendOnly(boolean value) {

        keySpendOnly_ = value;
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       *
       *Indicates that the above script_root is expected to be empty because this
       *is a BIP-0086 key spend only commitment where only the internal key is
       *committed to instead of also including a script root hash.
       * </pre>
       *
       * <code>bool key_spend_only = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearKeySpendOnly() {
        bitField0_ = (bitField0_ & ~0x00000002);
        keySpendOnly_ = false;
        onChanged();
        return this;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:signrpc.TaprootTweakDesc)
    }

    // @@protoc_insertion_point(class_scope:signrpc.TaprootTweakDesc)
    private static final signrpc.SignerOuterClass.TaprootTweakDesc DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new signrpc.SignerOuterClass.TaprootTweakDesc();
    }

    public static signrpc.SignerOuterClass.TaprootTweakDesc getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<TaprootTweakDesc>
        PARSER = new com.google.protobuf.AbstractParser<TaprootTweakDesc>() {
      @java.lang.Override
      public TaprootTweakDesc parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<TaprootTweakDesc> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<TaprootTweakDesc> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public signrpc.SignerOuterClass.TaprootTweakDesc getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface MuSig2CombineKeysRequestOrBuilder extends
      // @@protoc_insertion_point(interface_extends:signrpc.MuSig2CombineKeysRequest)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     *
     *A list of all public keys (serialized in 32-byte x-only format for v0.4.0
     *and 33-byte compressed format for v1.0.0rc2!) participating in the signing
     *session. The list will always be sorted lexicographically internally. This
     *must include the local key which is described by the above key_loc.
     * </pre>
     *
     * <code>repeated bytes all_signer_pubkeys = 1;</code>
     * @return A list containing the allSignerPubkeys.
     */
    java.util.List<com.google.protobuf.ByteString> getAllSignerPubkeysList();
    /**
     * <pre>
     *
     *A list of all public keys (serialized in 32-byte x-only format for v0.4.0
     *and 33-byte compressed format for v1.0.0rc2!) participating in the signing
     *session. The list will always be sorted lexicographically internally. This
     *must include the local key which is described by the above key_loc.
     * </pre>
     *
     * <code>repeated bytes all_signer_pubkeys = 1;</code>
     * @return The count of allSignerPubkeys.
     */
    int getAllSignerPubkeysCount();
    /**
     * <pre>
     *
     *A list of all public keys (serialized in 32-byte x-only format for v0.4.0
     *and 33-byte compressed format for v1.0.0rc2!) participating in the signing
     *session. The list will always be sorted lexicographically internally. This
     *must include the local key which is described by the above key_loc.
     * </pre>
     *
     * <code>repeated bytes all_signer_pubkeys = 1;</code>
     * @param index The index of the element to return.
     * @return The allSignerPubkeys at the given index.
     */
    com.google.protobuf.ByteString getAllSignerPubkeys(int index);

    /**
     * <pre>
     *
     *A series of optional generic tweaks to be applied to the the aggregated
     *public key.
     * </pre>
     *
     * <code>repeated .signrpc.TweakDesc tweaks = 2;</code>
     */
    java.util.List<signrpc.SignerOuterClass.TweakDesc> 
        getTweaksList();
    /**
     * <pre>
     *
     *A series of optional generic tweaks to be applied to the the aggregated
     *public key.
     * </pre>
     *
     * <code>repeated .signrpc.TweakDesc tweaks = 2;</code>
     */
    signrpc.SignerOuterClass.TweakDesc getTweaks(int index);
    /**
     * <pre>
     *
     *A series of optional generic tweaks to be applied to the the aggregated
     *public key.
     * </pre>
     *
     * <code>repeated .signrpc.TweakDesc tweaks = 2;</code>
     */
    int getTweaksCount();
    /**
     * <pre>
     *
     *A series of optional generic tweaks to be applied to the the aggregated
     *public key.
     * </pre>
     *
     * <code>repeated .signrpc.TweakDesc tweaks = 2;</code>
     */
    java.util.List<? extends signrpc.SignerOuterClass.TweakDescOrBuilder> 
        getTweaksOrBuilderList();
    /**
     * <pre>
     *
     *A series of optional generic tweaks to be applied to the the aggregated
     *public key.
     * </pre>
     *
     * <code>repeated .signrpc.TweakDesc tweaks = 2;</code>
     */
    signrpc.SignerOuterClass.TweakDescOrBuilder getTweaksOrBuilder(
        int index);

    /**
     * <pre>
     *
     *An optional taproot specific tweak that must be specified if the MuSig2
     *combined key will be used as the main taproot key of a taproot output
     *on-chain.
     * </pre>
     *
     * <code>.signrpc.TaprootTweakDesc taproot_tweak = 3;</code>
     * @return Whether the taprootTweak field is set.
     */
    boolean hasTaprootTweak();
    /**
     * <pre>
     *
     *An optional taproot specific tweak that must be specified if the MuSig2
     *combined key will be used as the main taproot key of a taproot output
     *on-chain.
     * </pre>
     *
     * <code>.signrpc.TaprootTweakDesc taproot_tweak = 3;</code>
     * @return The taprootTweak.
     */
    signrpc.SignerOuterClass.TaprootTweakDesc getTaprootTweak();
    /**
     * <pre>
     *
     *An optional taproot specific tweak that must be specified if the MuSig2
     *combined key will be used as the main taproot key of a taproot output
     *on-chain.
     * </pre>
     *
     * <code>.signrpc.TaprootTweakDesc taproot_tweak = 3;</code>
     */
    signrpc.SignerOuterClass.TaprootTweakDescOrBuilder getTaprootTweakOrBuilder();

    /**
     * <pre>
     *
     *The mandatory version of the MuSig2 BIP draft to use. This is necessary to
     *differentiate between the changes that were made to the BIP while this
     *experimental RPC was already released. Some of those changes affect how the
     *combined key and nonces are created.
     * </pre>
     *
     * <code>.signrpc.MuSig2Version version = 4;</code>
     * @return The enum numeric value on the wire for version.
     */
    int getVersionValue();
    /**
     * <pre>
     *
     *The mandatory version of the MuSig2 BIP draft to use. This is necessary to
     *differentiate between the changes that were made to the BIP while this
     *experimental RPC was already released. Some of those changes affect how the
     *combined key and nonces are created.
     * </pre>
     *
     * <code>.signrpc.MuSig2Version version = 4;</code>
     * @return The version.
     */
    signrpc.SignerOuterClass.MuSig2Version getVersion();
  }
  /**
   * Protobuf type {@code signrpc.MuSig2CombineKeysRequest}
   */
  public static final class MuSig2CombineKeysRequest extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:signrpc.MuSig2CombineKeysRequest)
      MuSig2CombineKeysRequestOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use MuSig2CombineKeysRequest.newBuilder() to construct.
    private MuSig2CombineKeysRequest(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private MuSig2CombineKeysRequest() {
      allSignerPubkeys_ = emptyList(com.google.protobuf.ByteString.class);
      tweaks_ = java.util.Collections.emptyList();
      version_ = 0;
    }

    @java.lang.Override
    @SuppressWarnings({"unused"})
    protected java.lang.Object newInstance(
        UnusedPrivateParameter unused) {
      return new MuSig2CombineKeysRequest();
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return signrpc.SignerOuterClass.internal_static_signrpc_MuSig2CombineKeysRequest_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return signrpc.SignerOuterClass.internal_static_signrpc_MuSig2CombineKeysRequest_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              signrpc.SignerOuterClass.MuSig2CombineKeysRequest.class, signrpc.SignerOuterClass.MuSig2CombineKeysRequest.Builder.class);
    }

    private int bitField0_;
    public static final int ALL_SIGNER_PUBKEYS_FIELD_NUMBER = 1;
    @SuppressWarnings("serial")
    private com.google.protobuf.Internal.ProtobufList<com.google.protobuf.ByteString> allSignerPubkeys_ =
        emptyList(com.google.protobuf.ByteString.class);
    /**
     * <pre>
     *
     *A list of all public keys (serialized in 32-byte x-only format for v0.4.0
     *and 33-byte compressed format for v1.0.0rc2!) participating in the signing
     *session. The list will always be sorted lexicographically internally. This
     *must include the local key which is described by the above key_loc.
     * </pre>
     *
     * <code>repeated bytes all_signer_pubkeys = 1;</code>
     * @return A list containing the allSignerPubkeys.
     */
    @java.lang.Override
    public java.util.List<com.google.protobuf.ByteString>
        getAllSignerPubkeysList() {
      return allSignerPubkeys_;
    }
    /**
     * <pre>
     *
     *A list of all public keys (serialized in 32-byte x-only format for v0.4.0
     *and 33-byte compressed format for v1.0.0rc2!) participating in the signing
     *session. The list will always be sorted lexicographically internally. This
     *must include the local key which is described by the above key_loc.
     * </pre>
     *
     * <code>repeated bytes all_signer_pubkeys = 1;</code>
     * @return The count of allSignerPubkeys.
     */
    public int getAllSignerPubkeysCount() {
      return allSignerPubkeys_.size();
    }
    /**
     * <pre>
     *
     *A list of all public keys (serialized in 32-byte x-only format for v0.4.0
     *and 33-byte compressed format for v1.0.0rc2!) participating in the signing
     *session. The list will always be sorted lexicographically internally. This
     *must include the local key which is described by the above key_loc.
     * </pre>
     *
     * <code>repeated bytes all_signer_pubkeys = 1;</code>
     * @param index The index of the element to return.
     * @return The allSignerPubkeys at the given index.
     */
    public com.google.protobuf.ByteString getAllSignerPubkeys(int index) {
      return allSignerPubkeys_.get(index);
    }

    public static final int TWEAKS_FIELD_NUMBER = 2;
    @SuppressWarnings("serial")
    private java.util.List<signrpc.SignerOuterClass.TweakDesc> tweaks_;
    /**
     * <pre>
     *
     *A series of optional generic tweaks to be applied to the the aggregated
     *public key.
     * </pre>
     *
     * <code>repeated .signrpc.TweakDesc tweaks = 2;</code>
     */
    @java.lang.Override
    public java.util.List<signrpc.SignerOuterClass.TweakDesc> getTweaksList() {
      return tweaks_;
    }
    /**
     * <pre>
     *
     *A series of optional generic tweaks to be applied to the the aggregated
     *public key.
     * </pre>
     *
     * <code>repeated .signrpc.TweakDesc tweaks = 2;</code>
     */
    @java.lang.Override
    public java.util.List<? extends signrpc.SignerOuterClass.TweakDescOrBuilder> 
        getTweaksOrBuilderList() {
      return tweaks_;
    }
    /**
     * <pre>
     *
     *A series of optional generic tweaks to be applied to the the aggregated
     *public key.
     * </pre>
     *
     * <code>repeated .signrpc.TweakDesc tweaks = 2;</code>
     */
    @java.lang.Override
    public int getTweaksCount() {
      return tweaks_.size();
    }
    /**
     * <pre>
     *
     *A series of optional generic tweaks to be applied to the the aggregated
     *public key.
     * </pre>
     *
     * <code>repeated .signrpc.TweakDesc tweaks = 2;</code>
     */
    @java.lang.Override
    public signrpc.SignerOuterClass.TweakDesc getTweaks(int index) {
      return tweaks_.get(index);
    }
    /**
     * <pre>
     *
     *A series of optional generic tweaks to be applied to the the aggregated
     *public key.
     * </pre>
     *
     * <code>repeated .signrpc.TweakDesc tweaks = 2;</code>
     */
    @java.lang.Override
    public signrpc.SignerOuterClass.TweakDescOrBuilder getTweaksOrBuilder(
        int index) {
      return tweaks_.get(index);
    }

    public static final int TAPROOT_TWEAK_FIELD_NUMBER = 3;
    private signrpc.SignerOuterClass.TaprootTweakDesc taprootTweak_;
    /**
     * <pre>
     *
     *An optional taproot specific tweak that must be specified if the MuSig2
     *combined key will be used as the main taproot key of a taproot output
     *on-chain.
     * </pre>
     *
     * <code>.signrpc.TaprootTweakDesc taproot_tweak = 3;</code>
     * @return Whether the taprootTweak field is set.
     */
    @java.lang.Override
    public boolean hasTaprootTweak() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     *
     *An optional taproot specific tweak that must be specified if the MuSig2
     *combined key will be used as the main taproot key of a taproot output
     *on-chain.
     * </pre>
     *
     * <code>.signrpc.TaprootTweakDesc taproot_tweak = 3;</code>
     * @return The taprootTweak.
     */
    @java.lang.Override
    public signrpc.SignerOuterClass.TaprootTweakDesc getTaprootTweak() {
      return taprootTweak_ == null ? signrpc.SignerOuterClass.TaprootTweakDesc.getDefaultInstance() : taprootTweak_;
    }
    /**
     * <pre>
     *
     *An optional taproot specific tweak that must be specified if the MuSig2
     *combined key will be used as the main taproot key of a taproot output
     *on-chain.
     * </pre>
     *
     * <code>.signrpc.TaprootTweakDesc taproot_tweak = 3;</code>
     */
    @java.lang.Override
    public signrpc.SignerOuterClass.TaprootTweakDescOrBuilder getTaprootTweakOrBuilder() {
      return taprootTweak_ == null ? signrpc.SignerOuterClass.TaprootTweakDesc.getDefaultInstance() : taprootTweak_;
    }

    public static final int VERSION_FIELD_NUMBER = 4;
    private int version_ = 0;
    /**
     * <pre>
     *
     *The mandatory version of the MuSig2 BIP draft to use. This is necessary to
     *differentiate between the changes that were made to the BIP while this
     *experimental RPC was already released. Some of those changes affect how the
     *combined key and nonces are created.
     * </pre>
     *
     * <code>.signrpc.MuSig2Version version = 4;</code>
     * @return The enum numeric value on the wire for version.
     */
    @java.lang.Override public int getVersionValue() {
      return version_;
    }
    /**
     * <pre>
     *
     *The mandatory version of the MuSig2 BIP draft to use. This is necessary to
     *differentiate between the changes that were made to the BIP while this
     *experimental RPC was already released. Some of those changes affect how the
     *combined key and nonces are created.
     * </pre>
     *
     * <code>.signrpc.MuSig2Version version = 4;</code>
     * @return The version.
     */
    @java.lang.Override public signrpc.SignerOuterClass.MuSig2Version getVersion() {
      signrpc.SignerOuterClass.MuSig2Version result = signrpc.SignerOuterClass.MuSig2Version.forNumber(version_);
      return result == null ? signrpc.SignerOuterClass.MuSig2Version.UNRECOGNIZED : result;
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      for (int i = 0; i < allSignerPubkeys_.size(); i++) {
        output.writeBytes(1, allSignerPubkeys_.get(i));
      }
      for (int i = 0; i < tweaks_.size(); i++) {
        output.writeMessage(2, tweaks_.get(i));
      }
      if (((bitField0_ & 0x00000001) != 0)) {
        output.writeMessage(3, getTaprootTweak());
      }
      if (version_ != signrpc.SignerOuterClass.MuSig2Version.MUSIG2_VERSION_UNDEFINED.getNumber()) {
        output.writeEnum(4, version_);
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      {
        int dataSize = 0;
        for (int i = 0; i < allSignerPubkeys_.size(); i++) {
          dataSize += com.google.protobuf.CodedOutputStream
            .computeBytesSizeNoTag(allSignerPubkeys_.get(i));
        }
        size += dataSize;
        size += 1 * getAllSignerPubkeysList().size();
      }
      for (int i = 0; i < tweaks_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(2, tweaks_.get(i));
      }
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(3, getTaprootTweak());
      }
      if (version_ != signrpc.SignerOuterClass.MuSig2Version.MUSIG2_VERSION_UNDEFINED.getNumber()) {
        size += com.google.protobuf.CodedOutputStream
          .computeEnumSize(4, version_);
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof signrpc.SignerOuterClass.MuSig2CombineKeysRequest)) {
        return super.equals(obj);
      }
      signrpc.SignerOuterClass.MuSig2CombineKeysRequest other = (signrpc.SignerOuterClass.MuSig2CombineKeysRequest) obj;

      if (!getAllSignerPubkeysList()
          .equals(other.getAllSignerPubkeysList())) return false;
      if (!getTweaksList()
          .equals(other.getTweaksList())) return false;
      if (hasTaprootTweak() != other.hasTaprootTweak()) return false;
      if (hasTaprootTweak()) {
        if (!getTaprootTweak()
            .equals(other.getTaprootTweak())) return false;
      }
      if (version_ != other.version_) return false;
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (getAllSignerPubkeysCount() > 0) {
        hash = (37 * hash) + ALL_SIGNER_PUBKEYS_FIELD_NUMBER;
        hash = (53 * hash) + getAllSignerPubkeysList().hashCode();
      }
      if (getTweaksCount() > 0) {
        hash = (37 * hash) + TWEAKS_FIELD_NUMBER;
        hash = (53 * hash) + getTweaksList().hashCode();
      }
      if (hasTaprootTweak()) {
        hash = (37 * hash) + TAPROOT_TWEAK_FIELD_NUMBER;
        hash = (53 * hash) + getTaprootTweak().hashCode();
      }
      hash = (37 * hash) + VERSION_FIELD_NUMBER;
      hash = (53 * hash) + version_;
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static signrpc.SignerOuterClass.MuSig2CombineKeysRequest parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static signrpc.SignerOuterClass.MuSig2CombineKeysRequest parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static signrpc.SignerOuterClass.MuSig2CombineKeysRequest parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static signrpc.SignerOuterClass.MuSig2CombineKeysRequest parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static signrpc.SignerOuterClass.MuSig2CombineKeysRequest parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static signrpc.SignerOuterClass.MuSig2CombineKeysRequest parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static signrpc.SignerOuterClass.MuSig2CombineKeysRequest parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static signrpc.SignerOuterClass.MuSig2CombineKeysRequest parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static signrpc.SignerOuterClass.MuSig2CombineKeysRequest parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static signrpc.SignerOuterClass.MuSig2CombineKeysRequest parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static signrpc.SignerOuterClass.MuSig2CombineKeysRequest parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static signrpc.SignerOuterClass.MuSig2CombineKeysRequest parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(signrpc.SignerOuterClass.MuSig2CombineKeysRequest prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * Protobuf type {@code signrpc.MuSig2CombineKeysRequest}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:signrpc.MuSig2CombineKeysRequest)
        signrpc.SignerOuterClass.MuSig2CombineKeysRequestOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return signrpc.SignerOuterClass.internal_static_signrpc_MuSig2CombineKeysRequest_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return signrpc.SignerOuterClass.internal_static_signrpc_MuSig2CombineKeysRequest_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                signrpc.SignerOuterClass.MuSig2CombineKeysRequest.class, signrpc.SignerOuterClass.MuSig2CombineKeysRequest.Builder.class);
      }

      // Construct using signrpc.SignerOuterClass.MuSig2CombineKeysRequest.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
          getTweaksFieldBuilder();
          getTaprootTweakFieldBuilder();
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        allSignerPubkeys_ = emptyList(com.google.protobuf.ByteString.class);
        if (tweaksBuilder_ == null) {
          tweaks_ = java.util.Collections.emptyList();
        } else {
          tweaks_ = null;
          tweaksBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000002);
        taprootTweak_ = null;
        if (taprootTweakBuilder_ != null) {
          taprootTweakBuilder_.dispose();
          taprootTweakBuilder_ = null;
        }
        version_ = 0;
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return signrpc.SignerOuterClass.internal_static_signrpc_MuSig2CombineKeysRequest_descriptor;
      }

      @java.lang.Override
      public signrpc.SignerOuterClass.MuSig2CombineKeysRequest getDefaultInstanceForType() {
        return signrpc.SignerOuterClass.MuSig2CombineKeysRequest.getDefaultInstance();
      }

      @java.lang.Override
      public signrpc.SignerOuterClass.MuSig2CombineKeysRequest build() {
        signrpc.SignerOuterClass.MuSig2CombineKeysRequest result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public signrpc.SignerOuterClass.MuSig2CombineKeysRequest buildPartial() {
        signrpc.SignerOuterClass.MuSig2CombineKeysRequest result = new signrpc.SignerOuterClass.MuSig2CombineKeysRequest(this);
        buildPartialRepeatedFields(result);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartialRepeatedFields(signrpc.SignerOuterClass.MuSig2CombineKeysRequest result) {
        if (tweaksBuilder_ == null) {
          if (((bitField0_ & 0x00000002) != 0)) {
            tweaks_ = java.util.Collections.unmodifiableList(tweaks_);
            bitField0_ = (bitField0_ & ~0x00000002);
          }
          result.tweaks_ = tweaks_;
        } else {
          result.tweaks_ = tweaksBuilder_.build();
        }
      }

      private void buildPartial0(signrpc.SignerOuterClass.MuSig2CombineKeysRequest result) {
        int from_bitField0_ = bitField0_;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          allSignerPubkeys_.makeImmutable();
          result.allSignerPubkeys_ = allSignerPubkeys_;
        }
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000004) != 0)) {
          result.taprootTweak_ = taprootTweakBuilder_ == null
              ? taprootTweak_
              : taprootTweakBuilder_.build();
          to_bitField0_ |= 0x00000001;
        }
        if (((from_bitField0_ & 0x00000008) != 0)) {
          result.version_ = version_;
        }
        result.bitField0_ |= to_bitField0_;
      }

      @java.lang.Override
      public Builder clone() {
        return super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof signrpc.SignerOuterClass.MuSig2CombineKeysRequest) {
          return mergeFrom((signrpc.SignerOuterClass.MuSig2CombineKeysRequest)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(signrpc.SignerOuterClass.MuSig2CombineKeysRequest other) {
        if (other == signrpc.SignerOuterClass.MuSig2CombineKeysRequest.getDefaultInstance()) return this;
        if (!other.allSignerPubkeys_.isEmpty()) {
          if (allSignerPubkeys_.isEmpty()) {
            allSignerPubkeys_ = other.allSignerPubkeys_;
            allSignerPubkeys_.makeImmutable();
            bitField0_ |= 0x00000001;
          } else {
            ensureAllSignerPubkeysIsMutable();
            allSignerPubkeys_.addAll(other.allSignerPubkeys_);
          }
          onChanged();
        }
        if (tweaksBuilder_ == null) {
          if (!other.tweaks_.isEmpty()) {
            if (tweaks_.isEmpty()) {
              tweaks_ = other.tweaks_;
              bitField0_ = (bitField0_ & ~0x00000002);
            } else {
              ensureTweaksIsMutable();
              tweaks_.addAll(other.tweaks_);
            }
            onChanged();
          }
        } else {
          if (!other.tweaks_.isEmpty()) {
            if (tweaksBuilder_.isEmpty()) {
              tweaksBuilder_.dispose();
              tweaksBuilder_ = null;
              tweaks_ = other.tweaks_;
              bitField0_ = (bitField0_ & ~0x00000002);
              tweaksBuilder_ = 
                com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
                   getTweaksFieldBuilder() : null;
            } else {
              tweaksBuilder_.addAllMessages(other.tweaks_);
            }
          }
        }
        if (other.hasTaprootTweak()) {
          mergeTaprootTweak(other.getTaprootTweak());
        }
        if (other.version_ != 0) {
          setVersionValue(other.getVersionValue());
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10: {
                com.google.protobuf.ByteString v = input.readBytes();
                ensureAllSignerPubkeysIsMutable();
                allSignerPubkeys_.add(v);
                break;
              } // case 10
              case 18: {
                signrpc.SignerOuterClass.TweakDesc m =
                    input.readMessage(
                        signrpc.SignerOuterClass.TweakDesc.parser(),
                        extensionRegistry);
                if (tweaksBuilder_ == null) {
                  ensureTweaksIsMutable();
                  tweaks_.add(m);
                } else {
                  tweaksBuilder_.addMessage(m);
                }
                break;
              } // case 18
              case 26: {
                input.readMessage(
                    getTaprootTweakFieldBuilder().getBuilder(),
                    extensionRegistry);
                bitField0_ |= 0x00000004;
                break;
              } // case 26
              case 32: {
                version_ = input.readEnum();
                bitField0_ |= 0x00000008;
                break;
              } // case 32
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private com.google.protobuf.Internal.ProtobufList<com.google.protobuf.ByteString> allSignerPubkeys_ = emptyList(com.google.protobuf.ByteString.class);
      private void ensureAllSignerPubkeysIsMutable() {
        if (!allSignerPubkeys_.isModifiable()) {
          allSignerPubkeys_ = makeMutableCopy(allSignerPubkeys_);
        }
        bitField0_ |= 0x00000001;
      }
      /**
       * <pre>
       *
       *A list of all public keys (serialized in 32-byte x-only format for v0.4.0
       *and 33-byte compressed format for v1.0.0rc2!) participating in the signing
       *session. The list will always be sorted lexicographically internally. This
       *must include the local key which is described by the above key_loc.
       * </pre>
       *
       * <code>repeated bytes all_signer_pubkeys = 1;</code>
       * @return A list containing the allSignerPubkeys.
       */
      public java.util.List<com.google.protobuf.ByteString>
          getAllSignerPubkeysList() {
        allSignerPubkeys_.makeImmutable();
        return allSignerPubkeys_;
      }
      /**
       * <pre>
       *
       *A list of all public keys (serialized in 32-byte x-only format for v0.4.0
       *and 33-byte compressed format for v1.0.0rc2!) participating in the signing
       *session. The list will always be sorted lexicographically internally. This
       *must include the local key which is described by the above key_loc.
       * </pre>
       *
       * <code>repeated bytes all_signer_pubkeys = 1;</code>
       * @return The count of allSignerPubkeys.
       */
      public int getAllSignerPubkeysCount() {
        return allSignerPubkeys_.size();
      }
      /**
       * <pre>
       *
       *A list of all public keys (serialized in 32-byte x-only format for v0.4.0
       *and 33-byte compressed format for v1.0.0rc2!) participating in the signing
       *session. The list will always be sorted lexicographically internally. This
       *must include the local key which is described by the above key_loc.
       * </pre>
       *
       * <code>repeated bytes all_signer_pubkeys = 1;</code>
       * @param index The index of the element to return.
       * @return The allSignerPubkeys at the given index.
       */
      public com.google.protobuf.ByteString getAllSignerPubkeys(int index) {
        return allSignerPubkeys_.get(index);
      }
      /**
       * <pre>
       *
       *A list of all public keys (serialized in 32-byte x-only format for v0.4.0
       *and 33-byte compressed format for v1.0.0rc2!) participating in the signing
       *session. The list will always be sorted lexicographically internally. This
       *must include the local key which is described by the above key_loc.
       * </pre>
       *
       * <code>repeated bytes all_signer_pubkeys = 1;</code>
       * @param index The index to set the value at.
       * @param value The allSignerPubkeys to set.
       * @return This builder for chaining.
       */
      public Builder setAllSignerPubkeys(
          int index, com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        ensureAllSignerPubkeysIsMutable();
        allSignerPubkeys_.set(index, value);
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       *
       *A list of all public keys (serialized in 32-byte x-only format for v0.4.0
       *and 33-byte compressed format for v1.0.0rc2!) participating in the signing
       *session. The list will always be sorted lexicographically internally. This
       *must include the local key which is described by the above key_loc.
       * </pre>
       *
       * <code>repeated bytes all_signer_pubkeys = 1;</code>
       * @param value The allSignerPubkeys to add.
       * @return This builder for chaining.
       */
      public Builder addAllSignerPubkeys(com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        ensureAllSignerPubkeysIsMutable();
        allSignerPubkeys_.add(value);
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       *
       *A list of all public keys (serialized in 32-byte x-only format for v0.4.0
       *and 33-byte compressed format for v1.0.0rc2!) participating in the signing
       *session. The list will always be sorted lexicographically internally. This
       *must include the local key which is described by the above key_loc.
       * </pre>
       *
       * <code>repeated bytes all_signer_pubkeys = 1;</code>
       * @param values The allSignerPubkeys to add.
       * @return This builder for chaining.
       */
      public Builder addAllAllSignerPubkeys(
          java.lang.Iterable<? extends com.google.protobuf.ByteString> values) {
        ensureAllSignerPubkeysIsMutable();
        com.google.protobuf.AbstractMessageLite.Builder.addAll(
            values, allSignerPubkeys_);
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       *
       *A list of all public keys (serialized in 32-byte x-only format for v0.4.0
       *and 33-byte compressed format for v1.0.0rc2!) participating in the signing
       *session. The list will always be sorted lexicographically internally. This
       *must include the local key which is described by the above key_loc.
       * </pre>
       *
       * <code>repeated bytes all_signer_pubkeys = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearAllSignerPubkeys() {
        allSignerPubkeys_ = emptyList(com.google.protobuf.ByteString.class);
        bitField0_ = (bitField0_ & ~0x00000001);
        onChanged();
        return this;
      }

      private java.util.List<signrpc.SignerOuterClass.TweakDesc> tweaks_ =
        java.util.Collections.emptyList();
      private void ensureTweaksIsMutable() {
        if (!((bitField0_ & 0x00000002) != 0)) {
          tweaks_ = new java.util.ArrayList<signrpc.SignerOuterClass.TweakDesc>(tweaks_);
          bitField0_ |= 0x00000002;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
          signrpc.SignerOuterClass.TweakDesc, signrpc.SignerOuterClass.TweakDesc.Builder, signrpc.SignerOuterClass.TweakDescOrBuilder> tweaksBuilder_;

      /**
       * <pre>
       *
       *A series of optional generic tweaks to be applied to the the aggregated
       *public key.
       * </pre>
       *
       * <code>repeated .signrpc.TweakDesc tweaks = 2;</code>
       */
      public java.util.List<signrpc.SignerOuterClass.TweakDesc> getTweaksList() {
        if (tweaksBuilder_ == null) {
          return java.util.Collections.unmodifiableList(tweaks_);
        } else {
          return tweaksBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       *
       *A series of optional generic tweaks to be applied to the the aggregated
       *public key.
       * </pre>
       *
       * <code>repeated .signrpc.TweakDesc tweaks = 2;</code>
       */
      public int getTweaksCount() {
        if (tweaksBuilder_ == null) {
          return tweaks_.size();
        } else {
          return tweaksBuilder_.getCount();
        }
      }
      /**
       * <pre>
       *
       *A series of optional generic tweaks to be applied to the the aggregated
       *public key.
       * </pre>
       *
       * <code>repeated .signrpc.TweakDesc tweaks = 2;</code>
       */
      public signrpc.SignerOuterClass.TweakDesc getTweaks(int index) {
        if (tweaksBuilder_ == null) {
          return tweaks_.get(index);
        } else {
          return tweaksBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       *
       *A series of optional generic tweaks to be applied to the the aggregated
       *public key.
       * </pre>
       *
       * <code>repeated .signrpc.TweakDesc tweaks = 2;</code>
       */
      public Builder setTweaks(
          int index, signrpc.SignerOuterClass.TweakDesc value) {
        if (tweaksBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureTweaksIsMutable();
          tweaks_.set(index, value);
          onChanged();
        } else {
          tweaksBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       *
       *A series of optional generic tweaks to be applied to the the aggregated
       *public key.
       * </pre>
       *
       * <code>repeated .signrpc.TweakDesc tweaks = 2;</code>
       */
      public Builder setTweaks(
          int index, signrpc.SignerOuterClass.TweakDesc.Builder builderForValue) {
        if (tweaksBuilder_ == null) {
          ensureTweaksIsMutable();
          tweaks_.set(index, builderForValue.build());
          onChanged();
        } else {
          tweaksBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       *
       *A series of optional generic tweaks to be applied to the the aggregated
       *public key.
       * </pre>
       *
       * <code>repeated .signrpc.TweakDesc tweaks = 2;</code>
       */
      public Builder addTweaks(signrpc.SignerOuterClass.TweakDesc value) {
        if (tweaksBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureTweaksIsMutable();
          tweaks_.add(value);
          onChanged();
        } else {
          tweaksBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       *
       *A series of optional generic tweaks to be applied to the the aggregated
       *public key.
       * </pre>
       *
       * <code>repeated .signrpc.TweakDesc tweaks = 2;</code>
       */
      public Builder addTweaks(
          int index, signrpc.SignerOuterClass.TweakDesc value) {
        if (tweaksBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureTweaksIsMutable();
          tweaks_.add(index, value);
          onChanged();
        } else {
          tweaksBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       *
       *A series of optional generic tweaks to be applied to the the aggregated
       *public key.
       * </pre>
       *
       * <code>repeated .signrpc.TweakDesc tweaks = 2;</code>
       */
      public Builder addTweaks(
          signrpc.SignerOuterClass.TweakDesc.Builder builderForValue) {
        if (tweaksBuilder_ == null) {
          ensureTweaksIsMutable();
          tweaks_.add(builderForValue.build());
          onChanged();
        } else {
          tweaksBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       *
       *A series of optional generic tweaks to be applied to the the aggregated
       *public key.
       * </pre>
       *
       * <code>repeated .signrpc.TweakDesc tweaks = 2;</code>
       */
      public Builder addTweaks(
          int index, signrpc.SignerOuterClass.TweakDesc.Builder builderForValue) {
        if (tweaksBuilder_ == null) {
          ensureTweaksIsMutable();
          tweaks_.add(index, builderForValue.build());
          onChanged();
        } else {
          tweaksBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       *
       *A series of optional generic tweaks to be applied to the the aggregated
       *public key.
       * </pre>
       *
       * <code>repeated .signrpc.TweakDesc tweaks = 2;</code>
       */
      public Builder addAllTweaks(
          java.lang.Iterable<? extends signrpc.SignerOuterClass.TweakDesc> values) {
        if (tweaksBuilder_ == null) {
          ensureTweaksIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, tweaks_);
          onChanged();
        } else {
          tweaksBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       *
       *A series of optional generic tweaks to be applied to the the aggregated
       *public key.
       * </pre>
       *
       * <code>repeated .signrpc.TweakDesc tweaks = 2;</code>
       */
      public Builder clearTweaks() {
        if (tweaksBuilder_ == null) {
          tweaks_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000002);
          onChanged();
        } else {
          tweaksBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       *
       *A series of optional generic tweaks to be applied to the the aggregated
       *public key.
       * </pre>
       *
       * <code>repeated .signrpc.TweakDesc tweaks = 2;</code>
       */
      public Builder removeTweaks(int index) {
        if (tweaksBuilder_ == null) {
          ensureTweaksIsMutable();
          tweaks_.remove(index);
          onChanged();
        } else {
          tweaksBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       *
       *A series of optional generic tweaks to be applied to the the aggregated
       *public key.
       * </pre>
       *
       * <code>repeated .signrpc.TweakDesc tweaks = 2;</code>
       */
      public signrpc.SignerOuterClass.TweakDesc.Builder getTweaksBuilder(
          int index) {
        return getTweaksFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       *
       *A series of optional generic tweaks to be applied to the the aggregated
       *public key.
       * </pre>
       *
       * <code>repeated .signrpc.TweakDesc tweaks = 2;</code>
       */
      public signrpc.SignerOuterClass.TweakDescOrBuilder getTweaksOrBuilder(
          int index) {
        if (tweaksBuilder_ == null) {
          return tweaks_.get(index);  } else {
          return tweaksBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       *
       *A series of optional generic tweaks to be applied to the the aggregated
       *public key.
       * </pre>
       *
       * <code>repeated .signrpc.TweakDesc tweaks = 2;</code>
       */
      public java.util.List<? extends signrpc.SignerOuterClass.TweakDescOrBuilder> 
           getTweaksOrBuilderList() {
        if (tweaksBuilder_ != null) {
          return tweaksBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(tweaks_);
        }
      }
      /**
       * <pre>
       *
       *A series of optional generic tweaks to be applied to the the aggregated
       *public key.
       * </pre>
       *
       * <code>repeated .signrpc.TweakDesc tweaks = 2;</code>
       */
      public signrpc.SignerOuterClass.TweakDesc.Builder addTweaksBuilder() {
        return getTweaksFieldBuilder().addBuilder(
            signrpc.SignerOuterClass.TweakDesc.getDefaultInstance());
      }
      /**
       * <pre>
       *
       *A series of optional generic tweaks to be applied to the the aggregated
       *public key.
       * </pre>
       *
       * <code>repeated .signrpc.TweakDesc tweaks = 2;</code>
       */
      public signrpc.SignerOuterClass.TweakDesc.Builder addTweaksBuilder(
          int index) {
        return getTweaksFieldBuilder().addBuilder(
            index, signrpc.SignerOuterClass.TweakDesc.getDefaultInstance());
      }
      /**
       * <pre>
       *
       *A series of optional generic tweaks to be applied to the the aggregated
       *public key.
       * </pre>
       *
       * <code>repeated .signrpc.TweakDesc tweaks = 2;</code>
       */
      public java.util.List<signrpc.SignerOuterClass.TweakDesc.Builder> 
           getTweaksBuilderList() {
        return getTweaksFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilderV3<
          signrpc.SignerOuterClass.TweakDesc, signrpc.SignerOuterClass.TweakDesc.Builder, signrpc.SignerOuterClass.TweakDescOrBuilder> 
          getTweaksFieldBuilder() {
        if (tweaksBuilder_ == null) {
          tweaksBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<
              signrpc.SignerOuterClass.TweakDesc, signrpc.SignerOuterClass.TweakDesc.Builder, signrpc.SignerOuterClass.TweakDescOrBuilder>(
                  tweaks_,
                  ((bitField0_ & 0x00000002) != 0),
                  getParentForChildren(),
                  isClean());
          tweaks_ = null;
        }
        return tweaksBuilder_;
      }

      private signrpc.SignerOuterClass.TaprootTweakDesc taprootTweak_;
      private com.google.protobuf.SingleFieldBuilderV3<
          signrpc.SignerOuterClass.TaprootTweakDesc, signrpc.SignerOuterClass.TaprootTweakDesc.Builder, signrpc.SignerOuterClass.TaprootTweakDescOrBuilder> taprootTweakBuilder_;
      /**
       * <pre>
       *
       *An optional taproot specific tweak that must be specified if the MuSig2
       *combined key will be used as the main taproot key of a taproot output
       *on-chain.
       * </pre>
       *
       * <code>.signrpc.TaprootTweakDesc taproot_tweak = 3;</code>
       * @return Whether the taprootTweak field is set.
       */
      public boolean hasTaprootTweak() {
        return ((bitField0_ & 0x00000004) != 0);
      }
      /**
       * <pre>
       *
       *An optional taproot specific tweak that must be specified if the MuSig2
       *combined key will be used as the main taproot key of a taproot output
       *on-chain.
       * </pre>
       *
       * <code>.signrpc.TaprootTweakDesc taproot_tweak = 3;</code>
       * @return The taprootTweak.
       */
      public signrpc.SignerOuterClass.TaprootTweakDesc getTaprootTweak() {
        if (taprootTweakBuilder_ == null) {
          return taprootTweak_ == null ? signrpc.SignerOuterClass.TaprootTweakDesc.getDefaultInstance() : taprootTweak_;
        } else {
          return taprootTweakBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       *
       *An optional taproot specific tweak that must be specified if the MuSig2
       *combined key will be used as the main taproot key of a taproot output
       *on-chain.
       * </pre>
       *
       * <code>.signrpc.TaprootTweakDesc taproot_tweak = 3;</code>
       */
      public Builder setTaprootTweak(signrpc.SignerOuterClass.TaprootTweakDesc value) {
        if (taprootTweakBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          taprootTweak_ = value;
        } else {
          taprootTweakBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }
      /**
       * <pre>
       *
       *An optional taproot specific tweak that must be specified if the MuSig2
       *combined key will be used as the main taproot key of a taproot output
       *on-chain.
       * </pre>
       *
       * <code>.signrpc.TaprootTweakDesc taproot_tweak = 3;</code>
       */
      public Builder setTaprootTweak(
          signrpc.SignerOuterClass.TaprootTweakDesc.Builder builderForValue) {
        if (taprootTweakBuilder_ == null) {
          taprootTweak_ = builderForValue.build();
        } else {
          taprootTweakBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }
      /**
       * <pre>
       *
       *An optional taproot specific tweak that must be specified if the MuSig2
       *combined key will be used as the main taproot key of a taproot output
       *on-chain.
       * </pre>
       *
       * <code>.signrpc.TaprootTweakDesc taproot_tweak = 3;</code>
       */
      public Builder mergeTaprootTweak(signrpc.SignerOuterClass.TaprootTweakDesc value) {
        if (taprootTweakBuilder_ == null) {
          if (((bitField0_ & 0x00000004) != 0) &&
            taprootTweak_ != null &&
            taprootTweak_ != signrpc.SignerOuterClass.TaprootTweakDesc.getDefaultInstance()) {
            getTaprootTweakBuilder().mergeFrom(value);
          } else {
            taprootTweak_ = value;
          }
        } else {
          taprootTweakBuilder_.mergeFrom(value);
        }
        if (taprootTweak_ != null) {
          bitField0_ |= 0x00000004;
          onChanged();
        }
        return this;
      }
      /**
       * <pre>
       *
       *An optional taproot specific tweak that must be specified if the MuSig2
       *combined key will be used as the main taproot key of a taproot output
       *on-chain.
       * </pre>
       *
       * <code>.signrpc.TaprootTweakDesc taproot_tweak = 3;</code>
       */
      public Builder clearTaprootTweak() {
        bitField0_ = (bitField0_ & ~0x00000004);
        taprootTweak_ = null;
        if (taprootTweakBuilder_ != null) {
          taprootTweakBuilder_.dispose();
          taprootTweakBuilder_ = null;
        }
        onChanged();
        return this;
      }
      /**
       * <pre>
       *
       *An optional taproot specific tweak that must be specified if the MuSig2
       *combined key will be used as the main taproot key of a taproot output
       *on-chain.
       * </pre>
       *
       * <code>.signrpc.TaprootTweakDesc taproot_tweak = 3;</code>
       */
      public signrpc.SignerOuterClass.TaprootTweakDesc.Builder getTaprootTweakBuilder() {
        bitField0_ |= 0x00000004;
        onChanged();
        return getTaprootTweakFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       *
       *An optional taproot specific tweak that must be specified if the MuSig2
       *combined key will be used as the main taproot key of a taproot output
       *on-chain.
       * </pre>
       *
       * <code>.signrpc.TaprootTweakDesc taproot_tweak = 3;</code>
       */
      public signrpc.SignerOuterClass.TaprootTweakDescOrBuilder getTaprootTweakOrBuilder() {
        if (taprootTweakBuilder_ != null) {
          return taprootTweakBuilder_.getMessageOrBuilder();
        } else {
          return taprootTweak_ == null ?
              signrpc.SignerOuterClass.TaprootTweakDesc.getDefaultInstance() : taprootTweak_;
        }
      }
      /**
       * <pre>
       *
       *An optional taproot specific tweak that must be specified if the MuSig2
       *combined key will be used as the main taproot key of a taproot output
       *on-chain.
       * </pre>
       *
       * <code>.signrpc.TaprootTweakDesc taproot_tweak = 3;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          signrpc.SignerOuterClass.TaprootTweakDesc, signrpc.SignerOuterClass.TaprootTweakDesc.Builder, signrpc.SignerOuterClass.TaprootTweakDescOrBuilder> 
          getTaprootTweakFieldBuilder() {
        if (taprootTweakBuilder_ == null) {
          taprootTweakBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              signrpc.SignerOuterClass.TaprootTweakDesc, signrpc.SignerOuterClass.TaprootTweakDesc.Builder, signrpc.SignerOuterClass.TaprootTweakDescOrBuilder>(
                  getTaprootTweak(),
                  getParentForChildren(),
                  isClean());
          taprootTweak_ = null;
        }
        return taprootTweakBuilder_;
      }

      private int version_ = 0;
      /**
       * <pre>
       *
       *The mandatory version of the MuSig2 BIP draft to use. This is necessary to
       *differentiate between the changes that were made to the BIP while this
       *experimental RPC was already released. Some of those changes affect how the
       *combined key and nonces are created.
       * </pre>
       *
       * <code>.signrpc.MuSig2Version version = 4;</code>
       * @return The enum numeric value on the wire for version.
       */
      @java.lang.Override public int getVersionValue() {
        return version_;
      }
      /**
       * <pre>
       *
       *The mandatory version of the MuSig2 BIP draft to use. This is necessary to
       *differentiate between the changes that were made to the BIP while this
       *experimental RPC was already released. Some of those changes affect how the
       *combined key and nonces are created.
       * </pre>
       *
       * <code>.signrpc.MuSig2Version version = 4;</code>
       * @param value The enum numeric value on the wire for version to set.
       * @return This builder for chaining.
       */
      public Builder setVersionValue(int value) {
        version_ = value;
        bitField0_ |= 0x00000008;
        onChanged();
        return this;
      }
      /**
       * <pre>
       *
       *The mandatory version of the MuSig2 BIP draft to use. This is necessary to
       *differentiate between the changes that were made to the BIP while this
       *experimental RPC was already released. Some of those changes affect how the
       *combined key and nonces are created.
       * </pre>
       *
       * <code>.signrpc.MuSig2Version version = 4;</code>
       * @return The version.
       */
      @java.lang.Override
      public signrpc.SignerOuterClass.MuSig2Version getVersion() {
        signrpc.SignerOuterClass.MuSig2Version result = signrpc.SignerOuterClass.MuSig2Version.forNumber(version_);
        return result == null ? signrpc.SignerOuterClass.MuSig2Version.UNRECOGNIZED : result;
      }
      /**
       * <pre>
       *
       *The mandatory version of the MuSig2 BIP draft to use. This is necessary to
       *differentiate between the changes that were made to the BIP while this
       *experimental RPC was already released. Some of those changes affect how the
       *combined key and nonces are created.
       * </pre>
       *
       * <code>.signrpc.MuSig2Version version = 4;</code>
       * @param value The version to set.
       * @return This builder for chaining.
       */
      public Builder setVersion(signrpc.SignerOuterClass.MuSig2Version value) {
        if (value == null) {
          throw new NullPointerException();
        }
        bitField0_ |= 0x00000008;
        version_ = value.getNumber();
        onChanged();
        return this;
      }
      /**
       * <pre>
       *
       *The mandatory version of the MuSig2 BIP draft to use. This is necessary to
       *differentiate between the changes that were made to the BIP while this
       *experimental RPC was already released. Some of those changes affect how the
       *combined key and nonces are created.
       * </pre>
       *
       * <code>.signrpc.MuSig2Version version = 4;</code>
       * @return This builder for chaining.
       */
      public Builder clearVersion() {
        bitField0_ = (bitField0_ & ~0x00000008);
        version_ = 0;
        onChanged();
        return this;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:signrpc.MuSig2CombineKeysRequest)
    }

    // @@protoc_insertion_point(class_scope:signrpc.MuSig2CombineKeysRequest)
    private static final signrpc.SignerOuterClass.MuSig2CombineKeysRequest DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new signrpc.SignerOuterClass.MuSig2CombineKeysRequest();
    }

    public static signrpc.SignerOuterClass.MuSig2CombineKeysRequest getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<MuSig2CombineKeysRequest>
        PARSER = new com.google.protobuf.AbstractParser<MuSig2CombineKeysRequest>() {
      @java.lang.Override
      public MuSig2CombineKeysRequest parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<MuSig2CombineKeysRequest> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<MuSig2CombineKeysRequest> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public signrpc.SignerOuterClass.MuSig2CombineKeysRequest getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface MuSig2CombineKeysResponseOrBuilder extends
      // @@protoc_insertion_point(interface_extends:signrpc.MuSig2CombineKeysResponse)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     *
     *The combined public key (in the 32-byte x-only format) with all tweaks
     *applied to it. If a taproot tweak is specified, this corresponds to the
     *taproot key that can be put into the on-chain output.
     * </pre>
     *
     * <code>bytes combined_key = 1;</code>
     * @return The combinedKey.
     */
    com.google.protobuf.ByteString getCombinedKey();

    /**
     * <pre>
     *
     *The raw combined public key (in the 32-byte x-only format) before any tweaks
     *are applied to it. If a taproot tweak is specified, this corresponds to the
     *internal key that needs to be put into the witness if the script spend path
     *is used.
     * </pre>
     *
     * <code>bytes taproot_internal_key = 2;</code>
     * @return The taprootInternalKey.
     */
    com.google.protobuf.ByteString getTaprootInternalKey();

    /**
     * <pre>
     *
     *The version of the MuSig2 BIP that was used to combine the keys.
     * </pre>
     *
     * <code>.signrpc.MuSig2Version version = 4;</code>
     * @return The enum numeric value on the wire for version.
     */
    int getVersionValue();
    /**
     * <pre>
     *
     *The version of the MuSig2 BIP that was used to combine the keys.
     * </pre>
     *
     * <code>.signrpc.MuSig2Version version = 4;</code>
     * @return The version.
     */
    signrpc.SignerOuterClass.MuSig2Version getVersion();
  }
  /**
   * Protobuf type {@code signrpc.MuSig2CombineKeysResponse}
   */
  public static final class MuSig2CombineKeysResponse extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:signrpc.MuSig2CombineKeysResponse)
      MuSig2CombineKeysResponseOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use MuSig2CombineKeysResponse.newBuilder() to construct.
    private MuSig2CombineKeysResponse(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private MuSig2CombineKeysResponse() {
      combinedKey_ = com.google.protobuf.ByteString.EMPTY;
      taprootInternalKey_ = com.google.protobuf.ByteString.EMPTY;
      version_ = 0;
    }

    @java.lang.Override
    @SuppressWarnings({"unused"})
    protected java.lang.Object newInstance(
        UnusedPrivateParameter unused) {
      return new MuSig2CombineKeysResponse();
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return signrpc.SignerOuterClass.internal_static_signrpc_MuSig2CombineKeysResponse_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return signrpc.SignerOuterClass.internal_static_signrpc_MuSig2CombineKeysResponse_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              signrpc.SignerOuterClass.MuSig2CombineKeysResponse.class, signrpc.SignerOuterClass.MuSig2CombineKeysResponse.Builder.class);
    }

    public static final int COMBINED_KEY_FIELD_NUMBER = 1;
    private com.google.protobuf.ByteString combinedKey_ = com.google.protobuf.ByteString.EMPTY;
    /**
     * <pre>
     *
     *The combined public key (in the 32-byte x-only format) with all tweaks
     *applied to it. If a taproot tweak is specified, this corresponds to the
     *taproot key that can be put into the on-chain output.
     * </pre>
     *
     * <code>bytes combined_key = 1;</code>
     * @return The combinedKey.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString getCombinedKey() {
      return combinedKey_;
    }

    public static final int TAPROOT_INTERNAL_KEY_FIELD_NUMBER = 2;
    private com.google.protobuf.ByteString taprootInternalKey_ = com.google.protobuf.ByteString.EMPTY;
    /**
     * <pre>
     *
     *The raw combined public key (in the 32-byte x-only format) before any tweaks
     *are applied to it. If a taproot tweak is specified, this corresponds to the
     *internal key that needs to be put into the witness if the script spend path
     *is used.
     * </pre>
     *
     * <code>bytes taproot_internal_key = 2;</code>
     * @return The taprootInternalKey.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString getTaprootInternalKey() {
      return taprootInternalKey_;
    }

    public static final int VERSION_FIELD_NUMBER = 4;
    private int version_ = 0;
    /**
     * <pre>
     *
     *The version of the MuSig2 BIP that was used to combine the keys.
     * </pre>
     *
     * <code>.signrpc.MuSig2Version version = 4;</code>
     * @return The enum numeric value on the wire for version.
     */
    @java.lang.Override public int getVersionValue() {
      return version_;
    }
    /**
     * <pre>
     *
     *The version of the MuSig2 BIP that was used to combine the keys.
     * </pre>
     *
     * <code>.signrpc.MuSig2Version version = 4;</code>
     * @return The version.
     */
    @java.lang.Override public signrpc.SignerOuterClass.MuSig2Version getVersion() {
      signrpc.SignerOuterClass.MuSig2Version result = signrpc.SignerOuterClass.MuSig2Version.forNumber(version_);
      return result == null ? signrpc.SignerOuterClass.MuSig2Version.UNRECOGNIZED : result;
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (!combinedKey_.isEmpty()) {
        output.writeBytes(1, combinedKey_);
      }
      if (!taprootInternalKey_.isEmpty()) {
        output.writeBytes(2, taprootInternalKey_);
      }
      if (version_ != signrpc.SignerOuterClass.MuSig2Version.MUSIG2_VERSION_UNDEFINED.getNumber()) {
        output.writeEnum(4, version_);
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (!combinedKey_.isEmpty()) {
        size += com.google.protobuf.CodedOutputStream
          .computeBytesSize(1, combinedKey_);
      }
      if (!taprootInternalKey_.isEmpty()) {
        size += com.google.protobuf.CodedOutputStream
          .computeBytesSize(2, taprootInternalKey_);
      }
      if (version_ != signrpc.SignerOuterClass.MuSig2Version.MUSIG2_VERSION_UNDEFINED.getNumber()) {
        size += com.google.protobuf.CodedOutputStream
          .computeEnumSize(4, version_);
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof signrpc.SignerOuterClass.MuSig2CombineKeysResponse)) {
        return super.equals(obj);
      }
      signrpc.SignerOuterClass.MuSig2CombineKeysResponse other = (signrpc.SignerOuterClass.MuSig2CombineKeysResponse) obj;

      if (!getCombinedKey()
          .equals(other.getCombinedKey())) return false;
      if (!getTaprootInternalKey()
          .equals(other.getTaprootInternalKey())) return false;
      if (version_ != other.version_) return false;
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      hash = (37 * hash) + COMBINED_KEY_FIELD_NUMBER;
      hash = (53 * hash) + getCombinedKey().hashCode();
      hash = (37 * hash) + TAPROOT_INTERNAL_KEY_FIELD_NUMBER;
      hash = (53 * hash) + getTaprootInternalKey().hashCode();
      hash = (37 * hash) + VERSION_FIELD_NUMBER;
      hash = (53 * hash) + version_;
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static signrpc.SignerOuterClass.MuSig2CombineKeysResponse parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static signrpc.SignerOuterClass.MuSig2CombineKeysResponse parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static signrpc.SignerOuterClass.MuSig2CombineKeysResponse parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static signrpc.SignerOuterClass.MuSig2CombineKeysResponse parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static signrpc.SignerOuterClass.MuSig2CombineKeysResponse parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static signrpc.SignerOuterClass.MuSig2CombineKeysResponse parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static signrpc.SignerOuterClass.MuSig2CombineKeysResponse parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static signrpc.SignerOuterClass.MuSig2CombineKeysResponse parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static signrpc.SignerOuterClass.MuSig2CombineKeysResponse parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static signrpc.SignerOuterClass.MuSig2CombineKeysResponse parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static signrpc.SignerOuterClass.MuSig2CombineKeysResponse parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static signrpc.SignerOuterClass.MuSig2CombineKeysResponse parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(signrpc.SignerOuterClass.MuSig2CombineKeysResponse prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * Protobuf type {@code signrpc.MuSig2CombineKeysResponse}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:signrpc.MuSig2CombineKeysResponse)
        signrpc.SignerOuterClass.MuSig2CombineKeysResponseOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return signrpc.SignerOuterClass.internal_static_signrpc_MuSig2CombineKeysResponse_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return signrpc.SignerOuterClass.internal_static_signrpc_MuSig2CombineKeysResponse_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                signrpc.SignerOuterClass.MuSig2CombineKeysResponse.class, signrpc.SignerOuterClass.MuSig2CombineKeysResponse.Builder.class);
      }

      // Construct using signrpc.SignerOuterClass.MuSig2CombineKeysResponse.newBuilder()
      private Builder() {

      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);

      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        combinedKey_ = com.google.protobuf.ByteString.EMPTY;
        taprootInternalKey_ = com.google.protobuf.ByteString.EMPTY;
        version_ = 0;
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return signrpc.SignerOuterClass.internal_static_signrpc_MuSig2CombineKeysResponse_descriptor;
      }

      @java.lang.Override
      public signrpc.SignerOuterClass.MuSig2CombineKeysResponse getDefaultInstanceForType() {
        return signrpc.SignerOuterClass.MuSig2CombineKeysResponse.getDefaultInstance();
      }

      @java.lang.Override
      public signrpc.SignerOuterClass.MuSig2CombineKeysResponse build() {
        signrpc.SignerOuterClass.MuSig2CombineKeysResponse result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public signrpc.SignerOuterClass.MuSig2CombineKeysResponse buildPartial() {
        signrpc.SignerOuterClass.MuSig2CombineKeysResponse result = new signrpc.SignerOuterClass.MuSig2CombineKeysResponse(this);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartial0(signrpc.SignerOuterClass.MuSig2CombineKeysResponse result) {
        int from_bitField0_ = bitField0_;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.combinedKey_ = combinedKey_;
        }
        if (((from_bitField0_ & 0x00000002) != 0)) {
          result.taprootInternalKey_ = taprootInternalKey_;
        }
        if (((from_bitField0_ & 0x00000004) != 0)) {
          result.version_ = version_;
        }
      }

      @java.lang.Override
      public Builder clone() {
        return super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof signrpc.SignerOuterClass.MuSig2CombineKeysResponse) {
          return mergeFrom((signrpc.SignerOuterClass.MuSig2CombineKeysResponse)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(signrpc.SignerOuterClass.MuSig2CombineKeysResponse other) {
        if (other == signrpc.SignerOuterClass.MuSig2CombineKeysResponse.getDefaultInstance()) return this;
        if (other.getCombinedKey() != com.google.protobuf.ByteString.EMPTY) {
          setCombinedKey(other.getCombinedKey());
        }
        if (other.getTaprootInternalKey() != com.google.protobuf.ByteString.EMPTY) {
          setTaprootInternalKey(other.getTaprootInternalKey());
        }
        if (other.version_ != 0) {
          setVersionValue(other.getVersionValue());
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10: {
                combinedKey_ = input.readBytes();
                bitField0_ |= 0x00000001;
                break;
              } // case 10
              case 18: {
                taprootInternalKey_ = input.readBytes();
                bitField0_ |= 0x00000002;
                break;
              } // case 18
              case 32: {
                version_ = input.readEnum();
                bitField0_ |= 0x00000004;
                break;
              } // case 32
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private com.google.protobuf.ByteString combinedKey_ = com.google.protobuf.ByteString.EMPTY;
      /**
       * <pre>
       *
       *The combined public key (in the 32-byte x-only format) with all tweaks
       *applied to it. If a taproot tweak is specified, this corresponds to the
       *taproot key that can be put into the on-chain output.
       * </pre>
       *
       * <code>bytes combined_key = 1;</code>
       * @return The combinedKey.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString getCombinedKey() {
        return combinedKey_;
      }
      /**
       * <pre>
       *
       *The combined public key (in the 32-byte x-only format) with all tweaks
       *applied to it. If a taproot tweak is specified, this corresponds to the
       *taproot key that can be put into the on-chain output.
       * </pre>
       *
       * <code>bytes combined_key = 1;</code>
       * @param value The combinedKey to set.
       * @return This builder for chaining.
       */
      public Builder setCombinedKey(com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        combinedKey_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       *
       *The combined public key (in the 32-byte x-only format) with all tweaks
       *applied to it. If a taproot tweak is specified, this corresponds to the
       *taproot key that can be put into the on-chain output.
       * </pre>
       *
       * <code>bytes combined_key = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearCombinedKey() {
        bitField0_ = (bitField0_ & ~0x00000001);
        combinedKey_ = getDefaultInstance().getCombinedKey();
        onChanged();
        return this;
      }

      private com.google.protobuf.ByteString taprootInternalKey_ = com.google.protobuf.ByteString.EMPTY;
      /**
       * <pre>
       *
       *The raw combined public key (in the 32-byte x-only format) before any tweaks
       *are applied to it. If a taproot tweak is specified, this corresponds to the
       *internal key that needs to be put into the witness if the script spend path
       *is used.
       * </pre>
       *
       * <code>bytes taproot_internal_key = 2;</code>
       * @return The taprootInternalKey.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString getTaprootInternalKey() {
        return taprootInternalKey_;
      }
      /**
       * <pre>
       *
       *The raw combined public key (in the 32-byte x-only format) before any tweaks
       *are applied to it. If a taproot tweak is specified, this corresponds to the
       *internal key that needs to be put into the witness if the script spend path
       *is used.
       * </pre>
       *
       * <code>bytes taproot_internal_key = 2;</code>
       * @param value The taprootInternalKey to set.
       * @return This builder for chaining.
       */
      public Builder setTaprootInternalKey(com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        taprootInternalKey_ = value;
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       *
       *The raw combined public key (in the 32-byte x-only format) before any tweaks
       *are applied to it. If a taproot tweak is specified, this corresponds to the
       *internal key that needs to be put into the witness if the script spend path
       *is used.
       * </pre>
       *
       * <code>bytes taproot_internal_key = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearTaprootInternalKey() {
        bitField0_ = (bitField0_ & ~0x00000002);
        taprootInternalKey_ = getDefaultInstance().getTaprootInternalKey();
        onChanged();
        return this;
      }

      private int version_ = 0;
      /**
       * <pre>
       *
       *The version of the MuSig2 BIP that was used to combine the keys.
       * </pre>
       *
       * <code>.signrpc.MuSig2Version version = 4;</code>
       * @return The enum numeric value on the wire for version.
       */
      @java.lang.Override public int getVersionValue() {
        return version_;
      }
      /**
       * <pre>
       *
       *The version of the MuSig2 BIP that was used to combine the keys.
       * </pre>
       *
       * <code>.signrpc.MuSig2Version version = 4;</code>
       * @param value The enum numeric value on the wire for version to set.
       * @return This builder for chaining.
       */
      public Builder setVersionValue(int value) {
        version_ = value;
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }
      /**
       * <pre>
       *
       *The version of the MuSig2 BIP that was used to combine the keys.
       * </pre>
       *
       * <code>.signrpc.MuSig2Version version = 4;</code>
       * @return The version.
       */
      @java.lang.Override
      public signrpc.SignerOuterClass.MuSig2Version getVersion() {
        signrpc.SignerOuterClass.MuSig2Version result = signrpc.SignerOuterClass.MuSig2Version.forNumber(version_);
        return result == null ? signrpc.SignerOuterClass.MuSig2Version.UNRECOGNIZED : result;
      }
      /**
       * <pre>
       *
       *The version of the MuSig2 BIP that was used to combine the keys.
       * </pre>
       *
       * <code>.signrpc.MuSig2Version version = 4;</code>
       * @param value The version to set.
       * @return This builder for chaining.
       */
      public Builder setVersion(signrpc.SignerOuterClass.MuSig2Version value) {
        if (value == null) {
          throw new NullPointerException();
        }
        bitField0_ |= 0x00000004;
        version_ = value.getNumber();
        onChanged();
        return this;
      }
      /**
       * <pre>
       *
       *The version of the MuSig2 BIP that was used to combine the keys.
       * </pre>
       *
       * <code>.signrpc.MuSig2Version version = 4;</code>
       * @return This builder for chaining.
       */
      public Builder clearVersion() {
        bitField0_ = (bitField0_ & ~0x00000004);
        version_ = 0;
        onChanged();
        return this;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:signrpc.MuSig2CombineKeysResponse)
    }

    // @@protoc_insertion_point(class_scope:signrpc.MuSig2CombineKeysResponse)
    private static final signrpc.SignerOuterClass.MuSig2CombineKeysResponse DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new signrpc.SignerOuterClass.MuSig2CombineKeysResponse();
    }

    public static signrpc.SignerOuterClass.MuSig2CombineKeysResponse getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<MuSig2CombineKeysResponse>
        PARSER = new com.google.protobuf.AbstractParser<MuSig2CombineKeysResponse>() {
      @java.lang.Override
      public MuSig2CombineKeysResponse parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<MuSig2CombineKeysResponse> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<MuSig2CombineKeysResponse> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public signrpc.SignerOuterClass.MuSig2CombineKeysResponse getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface MuSig2SessionRequestOrBuilder extends
      // @@protoc_insertion_point(interface_extends:signrpc.MuSig2SessionRequest)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     *
     *The key locator that identifies which key to use for signing.
     * </pre>
     *
     * <code>.signrpc.KeyLocator key_loc = 1;</code>
     * @return Whether the keyLoc field is set.
     */
    boolean hasKeyLoc();
    /**
     * <pre>
     *
     *The key locator that identifies which key to use for signing.
     * </pre>
     *
     * <code>.signrpc.KeyLocator key_loc = 1;</code>
     * @return The keyLoc.
     */
    signrpc.SignerOuterClass.KeyLocator getKeyLoc();
    /**
     * <pre>
     *
     *The key locator that identifies which key to use for signing.
     * </pre>
     *
     * <code>.signrpc.KeyLocator key_loc = 1;</code>
     */
    signrpc.SignerOuterClass.KeyLocatorOrBuilder getKeyLocOrBuilder();

    /**
     * <pre>
     *
     *A list of all public keys (serialized in 32-byte x-only format for v0.4.0
     *and 33-byte compressed format for v1.0.0rc2!) participating in the signing
     *session. The list will always be sorted lexicographically internally. This
     *must include the local key which is described by the above key_loc.
     * </pre>
     *
     * <code>repeated bytes all_signer_pubkeys = 2;</code>
     * @return A list containing the allSignerPubkeys.
     */
    java.util.List<com.google.protobuf.ByteString> getAllSignerPubkeysList();
    /**
     * <pre>
     *
     *A list of all public keys (serialized in 32-byte x-only format for v0.4.0
     *and 33-byte compressed format for v1.0.0rc2!) participating in the signing
     *session. The list will always be sorted lexicographically internally. This
     *must include the local key which is described by the above key_loc.
     * </pre>
     *
     * <code>repeated bytes all_signer_pubkeys = 2;</code>
     * @return The count of allSignerPubkeys.
     */
    int getAllSignerPubkeysCount();
    /**
     * <pre>
     *
     *A list of all public keys (serialized in 32-byte x-only format for v0.4.0
     *and 33-byte compressed format for v1.0.0rc2!) participating in the signing
     *session. The list will always be sorted lexicographically internally. This
     *must include the local key which is described by the above key_loc.
     * </pre>
     *
     * <code>repeated bytes all_signer_pubkeys = 2;</code>
     * @param index The index of the element to return.
     * @return The allSignerPubkeys at the given index.
     */
    com.google.protobuf.ByteString getAllSignerPubkeys(int index);

    /**
     * <pre>
     *
     *An optional list of all public nonces of other signing participants that
     *might already be known.
     * </pre>
     *
     * <code>repeated bytes other_signer_public_nonces = 3;</code>
     * @return A list containing the otherSignerPublicNonces.
     */
    java.util.List<com.google.protobuf.ByteString> getOtherSignerPublicNoncesList();
    /**
     * <pre>
     *
     *An optional list of all public nonces of other signing participants that
     *might already be known.
     * </pre>
     *
     * <code>repeated bytes other_signer_public_nonces = 3;</code>
     * @return The count of otherSignerPublicNonces.
     */
    int getOtherSignerPublicNoncesCount();
    /**
     * <pre>
     *
     *An optional list of all public nonces of other signing participants that
     *might already be known.
     * </pre>
     *
     * <code>repeated bytes other_signer_public_nonces = 3;</code>
     * @param index The index of the element to return.
     * @return The otherSignerPublicNonces at the given index.
     */
    com.google.protobuf.ByteString getOtherSignerPublicNonces(int index);

    /**
     * <pre>
     *
     *A series of optional generic tweaks to be applied to the the aggregated
     *public key.
     * </pre>
     *
     * <code>repeated .signrpc.TweakDesc tweaks = 4;</code>
     */
    java.util.List<signrpc.SignerOuterClass.TweakDesc> 
        getTweaksList();
    /**
     * <pre>
     *
     *A series of optional generic tweaks to be applied to the the aggregated
     *public key.
     * </pre>
     *
     * <code>repeated .signrpc.TweakDesc tweaks = 4;</code>
     */
    signrpc.SignerOuterClass.TweakDesc getTweaks(int index);
    /**
     * <pre>
     *
     *A series of optional generic tweaks to be applied to the the aggregated
     *public key.
     * </pre>
     *
     * <code>repeated .signrpc.TweakDesc tweaks = 4;</code>
     */
    int getTweaksCount();
    /**
     * <pre>
     *
     *A series of optional generic tweaks to be applied to the the aggregated
     *public key.
     * </pre>
     *
     * <code>repeated .signrpc.TweakDesc tweaks = 4;</code>
     */
    java.util.List<? extends signrpc.SignerOuterClass.TweakDescOrBuilder> 
        getTweaksOrBuilderList();
    /**
     * <pre>
     *
     *A series of optional generic tweaks to be applied to the the aggregated
     *public key.
     * </pre>
     *
     * <code>repeated .signrpc.TweakDesc tweaks = 4;</code>
     */
    signrpc.SignerOuterClass.TweakDescOrBuilder getTweaksOrBuilder(
        int index);

    /**
     * <pre>
     *
     *An optional taproot specific tweak that must be specified if the MuSig2
     *combined key will be used as the main taproot key of a taproot output
     *on-chain.
     * </pre>
     *
     * <code>.signrpc.TaprootTweakDesc taproot_tweak = 5;</code>
     * @return Whether the taprootTweak field is set.
     */
    boolean hasTaprootTweak();
    /**
     * <pre>
     *
     *An optional taproot specific tweak that must be specified if the MuSig2
     *combined key will be used as the main taproot key of a taproot output
     *on-chain.
     * </pre>
     *
     * <code>.signrpc.TaprootTweakDesc taproot_tweak = 5;</code>
     * @return The taprootTweak.
     */
    signrpc.SignerOuterClass.TaprootTweakDesc getTaprootTweak();
    /**
     * <pre>
     *
     *An optional taproot specific tweak that must be specified if the MuSig2
     *combined key will be used as the main taproot key of a taproot output
     *on-chain.
     * </pre>
     *
     * <code>.signrpc.TaprootTweakDesc taproot_tweak = 5;</code>
     */
    signrpc.SignerOuterClass.TaprootTweakDescOrBuilder getTaprootTweakOrBuilder();

    /**
     * <pre>
     *
     *The mandatory version of the MuSig2 BIP draft to use. This is necessary to
     *differentiate between the changes that were made to the BIP while this
     *experimental RPC was already released. Some of those changes affect how the
     *combined key and nonces are created.
     * </pre>
     *
     * <code>.signrpc.MuSig2Version version = 6;</code>
     * @return The enum numeric value on the wire for version.
     */
    int getVersionValue();
    /**
     * <pre>
     *
     *The mandatory version of the MuSig2 BIP draft to use. This is necessary to
     *differentiate between the changes that were made to the BIP while this
     *experimental RPC was already released. Some of those changes affect how the
     *combined key and nonces are created.
     * </pre>
     *
     * <code>.signrpc.MuSig2Version version = 6;</code>
     * @return The version.
     */
    signrpc.SignerOuterClass.MuSig2Version getVersion();
  }
  /**
   * Protobuf type {@code signrpc.MuSig2SessionRequest}
   */
  public static final class MuSig2SessionRequest extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:signrpc.MuSig2SessionRequest)
      MuSig2SessionRequestOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use MuSig2SessionRequest.newBuilder() to construct.
    private MuSig2SessionRequest(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private MuSig2SessionRequest() {
      allSignerPubkeys_ = emptyList(com.google.protobuf.ByteString.class);
      otherSignerPublicNonces_ = emptyList(com.google.protobuf.ByteString.class);
      tweaks_ = java.util.Collections.emptyList();
      version_ = 0;
    }

    @java.lang.Override
    @SuppressWarnings({"unused"})
    protected java.lang.Object newInstance(
        UnusedPrivateParameter unused) {
      return new MuSig2SessionRequest();
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return signrpc.SignerOuterClass.internal_static_signrpc_MuSig2SessionRequest_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return signrpc.SignerOuterClass.internal_static_signrpc_MuSig2SessionRequest_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              signrpc.SignerOuterClass.MuSig2SessionRequest.class, signrpc.SignerOuterClass.MuSig2SessionRequest.Builder.class);
    }

    private int bitField0_;
    public static final int KEY_LOC_FIELD_NUMBER = 1;
    private signrpc.SignerOuterClass.KeyLocator keyLoc_;
    /**
     * <pre>
     *
     *The key locator that identifies which key to use for signing.
     * </pre>
     *
     * <code>.signrpc.KeyLocator key_loc = 1;</code>
     * @return Whether the keyLoc field is set.
     */
    @java.lang.Override
    public boolean hasKeyLoc() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     *
     *The key locator that identifies which key to use for signing.
     * </pre>
     *
     * <code>.signrpc.KeyLocator key_loc = 1;</code>
     * @return The keyLoc.
     */
    @java.lang.Override
    public signrpc.SignerOuterClass.KeyLocator getKeyLoc() {
      return keyLoc_ == null ? signrpc.SignerOuterClass.KeyLocator.getDefaultInstance() : keyLoc_;
    }
    /**
     * <pre>
     *
     *The key locator that identifies which key to use for signing.
     * </pre>
     *
     * <code>.signrpc.KeyLocator key_loc = 1;</code>
     */
    @java.lang.Override
    public signrpc.SignerOuterClass.KeyLocatorOrBuilder getKeyLocOrBuilder() {
      return keyLoc_ == null ? signrpc.SignerOuterClass.KeyLocator.getDefaultInstance() : keyLoc_;
    }

    public static final int ALL_SIGNER_PUBKEYS_FIELD_NUMBER = 2;
    @SuppressWarnings("serial")
    private com.google.protobuf.Internal.ProtobufList<com.google.protobuf.ByteString> allSignerPubkeys_ =
        emptyList(com.google.protobuf.ByteString.class);
    /**
     * <pre>
     *
     *A list of all public keys (serialized in 32-byte x-only format for v0.4.0
     *and 33-byte compressed format for v1.0.0rc2!) participating in the signing
     *session. The list will always be sorted lexicographically internally. This
     *must include the local key which is described by the above key_loc.
     * </pre>
     *
     * <code>repeated bytes all_signer_pubkeys = 2;</code>
     * @return A list containing the allSignerPubkeys.
     */
    @java.lang.Override
    public java.util.List<com.google.protobuf.ByteString>
        getAllSignerPubkeysList() {
      return allSignerPubkeys_;
    }
    /**
     * <pre>
     *
     *A list of all public keys (serialized in 32-byte x-only format for v0.4.0
     *and 33-byte compressed format for v1.0.0rc2!) participating in the signing
     *session. The list will always be sorted lexicographically internally. This
     *must include the local key which is described by the above key_loc.
     * </pre>
     *
     * <code>repeated bytes all_signer_pubkeys = 2;</code>
     * @return The count of allSignerPubkeys.
     */
    public int getAllSignerPubkeysCount() {
      return allSignerPubkeys_.size();
    }
    /**
     * <pre>
     *
     *A list of all public keys (serialized in 32-byte x-only format for v0.4.0
     *and 33-byte compressed format for v1.0.0rc2!) participating in the signing
     *session. The list will always be sorted lexicographically internally. This
     *must include the local key which is described by the above key_loc.
     * </pre>
     *
     * <code>repeated bytes all_signer_pubkeys = 2;</code>
     * @param index The index of the element to return.
     * @return The allSignerPubkeys at the given index.
     */
    public com.google.protobuf.ByteString getAllSignerPubkeys(int index) {
      return allSignerPubkeys_.get(index);
    }

    public static final int OTHER_SIGNER_PUBLIC_NONCES_FIELD_NUMBER = 3;
    @SuppressWarnings("serial")
    private com.google.protobuf.Internal.ProtobufList<com.google.protobuf.ByteString> otherSignerPublicNonces_ =
        emptyList(com.google.protobuf.ByteString.class);
    /**
     * <pre>
     *
     *An optional list of all public nonces of other signing participants that
     *might already be known.
     * </pre>
     *
     * <code>repeated bytes other_signer_public_nonces = 3;</code>
     * @return A list containing the otherSignerPublicNonces.
     */
    @java.lang.Override
    public java.util.List<com.google.protobuf.ByteString>
        getOtherSignerPublicNoncesList() {
      return otherSignerPublicNonces_;
    }
    /**
     * <pre>
     *
     *An optional list of all public nonces of other signing participants that
     *might already be known.
     * </pre>
     *
     * <code>repeated bytes other_signer_public_nonces = 3;</code>
     * @return The count of otherSignerPublicNonces.
     */
    public int getOtherSignerPublicNoncesCount() {
      return otherSignerPublicNonces_.size();
    }
    /**
     * <pre>
     *
     *An optional list of all public nonces of other signing participants that
     *might already be known.
     * </pre>
     *
     * <code>repeated bytes other_signer_public_nonces = 3;</code>
     * @param index The index of the element to return.
     * @return The otherSignerPublicNonces at the given index.
     */
    public com.google.protobuf.ByteString getOtherSignerPublicNonces(int index) {
      return otherSignerPublicNonces_.get(index);
    }

    public static final int TWEAKS_FIELD_NUMBER = 4;
    @SuppressWarnings("serial")
    private java.util.List<signrpc.SignerOuterClass.TweakDesc> tweaks_;
    /**
     * <pre>
     *
     *A series of optional generic tweaks to be applied to the the aggregated
     *public key.
     * </pre>
     *
     * <code>repeated .signrpc.TweakDesc tweaks = 4;</code>
     */
    @java.lang.Override
    public java.util.List<signrpc.SignerOuterClass.TweakDesc> getTweaksList() {
      return tweaks_;
    }
    /**
     * <pre>
     *
     *A series of optional generic tweaks to be applied to the the aggregated
     *public key.
     * </pre>
     *
     * <code>repeated .signrpc.TweakDesc tweaks = 4;</code>
     */
    @java.lang.Override
    public java.util.List<? extends signrpc.SignerOuterClass.TweakDescOrBuilder> 
        getTweaksOrBuilderList() {
      return tweaks_;
    }
    /**
     * <pre>
     *
     *A series of optional generic tweaks to be applied to the the aggregated
     *public key.
     * </pre>
     *
     * <code>repeated .signrpc.TweakDesc tweaks = 4;</code>
     */
    @java.lang.Override
    public int getTweaksCount() {
      return tweaks_.size();
    }
    /**
     * <pre>
     *
     *A series of optional generic tweaks to be applied to the the aggregated
     *public key.
     * </pre>
     *
     * <code>repeated .signrpc.TweakDesc tweaks = 4;</code>
     */
    @java.lang.Override
    public signrpc.SignerOuterClass.TweakDesc getTweaks(int index) {
      return tweaks_.get(index);
    }
    /**
     * <pre>
     *
     *A series of optional generic tweaks to be applied to the the aggregated
     *public key.
     * </pre>
     *
     * <code>repeated .signrpc.TweakDesc tweaks = 4;</code>
     */
    @java.lang.Override
    public signrpc.SignerOuterClass.TweakDescOrBuilder getTweaksOrBuilder(
        int index) {
      return tweaks_.get(index);
    }

    public static final int TAPROOT_TWEAK_FIELD_NUMBER = 5;
    private signrpc.SignerOuterClass.TaprootTweakDesc taprootTweak_;
    /**
     * <pre>
     *
     *An optional taproot specific tweak that must be specified if the MuSig2
     *combined key will be used as the main taproot key of a taproot output
     *on-chain.
     * </pre>
     *
     * <code>.signrpc.TaprootTweakDesc taproot_tweak = 5;</code>
     * @return Whether the taprootTweak field is set.
     */
    @java.lang.Override
    public boolean hasTaprootTweak() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <pre>
     *
     *An optional taproot specific tweak that must be specified if the MuSig2
     *combined key will be used as the main taproot key of a taproot output
     *on-chain.
     * </pre>
     *
     * <code>.signrpc.TaprootTweakDesc taproot_tweak = 5;</code>
     * @return The taprootTweak.
     */
    @java.lang.Override
    public signrpc.SignerOuterClass.TaprootTweakDesc getTaprootTweak() {
      return taprootTweak_ == null ? signrpc.SignerOuterClass.TaprootTweakDesc.getDefaultInstance() : taprootTweak_;
    }
    /**
     * <pre>
     *
     *An optional taproot specific tweak that must be specified if the MuSig2
     *combined key will be used as the main taproot key of a taproot output
     *on-chain.
     * </pre>
     *
     * <code>.signrpc.TaprootTweakDesc taproot_tweak = 5;</code>
     */
    @java.lang.Override
    public signrpc.SignerOuterClass.TaprootTweakDescOrBuilder getTaprootTweakOrBuilder() {
      return taprootTweak_ == null ? signrpc.SignerOuterClass.TaprootTweakDesc.getDefaultInstance() : taprootTweak_;
    }

    public static final int VERSION_FIELD_NUMBER = 6;
    private int version_ = 0;
    /**
     * <pre>
     *
     *The mandatory version of the MuSig2 BIP draft to use. This is necessary to
     *differentiate between the changes that were made to the BIP while this
     *experimental RPC was already released. Some of those changes affect how the
     *combined key and nonces are created.
     * </pre>
     *
     * <code>.signrpc.MuSig2Version version = 6;</code>
     * @return The enum numeric value on the wire for version.
     */
    @java.lang.Override public int getVersionValue() {
      return version_;
    }
    /**
     * <pre>
     *
     *The mandatory version of the MuSig2 BIP draft to use. This is necessary to
     *differentiate between the changes that were made to the BIP while this
     *experimental RPC was already released. Some of those changes affect how the
     *combined key and nonces are created.
     * </pre>
     *
     * <code>.signrpc.MuSig2Version version = 6;</code>
     * @return The version.
     */
    @java.lang.Override public signrpc.SignerOuterClass.MuSig2Version getVersion() {
      signrpc.SignerOuterClass.MuSig2Version result = signrpc.SignerOuterClass.MuSig2Version.forNumber(version_);
      return result == null ? signrpc.SignerOuterClass.MuSig2Version.UNRECOGNIZED : result;
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) != 0)) {
        output.writeMessage(1, getKeyLoc());
      }
      for (int i = 0; i < allSignerPubkeys_.size(); i++) {
        output.writeBytes(2, allSignerPubkeys_.get(i));
      }
      for (int i = 0; i < otherSignerPublicNonces_.size(); i++) {
        output.writeBytes(3, otherSignerPublicNonces_.get(i));
      }
      for (int i = 0; i < tweaks_.size(); i++) {
        output.writeMessage(4, tweaks_.get(i));
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        output.writeMessage(5, getTaprootTweak());
      }
      if (version_ != signrpc.SignerOuterClass.MuSig2Version.MUSIG2_VERSION_UNDEFINED.getNumber()) {
        output.writeEnum(6, version_);
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(1, getKeyLoc());
      }
      {
        int dataSize = 0;
        for (int i = 0; i < allSignerPubkeys_.size(); i++) {
          dataSize += com.google.protobuf.CodedOutputStream
            .computeBytesSizeNoTag(allSignerPubkeys_.get(i));
        }
        size += dataSize;
        size += 1 * getAllSignerPubkeysList().size();
      }
      {
        int dataSize = 0;
        for (int i = 0; i < otherSignerPublicNonces_.size(); i++) {
          dataSize += com.google.protobuf.CodedOutputStream
            .computeBytesSizeNoTag(otherSignerPublicNonces_.get(i));
        }
        size += dataSize;
        size += 1 * getOtherSignerPublicNoncesList().size();
      }
      for (int i = 0; i < tweaks_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(4, tweaks_.get(i));
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(5, getTaprootTweak());
      }
      if (version_ != signrpc.SignerOuterClass.MuSig2Version.MUSIG2_VERSION_UNDEFINED.getNumber()) {
        size += com.google.protobuf.CodedOutputStream
          .computeEnumSize(6, version_);
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof signrpc.SignerOuterClass.MuSig2SessionRequest)) {
        return super.equals(obj);
      }
      signrpc.SignerOuterClass.MuSig2SessionRequest other = (signrpc.SignerOuterClass.MuSig2SessionRequest) obj;

      if (hasKeyLoc() != other.hasKeyLoc()) return false;
      if (hasKeyLoc()) {
        if (!getKeyLoc()
            .equals(other.getKeyLoc())) return false;
      }
      if (!getAllSignerPubkeysList()
          .equals(other.getAllSignerPubkeysList())) return false;
      if (!getOtherSignerPublicNoncesList()
          .equals(other.getOtherSignerPublicNoncesList())) return false;
      if (!getTweaksList()
          .equals(other.getTweaksList())) return false;
      if (hasTaprootTweak() != other.hasTaprootTweak()) return false;
      if (hasTaprootTweak()) {
        if (!getTaprootTweak()
            .equals(other.getTaprootTweak())) return false;
      }
      if (version_ != other.version_) return false;
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasKeyLoc()) {
        hash = (37 * hash) + KEY_LOC_FIELD_NUMBER;
        hash = (53 * hash) + getKeyLoc().hashCode();
      }
      if (getAllSignerPubkeysCount() > 0) {
        hash = (37 * hash) + ALL_SIGNER_PUBKEYS_FIELD_NUMBER;
        hash = (53 * hash) + getAllSignerPubkeysList().hashCode();
      }
      if (getOtherSignerPublicNoncesCount() > 0) {
        hash = (37 * hash) + OTHER_SIGNER_PUBLIC_NONCES_FIELD_NUMBER;
        hash = (53 * hash) + getOtherSignerPublicNoncesList().hashCode();
      }
      if (getTweaksCount() > 0) {
        hash = (37 * hash) + TWEAKS_FIELD_NUMBER;
        hash = (53 * hash) + getTweaksList().hashCode();
      }
      if (hasTaprootTweak()) {
        hash = (37 * hash) + TAPROOT_TWEAK_FIELD_NUMBER;
        hash = (53 * hash) + getTaprootTweak().hashCode();
      }
      hash = (37 * hash) + VERSION_FIELD_NUMBER;
      hash = (53 * hash) + version_;
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static signrpc.SignerOuterClass.MuSig2SessionRequest parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static signrpc.SignerOuterClass.MuSig2SessionRequest parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static signrpc.SignerOuterClass.MuSig2SessionRequest parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static signrpc.SignerOuterClass.MuSig2SessionRequest parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static signrpc.SignerOuterClass.MuSig2SessionRequest parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static signrpc.SignerOuterClass.MuSig2SessionRequest parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static signrpc.SignerOuterClass.MuSig2SessionRequest parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static signrpc.SignerOuterClass.MuSig2SessionRequest parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static signrpc.SignerOuterClass.MuSig2SessionRequest parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static signrpc.SignerOuterClass.MuSig2SessionRequest parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static signrpc.SignerOuterClass.MuSig2SessionRequest parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static signrpc.SignerOuterClass.MuSig2SessionRequest parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(signrpc.SignerOuterClass.MuSig2SessionRequest prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * Protobuf type {@code signrpc.MuSig2SessionRequest}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:signrpc.MuSig2SessionRequest)
        signrpc.SignerOuterClass.MuSig2SessionRequestOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return signrpc.SignerOuterClass.internal_static_signrpc_MuSig2SessionRequest_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return signrpc.SignerOuterClass.internal_static_signrpc_MuSig2SessionRequest_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                signrpc.SignerOuterClass.MuSig2SessionRequest.class, signrpc.SignerOuterClass.MuSig2SessionRequest.Builder.class);
      }

      // Construct using signrpc.SignerOuterClass.MuSig2SessionRequest.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
          getKeyLocFieldBuilder();
          getTweaksFieldBuilder();
          getTaprootTweakFieldBuilder();
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        keyLoc_ = null;
        if (keyLocBuilder_ != null) {
          keyLocBuilder_.dispose();
          keyLocBuilder_ = null;
        }
        allSignerPubkeys_ = emptyList(com.google.protobuf.ByteString.class);
        otherSignerPublicNonces_ = emptyList(com.google.protobuf.ByteString.class);
        if (tweaksBuilder_ == null) {
          tweaks_ = java.util.Collections.emptyList();
        } else {
          tweaks_ = null;
          tweaksBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000008);
        taprootTweak_ = null;
        if (taprootTweakBuilder_ != null) {
          taprootTweakBuilder_.dispose();
          taprootTweakBuilder_ = null;
        }
        version_ = 0;
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return signrpc.SignerOuterClass.internal_static_signrpc_MuSig2SessionRequest_descriptor;
      }

      @java.lang.Override
      public signrpc.SignerOuterClass.MuSig2SessionRequest getDefaultInstanceForType() {
        return signrpc.SignerOuterClass.MuSig2SessionRequest.getDefaultInstance();
      }

      @java.lang.Override
      public signrpc.SignerOuterClass.MuSig2SessionRequest build() {
        signrpc.SignerOuterClass.MuSig2SessionRequest result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public signrpc.SignerOuterClass.MuSig2SessionRequest buildPartial() {
        signrpc.SignerOuterClass.MuSig2SessionRequest result = new signrpc.SignerOuterClass.MuSig2SessionRequest(this);
        buildPartialRepeatedFields(result);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartialRepeatedFields(signrpc.SignerOuterClass.MuSig2SessionRequest result) {
        if (tweaksBuilder_ == null) {
          if (((bitField0_ & 0x00000008) != 0)) {
            tweaks_ = java.util.Collections.unmodifiableList(tweaks_);
            bitField0_ = (bitField0_ & ~0x00000008);
          }
          result.tweaks_ = tweaks_;
        } else {
          result.tweaks_ = tweaksBuilder_.build();
        }
      }

      private void buildPartial0(signrpc.SignerOuterClass.MuSig2SessionRequest result) {
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.keyLoc_ = keyLocBuilder_ == null
              ? keyLoc_
              : keyLocBuilder_.build();
          to_bitField0_ |= 0x00000001;
        }
        if (((from_bitField0_ & 0x00000002) != 0)) {
          allSignerPubkeys_.makeImmutable();
          result.allSignerPubkeys_ = allSignerPubkeys_;
        }
        if (((from_bitField0_ & 0x00000004) != 0)) {
          otherSignerPublicNonces_.makeImmutable();
          result.otherSignerPublicNonces_ = otherSignerPublicNonces_;
        }
        if (((from_bitField0_ & 0x00000010) != 0)) {
          result.taprootTweak_ = taprootTweakBuilder_ == null
              ? taprootTweak_
              : taprootTweakBuilder_.build();
          to_bitField0_ |= 0x00000002;
        }
        if (((from_bitField0_ & 0x00000020) != 0)) {
          result.version_ = version_;
        }
        result.bitField0_ |= to_bitField0_;
      }

      @java.lang.Override
      public Builder clone() {
        return super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof signrpc.SignerOuterClass.MuSig2SessionRequest) {
          return mergeFrom((signrpc.SignerOuterClass.MuSig2SessionRequest)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(signrpc.SignerOuterClass.MuSig2SessionRequest other) {
        if (other == signrpc.SignerOuterClass.MuSig2SessionRequest.getDefaultInstance()) return this;
        if (other.hasKeyLoc()) {
          mergeKeyLoc(other.getKeyLoc());
        }
        if (!other.allSignerPubkeys_.isEmpty()) {
          if (allSignerPubkeys_.isEmpty()) {
            allSignerPubkeys_ = other.allSignerPubkeys_;
            allSignerPubkeys_.makeImmutable();
            bitField0_ |= 0x00000002;
          } else {
            ensureAllSignerPubkeysIsMutable();
            allSignerPubkeys_.addAll(other.allSignerPubkeys_);
          }
          onChanged();
        }
        if (!other.otherSignerPublicNonces_.isEmpty()) {
          if (otherSignerPublicNonces_.isEmpty()) {
            otherSignerPublicNonces_ = other.otherSignerPublicNonces_;
            otherSignerPublicNonces_.makeImmutable();
            bitField0_ |= 0x00000004;
          } else {
            ensureOtherSignerPublicNoncesIsMutable();
            otherSignerPublicNonces_.addAll(other.otherSignerPublicNonces_);
          }
          onChanged();
        }
        if (tweaksBuilder_ == null) {
          if (!other.tweaks_.isEmpty()) {
            if (tweaks_.isEmpty()) {
              tweaks_ = other.tweaks_;
              bitField0_ = (bitField0_ & ~0x00000008);
            } else {
              ensureTweaksIsMutable();
              tweaks_.addAll(other.tweaks_);
            }
            onChanged();
          }
        } else {
          if (!other.tweaks_.isEmpty()) {
            if (tweaksBuilder_.isEmpty()) {
              tweaksBuilder_.dispose();
              tweaksBuilder_ = null;
              tweaks_ = other.tweaks_;
              bitField0_ = (bitField0_ & ~0x00000008);
              tweaksBuilder_ = 
                com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
                   getTweaksFieldBuilder() : null;
            } else {
              tweaksBuilder_.addAllMessages(other.tweaks_);
            }
          }
        }
        if (other.hasTaprootTweak()) {
          mergeTaprootTweak(other.getTaprootTweak());
        }
        if (other.version_ != 0) {
          setVersionValue(other.getVersionValue());
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10: {
                input.readMessage(
                    getKeyLocFieldBuilder().getBuilder(),
                    extensionRegistry);
                bitField0_ |= 0x00000001;
                break;
              } // case 10
              case 18: {
                com.google.protobuf.ByteString v = input.readBytes();
                ensureAllSignerPubkeysIsMutable();
                allSignerPubkeys_.add(v);
                break;
              } // case 18
              case 26: {
                com.google.protobuf.ByteString v = input.readBytes();
                ensureOtherSignerPublicNoncesIsMutable();
                otherSignerPublicNonces_.add(v);
                break;
              } // case 26
              case 34: {
                signrpc.SignerOuterClass.TweakDesc m =
                    input.readMessage(
                        signrpc.SignerOuterClass.TweakDesc.parser(),
                        extensionRegistry);
                if (tweaksBuilder_ == null) {
                  ensureTweaksIsMutable();
                  tweaks_.add(m);
                } else {
                  tweaksBuilder_.addMessage(m);
                }
                break;
              } // case 34
              case 42: {
                input.readMessage(
                    getTaprootTweakFieldBuilder().getBuilder(),
                    extensionRegistry);
                bitField0_ |= 0x00000010;
                break;
              } // case 42
              case 48: {
                version_ = input.readEnum();
                bitField0_ |= 0x00000020;
                break;
              } // case 48
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private signrpc.SignerOuterClass.KeyLocator keyLoc_;
      private com.google.protobuf.SingleFieldBuilderV3<
          signrpc.SignerOuterClass.KeyLocator, signrpc.SignerOuterClass.KeyLocator.Builder, signrpc.SignerOuterClass.KeyLocatorOrBuilder> keyLocBuilder_;
      /**
       * <pre>
       *
       *The key locator that identifies which key to use for signing.
       * </pre>
       *
       * <code>.signrpc.KeyLocator key_loc = 1;</code>
       * @return Whether the keyLoc field is set.
       */
      public boolean hasKeyLoc() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <pre>
       *
       *The key locator that identifies which key to use for signing.
       * </pre>
       *
       * <code>.signrpc.KeyLocator key_loc = 1;</code>
       * @return The keyLoc.
       */
      public signrpc.SignerOuterClass.KeyLocator getKeyLoc() {
        if (keyLocBuilder_ == null) {
          return keyLoc_ == null ? signrpc.SignerOuterClass.KeyLocator.getDefaultInstance() : keyLoc_;
        } else {
          return keyLocBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       *
       *The key locator that identifies which key to use for signing.
       * </pre>
       *
       * <code>.signrpc.KeyLocator key_loc = 1;</code>
       */
      public Builder setKeyLoc(signrpc.SignerOuterClass.KeyLocator value) {
        if (keyLocBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          keyLoc_ = value;
        } else {
          keyLocBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       *
       *The key locator that identifies which key to use for signing.
       * </pre>
       *
       * <code>.signrpc.KeyLocator key_loc = 1;</code>
       */
      public Builder setKeyLoc(
          signrpc.SignerOuterClass.KeyLocator.Builder builderForValue) {
        if (keyLocBuilder_ == null) {
          keyLoc_ = builderForValue.build();
        } else {
          keyLocBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       *
       *The key locator that identifies which key to use for signing.
       * </pre>
       *
       * <code>.signrpc.KeyLocator key_loc = 1;</code>
       */
      public Builder mergeKeyLoc(signrpc.SignerOuterClass.KeyLocator value) {
        if (keyLocBuilder_ == null) {
          if (((bitField0_ & 0x00000001) != 0) &&
            keyLoc_ != null &&
            keyLoc_ != signrpc.SignerOuterClass.KeyLocator.getDefaultInstance()) {
            getKeyLocBuilder().mergeFrom(value);
          } else {
            keyLoc_ = value;
          }
        } else {
          keyLocBuilder_.mergeFrom(value);
        }
        if (keyLoc_ != null) {
          bitField0_ |= 0x00000001;
          onChanged();
        }
        return this;
      }
      /**
       * <pre>
       *
       *The key locator that identifies which key to use for signing.
       * </pre>
       *
       * <code>.signrpc.KeyLocator key_loc = 1;</code>
       */
      public Builder clearKeyLoc() {
        bitField0_ = (bitField0_ & ~0x00000001);
        keyLoc_ = null;
        if (keyLocBuilder_ != null) {
          keyLocBuilder_.dispose();
          keyLocBuilder_ = null;
        }
        onChanged();
        return this;
      }
      /**
       * <pre>
       *
       *The key locator that identifies which key to use for signing.
       * </pre>
       *
       * <code>.signrpc.KeyLocator key_loc = 1;</code>
       */
      public signrpc.SignerOuterClass.KeyLocator.Builder getKeyLocBuilder() {
        bitField0_ |= 0x00000001;
        onChanged();
        return getKeyLocFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       *
       *The key locator that identifies which key to use for signing.
       * </pre>
       *
       * <code>.signrpc.KeyLocator key_loc = 1;</code>
       */
      public signrpc.SignerOuterClass.KeyLocatorOrBuilder getKeyLocOrBuilder() {
        if (keyLocBuilder_ != null) {
          return keyLocBuilder_.getMessageOrBuilder();
        } else {
          return keyLoc_ == null ?
              signrpc.SignerOuterClass.KeyLocator.getDefaultInstance() : keyLoc_;
        }
      }
      /**
       * <pre>
       *
       *The key locator that identifies which key to use for signing.
       * </pre>
       *
       * <code>.signrpc.KeyLocator key_loc = 1;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          signrpc.SignerOuterClass.KeyLocator, signrpc.SignerOuterClass.KeyLocator.Builder, signrpc.SignerOuterClass.KeyLocatorOrBuilder> 
          getKeyLocFieldBuilder() {
        if (keyLocBuilder_ == null) {
          keyLocBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              signrpc.SignerOuterClass.KeyLocator, signrpc.SignerOuterClass.KeyLocator.Builder, signrpc.SignerOuterClass.KeyLocatorOrBuilder>(
                  getKeyLoc(),
                  getParentForChildren(),
                  isClean());
          keyLoc_ = null;
        }
        return keyLocBuilder_;
      }

      private com.google.protobuf.Internal.ProtobufList<com.google.protobuf.ByteString> allSignerPubkeys_ = emptyList(com.google.protobuf.ByteString.class);
      private void ensureAllSignerPubkeysIsMutable() {
        if (!allSignerPubkeys_.isModifiable()) {
          allSignerPubkeys_ = makeMutableCopy(allSignerPubkeys_);
        }
        bitField0_ |= 0x00000002;
      }
      /**
       * <pre>
       *
       *A list of all public keys (serialized in 32-byte x-only format for v0.4.0
       *and 33-byte compressed format for v1.0.0rc2!) participating in the signing
       *session. The list will always be sorted lexicographically internally. This
       *must include the local key which is described by the above key_loc.
       * </pre>
       *
       * <code>repeated bytes all_signer_pubkeys = 2;</code>
       * @return A list containing the allSignerPubkeys.
       */
      public java.util.List<com.google.protobuf.ByteString>
          getAllSignerPubkeysList() {
        allSignerPubkeys_.makeImmutable();
        return allSignerPubkeys_;
      }
      /**
       * <pre>
       *
       *A list of all public keys (serialized in 32-byte x-only format for v0.4.0
       *and 33-byte compressed format for v1.0.0rc2!) participating in the signing
       *session. The list will always be sorted lexicographically internally. This
       *must include the local key which is described by the above key_loc.
       * </pre>
       *
       * <code>repeated bytes all_signer_pubkeys = 2;</code>
       * @return The count of allSignerPubkeys.
       */
      public int getAllSignerPubkeysCount() {
        return allSignerPubkeys_.size();
      }
      /**
       * <pre>
       *
       *A list of all public keys (serialized in 32-byte x-only format for v0.4.0
       *and 33-byte compressed format for v1.0.0rc2!) participating in the signing
       *session. The list will always be sorted lexicographically internally. This
       *must include the local key which is described by the above key_loc.
       * </pre>
       *
       * <code>repeated bytes all_signer_pubkeys = 2;</code>
       * @param index The index of the element to return.
       * @return The allSignerPubkeys at the given index.
       */
      public com.google.protobuf.ByteString getAllSignerPubkeys(int index) {
        return allSignerPubkeys_.get(index);
      }
      /**
       * <pre>
       *
       *A list of all public keys (serialized in 32-byte x-only format for v0.4.0
       *and 33-byte compressed format for v1.0.0rc2!) participating in the signing
       *session. The list will always be sorted lexicographically internally. This
       *must include the local key which is described by the above key_loc.
       * </pre>
       *
       * <code>repeated bytes all_signer_pubkeys = 2;</code>
       * @param index The index to set the value at.
       * @param value The allSignerPubkeys to set.
       * @return This builder for chaining.
       */
      public Builder setAllSignerPubkeys(
          int index, com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        ensureAllSignerPubkeysIsMutable();
        allSignerPubkeys_.set(index, value);
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       *
       *A list of all public keys (serialized in 32-byte x-only format for v0.4.0
       *and 33-byte compressed format for v1.0.0rc2!) participating in the signing
       *session. The list will always be sorted lexicographically internally. This
       *must include the local key which is described by the above key_loc.
       * </pre>
       *
       * <code>repeated bytes all_signer_pubkeys = 2;</code>
       * @param value The allSignerPubkeys to add.
       * @return This builder for chaining.
       */
      public Builder addAllSignerPubkeys(com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        ensureAllSignerPubkeysIsMutable();
        allSignerPubkeys_.add(value);
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       *
       *A list of all public keys (serialized in 32-byte x-only format for v0.4.0
       *and 33-byte compressed format for v1.0.0rc2!) participating in the signing
       *session. The list will always be sorted lexicographically internally. This
       *must include the local key which is described by the above key_loc.
       * </pre>
       *
       * <code>repeated bytes all_signer_pubkeys = 2;</code>
       * @param values The allSignerPubkeys to add.
       * @return This builder for chaining.
       */
      public Builder addAllAllSignerPubkeys(
          java.lang.Iterable<? extends com.google.protobuf.ByteString> values) {
        ensureAllSignerPubkeysIsMutable();
        com.google.protobuf.AbstractMessageLite.Builder.addAll(
            values, allSignerPubkeys_);
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       *
       *A list of all public keys (serialized in 32-byte x-only format for v0.4.0
       *and 33-byte compressed format for v1.0.0rc2!) participating in the signing
       *session. The list will always be sorted lexicographically internally. This
       *must include the local key which is described by the above key_loc.
       * </pre>
       *
       * <code>repeated bytes all_signer_pubkeys = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearAllSignerPubkeys() {
        allSignerPubkeys_ = emptyList(com.google.protobuf.ByteString.class);
        bitField0_ = (bitField0_ & ~0x00000002);
        onChanged();
        return this;
      }

      private com.google.protobuf.Internal.ProtobufList<com.google.protobuf.ByteString> otherSignerPublicNonces_ = emptyList(com.google.protobuf.ByteString.class);
      private void ensureOtherSignerPublicNoncesIsMutable() {
        if (!otherSignerPublicNonces_.isModifiable()) {
          otherSignerPublicNonces_ = makeMutableCopy(otherSignerPublicNonces_);
        }
        bitField0_ |= 0x00000004;
      }
      /**
       * <pre>
       *
       *An optional list of all public nonces of other signing participants that
       *might already be known.
       * </pre>
       *
       * <code>repeated bytes other_signer_public_nonces = 3;</code>
       * @return A list containing the otherSignerPublicNonces.
       */
      public java.util.List<com.google.protobuf.ByteString>
          getOtherSignerPublicNoncesList() {
        otherSignerPublicNonces_.makeImmutable();
        return otherSignerPublicNonces_;
      }
      /**
       * <pre>
       *
       *An optional list of all public nonces of other signing participants that
       *might already be known.
       * </pre>
       *
       * <code>repeated bytes other_signer_public_nonces = 3;</code>
       * @return The count of otherSignerPublicNonces.
       */
      public int getOtherSignerPublicNoncesCount() {
        return otherSignerPublicNonces_.size();
      }
      /**
       * <pre>
       *
       *An optional list of all public nonces of other signing participants that
       *might already be known.
       * </pre>
       *
       * <code>repeated bytes other_signer_public_nonces = 3;</code>
       * @param index The index of the element to return.
       * @return The otherSignerPublicNonces at the given index.
       */
      public com.google.protobuf.ByteString getOtherSignerPublicNonces(int index) {
        return otherSignerPublicNonces_.get(index);
      }
      /**
       * <pre>
       *
       *An optional list of all public nonces of other signing participants that
       *might already be known.
       * </pre>
       *
       * <code>repeated bytes other_signer_public_nonces = 3;</code>
       * @param index The index to set the value at.
       * @param value The otherSignerPublicNonces to set.
       * @return This builder for chaining.
       */
      public Builder setOtherSignerPublicNonces(
          int index, com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        ensureOtherSignerPublicNoncesIsMutable();
        otherSignerPublicNonces_.set(index, value);
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }
      /**
       * <pre>
       *
       *An optional list of all public nonces of other signing participants that
       *might already be known.
       * </pre>
       *
       * <code>repeated bytes other_signer_public_nonces = 3;</code>
       * @param value The otherSignerPublicNonces to add.
       * @return This builder for chaining.
       */
      public Builder addOtherSignerPublicNonces(com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        ensureOtherSignerPublicNoncesIsMutable();
        otherSignerPublicNonces_.add(value);
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }
      /**
       * <pre>
       *
       *An optional list of all public nonces of other signing participants that
       *might already be known.
       * </pre>
       *
       * <code>repeated bytes other_signer_public_nonces = 3;</code>
       * @param values The otherSignerPublicNonces to add.
       * @return This builder for chaining.
       */
      public Builder addAllOtherSignerPublicNonces(
          java.lang.Iterable<? extends com.google.protobuf.ByteString> values) {
        ensureOtherSignerPublicNoncesIsMutable();
        com.google.protobuf.AbstractMessageLite.Builder.addAll(
            values, otherSignerPublicNonces_);
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }
      /**
       * <pre>
       *
       *An optional list of all public nonces of other signing participants that
       *might already be known.
       * </pre>
       *
       * <code>repeated bytes other_signer_public_nonces = 3;</code>
       * @return This builder for chaining.
       */
      public Builder clearOtherSignerPublicNonces() {
        otherSignerPublicNonces_ = emptyList(com.google.protobuf.ByteString.class);
        bitField0_ = (bitField0_ & ~0x00000004);
        onChanged();
        return this;
      }

      private java.util.List<signrpc.SignerOuterClass.TweakDesc> tweaks_ =
        java.util.Collections.emptyList();
      private void ensureTweaksIsMutable() {
        if (!((bitField0_ & 0x00000008) != 0)) {
          tweaks_ = new java.util.ArrayList<signrpc.SignerOuterClass.TweakDesc>(tweaks_);
          bitField0_ |= 0x00000008;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
          signrpc.SignerOuterClass.TweakDesc, signrpc.SignerOuterClass.TweakDesc.Builder, signrpc.SignerOuterClass.TweakDescOrBuilder> tweaksBuilder_;

      /**
       * <pre>
       *
       *A series of optional generic tweaks to be applied to the the aggregated
       *public key.
       * </pre>
       *
       * <code>repeated .signrpc.TweakDesc tweaks = 4;</code>
       */
      public java.util.List<signrpc.SignerOuterClass.TweakDesc> getTweaksList() {
        if (tweaksBuilder_ == null) {
          return java.util.Collections.unmodifiableList(tweaks_);
        } else {
          return tweaksBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       *
       *A series of optional generic tweaks to be applied to the the aggregated
       *public key.
       * </pre>
       *
       * <code>repeated .signrpc.TweakDesc tweaks = 4;</code>
       */
      public int getTweaksCount() {
        if (tweaksBuilder_ == null) {
          return tweaks_.size();
        } else {
          return tweaksBuilder_.getCount();
        }
      }
      /**
       * <pre>
       *
       *A series of optional generic tweaks to be applied to the the aggregated
       *public key.
       * </pre>
       *
       * <code>repeated .signrpc.TweakDesc tweaks = 4;</code>
       */
      public signrpc.SignerOuterClass.TweakDesc getTweaks(int index) {
        if (tweaksBuilder_ == null) {
          return tweaks_.get(index);
        } else {
          return tweaksBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       *
       *A series of optional generic tweaks to be applied to the the aggregated
       *public key.
       * </pre>
       *
       * <code>repeated .signrpc.TweakDesc tweaks = 4;</code>
       */
      public Builder setTweaks(
          int index, signrpc.SignerOuterClass.TweakDesc value) {
        if (tweaksBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureTweaksIsMutable();
          tweaks_.set(index, value);
          onChanged();
        } else {
          tweaksBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       *
       *A series of optional generic tweaks to be applied to the the aggregated
       *public key.
       * </pre>
       *
       * <code>repeated .signrpc.TweakDesc tweaks = 4;</code>
       */
      public Builder setTweaks(
          int index, signrpc.SignerOuterClass.TweakDesc.Builder builderForValue) {
        if (tweaksBuilder_ == null) {
          ensureTweaksIsMutable();
          tweaks_.set(index, builderForValue.build());
          onChanged();
        } else {
          tweaksBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       *
       *A series of optional generic tweaks to be applied to the the aggregated
       *public key.
       * </pre>
       *
       * <code>repeated .signrpc.TweakDesc tweaks = 4;</code>
       */
      public Builder addTweaks(signrpc.SignerOuterClass.TweakDesc value) {
        if (tweaksBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureTweaksIsMutable();
          tweaks_.add(value);
          onChanged();
        } else {
          tweaksBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       *
       *A series of optional generic tweaks to be applied to the the aggregated
       *public key.
       * </pre>
       *
       * <code>repeated .signrpc.TweakDesc tweaks = 4;</code>
       */
      public Builder addTweaks(
          int index, signrpc.SignerOuterClass.TweakDesc value) {
        if (tweaksBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureTweaksIsMutable();
          tweaks_.add(index, value);
          onChanged();
        } else {
          tweaksBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       *
       *A series of optional generic tweaks to be applied to the the aggregated
       *public key.
       * </pre>
       *
       * <code>repeated .signrpc.TweakDesc tweaks = 4;</code>
       */
      public Builder addTweaks(
          signrpc.SignerOuterClass.TweakDesc.Builder builderForValue) {
        if (tweaksBuilder_ == null) {
          ensureTweaksIsMutable();
          tweaks_.add(builderForValue.build());
          onChanged();
        } else {
          tweaksBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       *
       *A series of optional generic tweaks to be applied to the the aggregated
       *public key.
       * </pre>
       *
       * <code>repeated .signrpc.TweakDesc tweaks = 4;</code>
       */
      public Builder addTweaks(
          int index, signrpc.SignerOuterClass.TweakDesc.Builder builderForValue) {
        if (tweaksBuilder_ == null) {
          ensureTweaksIsMutable();
          tweaks_.add(index, builderForValue.build());
          onChanged();
        } else {
          tweaksBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       *
       *A series of optional generic tweaks to be applied to the the aggregated
       *public key.
       * </pre>
       *
       * <code>repeated .signrpc.TweakDesc tweaks = 4;</code>
       */
      public Builder addAllTweaks(
          java.lang.Iterable<? extends signrpc.SignerOuterClass.TweakDesc> values) {
        if (tweaksBuilder_ == null) {
          ensureTweaksIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, tweaks_);
          onChanged();
        } else {
          tweaksBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       *
       *A series of optional generic tweaks to be applied to the the aggregated
       *public key.
       * </pre>
       *
       * <code>repeated .signrpc.TweakDesc tweaks = 4;</code>
       */
      public Builder clearTweaks() {
        if (tweaksBuilder_ == null) {
          tweaks_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000008);
          onChanged();
        } else {
          tweaksBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       *
       *A series of optional generic tweaks to be applied to the the aggregated
       *public key.
       * </pre>
       *
       * <code>repeated .signrpc.TweakDesc tweaks = 4;</code>
       */
      public Builder removeTweaks(int index) {
        if (tweaksBuilder_ == null) {
          ensureTweaksIsMutable();
          tweaks_.remove(index);
          onChanged();
        } else {
          tweaksBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       *
       *A series of optional generic tweaks to be applied to the the aggregated
       *public key.
       * </pre>
       *
       * <code>repeated .signrpc.TweakDesc tweaks = 4;</code>
       */
      public signrpc.SignerOuterClass.TweakDesc.Builder getTweaksBuilder(
          int index) {
        return getTweaksFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       *
       *A series of optional generic tweaks to be applied to the the aggregated
       *public key.
       * </pre>
       *
       * <code>repeated .signrpc.TweakDesc tweaks = 4;</code>
       */
      public signrpc.SignerOuterClass.TweakDescOrBuilder getTweaksOrBuilder(
          int index) {
        if (tweaksBuilder_ == null) {
          return tweaks_.get(index);  } else {
          return tweaksBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       *
       *A series of optional generic tweaks to be applied to the the aggregated
       *public key.
       * </pre>
       *
       * <code>repeated .signrpc.TweakDesc tweaks = 4;</code>
       */
      public java.util.List<? extends signrpc.SignerOuterClass.TweakDescOrBuilder> 
           getTweaksOrBuilderList() {
        if (tweaksBuilder_ != null) {
          return tweaksBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(tweaks_);
        }
      }
      /**
       * <pre>
       *
       *A series of optional generic tweaks to be applied to the the aggregated
       *public key.
       * </pre>
       *
       * <code>repeated .signrpc.TweakDesc tweaks = 4;</code>
       */
      public signrpc.SignerOuterClass.TweakDesc.Builder addTweaksBuilder() {
        return getTweaksFieldBuilder().addBuilder(
            signrpc.SignerOuterClass.TweakDesc.getDefaultInstance());
      }
      /**
       * <pre>
       *
       *A series of optional generic tweaks to be applied to the the aggregated
       *public key.
       * </pre>
       *
       * <code>repeated .signrpc.TweakDesc tweaks = 4;</code>
       */
      public signrpc.SignerOuterClass.TweakDesc.Builder addTweaksBuilder(
          int index) {
        return getTweaksFieldBuilder().addBuilder(
            index, signrpc.SignerOuterClass.TweakDesc.getDefaultInstance());
      }
      /**
       * <pre>
       *
       *A series of optional generic tweaks to be applied to the the aggregated
       *public key.
       * </pre>
       *
       * <code>repeated .signrpc.TweakDesc tweaks = 4;</code>
       */
      public java.util.List<signrpc.SignerOuterClass.TweakDesc.Builder> 
           getTweaksBuilderList() {
        return getTweaksFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilderV3<
          signrpc.SignerOuterClass.TweakDesc, signrpc.SignerOuterClass.TweakDesc.Builder, signrpc.SignerOuterClass.TweakDescOrBuilder> 
          getTweaksFieldBuilder() {
        if (tweaksBuilder_ == null) {
          tweaksBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<
              signrpc.SignerOuterClass.TweakDesc, signrpc.SignerOuterClass.TweakDesc.Builder, signrpc.SignerOuterClass.TweakDescOrBuilder>(
                  tweaks_,
                  ((bitField0_ & 0x00000008) != 0),
                  getParentForChildren(),
                  isClean());
          tweaks_ = null;
        }
        return tweaksBuilder_;
      }

      private signrpc.SignerOuterClass.TaprootTweakDesc taprootTweak_;
      private com.google.protobuf.SingleFieldBuilderV3<
          signrpc.SignerOuterClass.TaprootTweakDesc, signrpc.SignerOuterClass.TaprootTweakDesc.Builder, signrpc.SignerOuterClass.TaprootTweakDescOrBuilder> taprootTweakBuilder_;
      /**
       * <pre>
       *
       *An optional taproot specific tweak that must be specified if the MuSig2
       *combined key will be used as the main taproot key of a taproot output
       *on-chain.
       * </pre>
       *
       * <code>.signrpc.TaprootTweakDesc taproot_tweak = 5;</code>
       * @return Whether the taprootTweak field is set.
       */
      public boolean hasTaprootTweak() {
        return ((bitField0_ & 0x00000010) != 0);
      }
      /**
       * <pre>
       *
       *An optional taproot specific tweak that must be specified if the MuSig2
       *combined key will be used as the main taproot key of a taproot output
       *on-chain.
       * </pre>
       *
       * <code>.signrpc.TaprootTweakDesc taproot_tweak = 5;</code>
       * @return The taprootTweak.
       */
      public signrpc.SignerOuterClass.TaprootTweakDesc getTaprootTweak() {
        if (taprootTweakBuilder_ == null) {
          return taprootTweak_ == null ? signrpc.SignerOuterClass.TaprootTweakDesc.getDefaultInstance() : taprootTweak_;
        } else {
          return taprootTweakBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       *
       *An optional taproot specific tweak that must be specified if the MuSig2
       *combined key will be used as the main taproot key of a taproot output
       *on-chain.
       * </pre>
       *
       * <code>.signrpc.TaprootTweakDesc taproot_tweak = 5;</code>
       */
      public Builder setTaprootTweak(signrpc.SignerOuterClass.TaprootTweakDesc value) {
        if (taprootTweakBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          taprootTweak_ = value;
        } else {
          taprootTweakBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000010;
        onChanged();
        return this;
      }
      /**
       * <pre>
       *
       *An optional taproot specific tweak that must be specified if the MuSig2
       *combined key will be used as the main taproot key of a taproot output
       *on-chain.
       * </pre>
       *
       * <code>.signrpc.TaprootTweakDesc taproot_tweak = 5;</code>
       */
      public Builder setTaprootTweak(
          signrpc.SignerOuterClass.TaprootTweakDesc.Builder builderForValue) {
        if (taprootTweakBuilder_ == null) {
          taprootTweak_ = builderForValue.build();
        } else {
          taprootTweakBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000010;
        onChanged();
        return this;
      }
      /**
       * <pre>
       *
       *An optional taproot specific tweak that must be specified if the MuSig2
       *combined key will be used as the main taproot key of a taproot output
       *on-chain.
       * </pre>
       *
       * <code>.signrpc.TaprootTweakDesc taproot_tweak = 5;</code>
       */
      public Builder mergeTaprootTweak(signrpc.SignerOuterClass.TaprootTweakDesc value) {
        if (taprootTweakBuilder_ == null) {
          if (((bitField0_ & 0x00000010) != 0) &&
            taprootTweak_ != null &&
            taprootTweak_ != signrpc.SignerOuterClass.TaprootTweakDesc.getDefaultInstance()) {
            getTaprootTweakBuilder().mergeFrom(value);
          } else {
            taprootTweak_ = value;
          }
        } else {
          taprootTweakBuilder_.mergeFrom(value);
        }
        if (taprootTweak_ != null) {
          bitField0_ |= 0x00000010;
          onChanged();
        }
        return this;
      }
      /**
       * <pre>
       *
       *An optional taproot specific tweak that must be specified if the MuSig2
       *combined key will be used as the main taproot key of a taproot output
       *on-chain.
       * </pre>
       *
       * <code>.signrpc.TaprootTweakDesc taproot_tweak = 5;</code>
       */
      public Builder clearTaprootTweak() {
        bitField0_ = (bitField0_ & ~0x00000010);
        taprootTweak_ = null;
        if (taprootTweakBuilder_ != null) {
          taprootTweakBuilder_.dispose();
          taprootTweakBuilder_ = null;
        }
        onChanged();
        return this;
      }
      /**
       * <pre>
       *
       *An optional taproot specific tweak that must be specified if the MuSig2
       *combined key will be used as the main taproot key of a taproot output
       *on-chain.
       * </pre>
       *
       * <code>.signrpc.TaprootTweakDesc taproot_tweak = 5;</code>
       */
      public signrpc.SignerOuterClass.TaprootTweakDesc.Builder getTaprootTweakBuilder() {
        bitField0_ |= 0x00000010;
        onChanged();
        return getTaprootTweakFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       *
       *An optional taproot specific tweak that must be specified if the MuSig2
       *combined key will be used as the main taproot key of a taproot output
       *on-chain.
       * </pre>
       *
       * <code>.signrpc.TaprootTweakDesc taproot_tweak = 5;</code>
       */
      public signrpc.SignerOuterClass.TaprootTweakDescOrBuilder getTaprootTweakOrBuilder() {
        if (taprootTweakBuilder_ != null) {
          return taprootTweakBuilder_.getMessageOrBuilder();
        } else {
          return taprootTweak_ == null ?
              signrpc.SignerOuterClass.TaprootTweakDesc.getDefaultInstance() : taprootTweak_;
        }
      }
      /**
       * <pre>
       *
       *An optional taproot specific tweak that must be specified if the MuSig2
       *combined key will be used as the main taproot key of a taproot output
       *on-chain.
       * </pre>
       *
       * <code>.signrpc.TaprootTweakDesc taproot_tweak = 5;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          signrpc.SignerOuterClass.TaprootTweakDesc, signrpc.SignerOuterClass.TaprootTweakDesc.Builder, signrpc.SignerOuterClass.TaprootTweakDescOrBuilder> 
          getTaprootTweakFieldBuilder() {
        if (taprootTweakBuilder_ == null) {
          taprootTweakBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              signrpc.SignerOuterClass.TaprootTweakDesc, signrpc.SignerOuterClass.TaprootTweakDesc.Builder, signrpc.SignerOuterClass.TaprootTweakDescOrBuilder>(
                  getTaprootTweak(),
                  getParentForChildren(),
                  isClean());
          taprootTweak_ = null;
        }
        return taprootTweakBuilder_;
      }

      private int version_ = 0;
      /**
       * <pre>
       *
       *The mandatory version of the MuSig2 BIP draft to use. This is necessary to
       *differentiate between the changes that were made to the BIP while this
       *experimental RPC was already released. Some of those changes affect how the
       *combined key and nonces are created.
       * </pre>
       *
       * <code>.signrpc.MuSig2Version version = 6;</code>
       * @return The enum numeric value on the wire for version.
       */
      @java.lang.Override public int getVersionValue() {
        return version_;
      }
      /**
       * <pre>
       *
       *The mandatory version of the MuSig2 BIP draft to use. This is necessary to
       *differentiate between the changes that were made to the BIP while this
       *experimental RPC was already released. Some of those changes affect how the
       *combined key and nonces are created.
       * </pre>
       *
       * <code>.signrpc.MuSig2Version version = 6;</code>
       * @param value The enum numeric value on the wire for version to set.
       * @return This builder for chaining.
       */
      public Builder setVersionValue(int value) {
        version_ = value;
        bitField0_ |= 0x00000020;
        onChanged();
        return this;
      }
      /**
       * <pre>
       *
       *The mandatory version of the MuSig2 BIP draft to use. This is necessary to
       *differentiate between the changes that were made to the BIP while this
       *experimental RPC was already released. Some of those changes affect how the
       *combined key and nonces are created.
       * </pre>
       *
       * <code>.signrpc.MuSig2Version version = 6;</code>
       * @return The version.
       */
      @java.lang.Override
      public signrpc.SignerOuterClass.MuSig2Version getVersion() {
        signrpc.SignerOuterClass.MuSig2Version result = signrpc.SignerOuterClass.MuSig2Version.forNumber(version_);
        return result == null ? signrpc.SignerOuterClass.MuSig2Version.UNRECOGNIZED : result;
      }
      /**
       * <pre>
       *
       *The mandatory version of the MuSig2 BIP draft to use. This is necessary to
       *differentiate between the changes that were made to the BIP while this
       *experimental RPC was already released. Some of those changes affect how the
       *combined key and nonces are created.
       * </pre>
       *
       * <code>.signrpc.MuSig2Version version = 6;</code>
       * @param value The version to set.
       * @return This builder for chaining.
       */
      public Builder setVersion(signrpc.SignerOuterClass.MuSig2Version value) {
        if (value == null) {
          throw new NullPointerException();
        }
        bitField0_ |= 0x00000020;
        version_ = value.getNumber();
        onChanged();
        return this;
      }
      /**
       * <pre>
       *
       *The mandatory version of the MuSig2 BIP draft to use. This is necessary to
       *differentiate between the changes that were made to the BIP while this
       *experimental RPC was already released. Some of those changes affect how the
       *combined key and nonces are created.
       * </pre>
       *
       * <code>.signrpc.MuSig2Version version = 6;</code>
       * @return This builder for chaining.
       */
      public Builder clearVersion() {
        bitField0_ = (bitField0_ & ~0x00000020);
        version_ = 0;
        onChanged();
        return this;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:signrpc.MuSig2SessionRequest)
    }

    // @@protoc_insertion_point(class_scope:signrpc.MuSig2SessionRequest)
    private static final signrpc.SignerOuterClass.MuSig2SessionRequest DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new signrpc.SignerOuterClass.MuSig2SessionRequest();
    }

    public static signrpc.SignerOuterClass.MuSig2SessionRequest getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<MuSig2SessionRequest>
        PARSER = new com.google.protobuf.AbstractParser<MuSig2SessionRequest>() {
      @java.lang.Override
      public MuSig2SessionRequest parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<MuSig2SessionRequest> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<MuSig2SessionRequest> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public signrpc.SignerOuterClass.MuSig2SessionRequest getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface MuSig2SessionResponseOrBuilder extends
      // @@protoc_insertion_point(interface_extends:signrpc.MuSig2SessionResponse)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     *
     *The unique ID that represents this signing session. A session can be used
     *for producing a signature a single time. If the signing fails for any
     *reason, a new session with the same participants needs to be created.
     * </pre>
     *
     * <code>bytes session_id = 1;</code>
     * @return The sessionId.
     */
    com.google.protobuf.ByteString getSessionId();

    /**
     * <pre>
     *
     *The combined public key (in the 32-byte x-only format) with all tweaks
     *applied to it. If a taproot tweak is specified, this corresponds to the
     *taproot key that can be put into the on-chain output.
     * </pre>
     *
     * <code>bytes combined_key = 2;</code>
     * @return The combinedKey.
     */
    com.google.protobuf.ByteString getCombinedKey();

    /**
     * <pre>
     *
     *The raw combined public key (in the 32-byte x-only format) before any tweaks
     *are applied to it. If a taproot tweak is specified, this corresponds to the
     *internal key that needs to be put into the witness if the script spend path
     *is used.
     * </pre>
     *
     * <code>bytes taproot_internal_key = 3;</code>
     * @return The taprootInternalKey.
     */
    com.google.protobuf.ByteString getTaprootInternalKey();

    /**
     * <pre>
     *
     *The two public nonces the local signer uses, combined into a single value
     *of 66 bytes. Can be split into the two 33-byte points to get the individual
     *nonces.
     * </pre>
     *
     * <code>bytes local_public_nonces = 4;</code>
     * @return The localPublicNonces.
     */
    com.google.protobuf.ByteString getLocalPublicNonces();

    /**
     * <pre>
     *
     *Indicates whether all nonces required to start the signing process are known
     *now.
     * </pre>
     *
     * <code>bool have_all_nonces = 5;</code>
     * @return The haveAllNonces.
     */
    boolean getHaveAllNonces();

    /**
     * <pre>
     *
     *The version of the MuSig2 BIP that was used to create the session.
     * </pre>
     *
     * <code>.signrpc.MuSig2Version version = 6;</code>
     * @return The enum numeric value on the wire for version.
     */
    int getVersionValue();
    /**
     * <pre>
     *
     *The version of the MuSig2 BIP that was used to create the session.
     * </pre>
     *
     * <code>.signrpc.MuSig2Version version = 6;</code>
     * @return The version.
     */
    signrpc.SignerOuterClass.MuSig2Version getVersion();
  }
  /**
   * Protobuf type {@code signrpc.MuSig2SessionResponse}
   */
  public static final class MuSig2SessionResponse extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:signrpc.MuSig2SessionResponse)
      MuSig2SessionResponseOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use MuSig2SessionResponse.newBuilder() to construct.
    private MuSig2SessionResponse(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private MuSig2SessionResponse() {
      sessionId_ = com.google.protobuf.ByteString.EMPTY;
      combinedKey_ = com.google.protobuf.ByteString.EMPTY;
      taprootInternalKey_ = com.google.protobuf.ByteString.EMPTY;
      localPublicNonces_ = com.google.protobuf.ByteString.EMPTY;
      version_ = 0;
    }

    @java.lang.Override
    @SuppressWarnings({"unused"})
    protected java.lang.Object newInstance(
        UnusedPrivateParameter unused) {
      return new MuSig2SessionResponse();
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return signrpc.SignerOuterClass.internal_static_signrpc_MuSig2SessionResponse_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return signrpc.SignerOuterClass.internal_static_signrpc_MuSig2SessionResponse_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              signrpc.SignerOuterClass.MuSig2SessionResponse.class, signrpc.SignerOuterClass.MuSig2SessionResponse.Builder.class);
    }

    public static final int SESSION_ID_FIELD_NUMBER = 1;
    private com.google.protobuf.ByteString sessionId_ = com.google.protobuf.ByteString.EMPTY;
    /**
     * <pre>
     *
     *The unique ID that represents this signing session. A session can be used
     *for producing a signature a single time. If the signing fails for any
     *reason, a new session with the same participants needs to be created.
     * </pre>
     *
     * <code>bytes session_id = 1;</code>
     * @return The sessionId.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString getSessionId() {
      return sessionId_;
    }

    public static final int COMBINED_KEY_FIELD_NUMBER = 2;
    private com.google.protobuf.ByteString combinedKey_ = com.google.protobuf.ByteString.EMPTY;
    /**
     * <pre>
     *
     *The combined public key (in the 32-byte x-only format) with all tweaks
     *applied to it. If a taproot tweak is specified, this corresponds to the
     *taproot key that can be put into the on-chain output.
     * </pre>
     *
     * <code>bytes combined_key = 2;</code>
     * @return The combinedKey.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString getCombinedKey() {
      return combinedKey_;
    }

    public static final int TAPROOT_INTERNAL_KEY_FIELD_NUMBER = 3;
    private com.google.protobuf.ByteString taprootInternalKey_ = com.google.protobuf.ByteString.EMPTY;
    /**
     * <pre>
     *
     *The raw combined public key (in the 32-byte x-only format) before any tweaks
     *are applied to it. If a taproot tweak is specified, this corresponds to the
     *internal key that needs to be put into the witness if the script spend path
     *is used.
     * </pre>
     *
     * <code>bytes taproot_internal_key = 3;</code>
     * @return The taprootInternalKey.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString getTaprootInternalKey() {
      return taprootInternalKey_;
    }

    public static final int LOCAL_PUBLIC_NONCES_FIELD_NUMBER = 4;
    private com.google.protobuf.ByteString localPublicNonces_ = com.google.protobuf.ByteString.EMPTY;
    /**
     * <pre>
     *
     *The two public nonces the local signer uses, combined into a single value
     *of 66 bytes. Can be split into the two 33-byte points to get the individual
     *nonces.
     * </pre>
     *
     * <code>bytes local_public_nonces = 4;</code>
     * @return The localPublicNonces.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString getLocalPublicNonces() {
      return localPublicNonces_;
    }

    public static final int HAVE_ALL_NONCES_FIELD_NUMBER = 5;
    private boolean haveAllNonces_ = false;
    /**
     * <pre>
     *
     *Indicates whether all nonces required to start the signing process are known
     *now.
     * </pre>
     *
     * <code>bool have_all_nonces = 5;</code>
     * @return The haveAllNonces.
     */
    @java.lang.Override
    public boolean getHaveAllNonces() {
      return haveAllNonces_;
    }

    public static final int VERSION_FIELD_NUMBER = 6;
    private int version_ = 0;
    /**
     * <pre>
     *
     *The version of the MuSig2 BIP that was used to create the session.
     * </pre>
     *
     * <code>.signrpc.MuSig2Version version = 6;</code>
     * @return The enum numeric value on the wire for version.
     */
    @java.lang.Override public int getVersionValue() {
      return version_;
    }
    /**
     * <pre>
     *
     *The version of the MuSig2 BIP that was used to create the session.
     * </pre>
     *
     * <code>.signrpc.MuSig2Version version = 6;</code>
     * @return The version.
     */
    @java.lang.Override public signrpc.SignerOuterClass.MuSig2Version getVersion() {
      signrpc.SignerOuterClass.MuSig2Version result = signrpc.SignerOuterClass.MuSig2Version.forNumber(version_);
      return result == null ? signrpc.SignerOuterClass.MuSig2Version.UNRECOGNIZED : result;
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (!sessionId_.isEmpty()) {
        output.writeBytes(1, sessionId_);
      }
      if (!combinedKey_.isEmpty()) {
        output.writeBytes(2, combinedKey_);
      }
      if (!taprootInternalKey_.isEmpty()) {
        output.writeBytes(3, taprootInternalKey_);
      }
      if (!localPublicNonces_.isEmpty()) {
        output.writeBytes(4, localPublicNonces_);
      }
      if (haveAllNonces_ != false) {
        output.writeBool(5, haveAllNonces_);
      }
      if (version_ != signrpc.SignerOuterClass.MuSig2Version.MUSIG2_VERSION_UNDEFINED.getNumber()) {
        output.writeEnum(6, version_);
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (!sessionId_.isEmpty()) {
        size += com.google.protobuf.CodedOutputStream
          .computeBytesSize(1, sessionId_);
      }
      if (!combinedKey_.isEmpty()) {
        size += com.google.protobuf.CodedOutputStream
          .computeBytesSize(2, combinedKey_);
      }
      if (!taprootInternalKey_.isEmpty()) {
        size += com.google.protobuf.CodedOutputStream
          .computeBytesSize(3, taprootInternalKey_);
      }
      if (!localPublicNonces_.isEmpty()) {
        size += com.google.protobuf.CodedOutputStream
          .computeBytesSize(4, localPublicNonces_);
      }
      if (haveAllNonces_ != false) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(5, haveAllNonces_);
      }
      if (version_ != signrpc.SignerOuterClass.MuSig2Version.MUSIG2_VERSION_UNDEFINED.getNumber()) {
        size += com.google.protobuf.CodedOutputStream
          .computeEnumSize(6, version_);
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof signrpc.SignerOuterClass.MuSig2SessionResponse)) {
        return super.equals(obj);
      }
      signrpc.SignerOuterClass.MuSig2SessionResponse other = (signrpc.SignerOuterClass.MuSig2SessionResponse) obj;

      if (!getSessionId()
          .equals(other.getSessionId())) return false;
      if (!getCombinedKey()
          .equals(other.getCombinedKey())) return false;
      if (!getTaprootInternalKey()
          .equals(other.getTaprootInternalKey())) return false;
      if (!getLocalPublicNonces()
          .equals(other.getLocalPublicNonces())) return false;
      if (getHaveAllNonces()
          != other.getHaveAllNonces()) return false;
      if (version_ != other.version_) return false;
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      hash = (37 * hash) + SESSION_ID_FIELD_NUMBER;
      hash = (53 * hash) + getSessionId().hashCode();
      hash = (37 * hash) + COMBINED_KEY_FIELD_NUMBER;
      hash = (53 * hash) + getCombinedKey().hashCode();
      hash = (37 * hash) + TAPROOT_INTERNAL_KEY_FIELD_NUMBER;
      hash = (53 * hash) + getTaprootInternalKey().hashCode();
      hash = (37 * hash) + LOCAL_PUBLIC_NONCES_FIELD_NUMBER;
      hash = (53 * hash) + getLocalPublicNonces().hashCode();
      hash = (37 * hash) + HAVE_ALL_NONCES_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
          getHaveAllNonces());
      hash = (37 * hash) + VERSION_FIELD_NUMBER;
      hash = (53 * hash) + version_;
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static signrpc.SignerOuterClass.MuSig2SessionResponse parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static signrpc.SignerOuterClass.MuSig2SessionResponse parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static signrpc.SignerOuterClass.MuSig2SessionResponse parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static signrpc.SignerOuterClass.MuSig2SessionResponse parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static signrpc.SignerOuterClass.MuSig2SessionResponse parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static signrpc.SignerOuterClass.MuSig2SessionResponse parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static signrpc.SignerOuterClass.MuSig2SessionResponse parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static signrpc.SignerOuterClass.MuSig2SessionResponse parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static signrpc.SignerOuterClass.MuSig2SessionResponse parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static signrpc.SignerOuterClass.MuSig2SessionResponse parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static signrpc.SignerOuterClass.MuSig2SessionResponse parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static signrpc.SignerOuterClass.MuSig2SessionResponse parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(signrpc.SignerOuterClass.MuSig2SessionResponse prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * Protobuf type {@code signrpc.MuSig2SessionResponse}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:signrpc.MuSig2SessionResponse)
        signrpc.SignerOuterClass.MuSig2SessionResponseOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return signrpc.SignerOuterClass.internal_static_signrpc_MuSig2SessionResponse_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return signrpc.SignerOuterClass.internal_static_signrpc_MuSig2SessionResponse_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                signrpc.SignerOuterClass.MuSig2SessionResponse.class, signrpc.SignerOuterClass.MuSig2SessionResponse.Builder.class);
      }

      // Construct using signrpc.SignerOuterClass.MuSig2SessionResponse.newBuilder()
      private Builder() {

      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);

      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        sessionId_ = com.google.protobuf.ByteString.EMPTY;
        combinedKey_ = com.google.protobuf.ByteString.EMPTY;
        taprootInternalKey_ = com.google.protobuf.ByteString.EMPTY;
        localPublicNonces_ = com.google.protobuf.ByteString.EMPTY;
        haveAllNonces_ = false;
        version_ = 0;
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return signrpc.SignerOuterClass.internal_static_signrpc_MuSig2SessionResponse_descriptor;
      }

      @java.lang.Override
      public signrpc.SignerOuterClass.MuSig2SessionResponse getDefaultInstanceForType() {
        return signrpc.SignerOuterClass.MuSig2SessionResponse.getDefaultInstance();
      }

      @java.lang.Override
      public signrpc.SignerOuterClass.MuSig2SessionResponse build() {
        signrpc.SignerOuterClass.MuSig2SessionResponse result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public signrpc.SignerOuterClass.MuSig2SessionResponse buildPartial() {
        signrpc.SignerOuterClass.MuSig2SessionResponse result = new signrpc.SignerOuterClass.MuSig2SessionResponse(this);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartial0(signrpc.SignerOuterClass.MuSig2SessionResponse result) {
        int from_bitField0_ = bitField0_;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.sessionId_ = sessionId_;
        }
        if (((from_bitField0_ & 0x00000002) != 0)) {
          result.combinedKey_ = combinedKey_;
        }
        if (((from_bitField0_ & 0x00000004) != 0)) {
          result.taprootInternalKey_ = taprootInternalKey_;
        }
        if (((from_bitField0_ & 0x00000008) != 0)) {
          result.localPublicNonces_ = localPublicNonces_;
        }
        if (((from_bitField0_ & 0x00000010) != 0)) {
          result.haveAllNonces_ = haveAllNonces_;
        }
        if (((from_bitField0_ & 0x00000020) != 0)) {
          result.version_ = version_;
        }
      }

      @java.lang.Override
      public Builder clone() {
        return super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof signrpc.SignerOuterClass.MuSig2SessionResponse) {
          return mergeFrom((signrpc.SignerOuterClass.MuSig2SessionResponse)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(signrpc.SignerOuterClass.MuSig2SessionResponse other) {
        if (other == signrpc.SignerOuterClass.MuSig2SessionResponse.getDefaultInstance()) return this;
        if (other.getSessionId() != com.google.protobuf.ByteString.EMPTY) {
          setSessionId(other.getSessionId());
        }
        if (other.getCombinedKey() != com.google.protobuf.ByteString.EMPTY) {
          setCombinedKey(other.getCombinedKey());
        }
        if (other.getTaprootInternalKey() != com.google.protobuf.ByteString.EMPTY) {
          setTaprootInternalKey(other.getTaprootInternalKey());
        }
        if (other.getLocalPublicNonces() != com.google.protobuf.ByteString.EMPTY) {
          setLocalPublicNonces(other.getLocalPublicNonces());
        }
        if (other.getHaveAllNonces() != false) {
          setHaveAllNonces(other.getHaveAllNonces());
        }
        if (other.version_ != 0) {
          setVersionValue(other.getVersionValue());
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10: {
                sessionId_ = input.readBytes();
                bitField0_ |= 0x00000001;
                break;
              } // case 10
              case 18: {
                combinedKey_ = input.readBytes();
                bitField0_ |= 0x00000002;
                break;
              } // case 18
              case 26: {
                taprootInternalKey_ = input.readBytes();
                bitField0_ |= 0x00000004;
                break;
              } // case 26
              case 34: {
                localPublicNonces_ = input.readBytes();
                bitField0_ |= 0x00000008;
                break;
              } // case 34
              case 40: {
                haveAllNonces_ = input.readBool();
                bitField0_ |= 0x00000010;
                break;
              } // case 40
              case 48: {
                version_ = input.readEnum();
                bitField0_ |= 0x00000020;
                break;
              } // case 48
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private com.google.protobuf.ByteString sessionId_ = com.google.protobuf.ByteString.EMPTY;
      /**
       * <pre>
       *
       *The unique ID that represents this signing session. A session can be used
       *for producing a signature a single time. If the signing fails for any
       *reason, a new session with the same participants needs to be created.
       * </pre>
       *
       * <code>bytes session_id = 1;</code>
       * @return The sessionId.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString getSessionId() {
        return sessionId_;
      }
      /**
       * <pre>
       *
       *The unique ID that represents this signing session. A session can be used
       *for producing a signature a single time. If the signing fails for any
       *reason, a new session with the same participants needs to be created.
       * </pre>
       *
       * <code>bytes session_id = 1;</code>
       * @param value The sessionId to set.
       * @return This builder for chaining.
       */
      public Builder setSessionId(com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        sessionId_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       *
       *The unique ID that represents this signing session. A session can be used
       *for producing a signature a single time. If the signing fails for any
       *reason, a new session with the same participants needs to be created.
       * </pre>
       *
       * <code>bytes session_id = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearSessionId() {
        bitField0_ = (bitField0_ & ~0x00000001);
        sessionId_ = getDefaultInstance().getSessionId();
        onChanged();
        return this;
      }

      private com.google.protobuf.ByteString combinedKey_ = com.google.protobuf.ByteString.EMPTY;
      /**
       * <pre>
       *
       *The combined public key (in the 32-byte x-only format) with all tweaks
       *applied to it. If a taproot tweak is specified, this corresponds to the
       *taproot key that can be put into the on-chain output.
       * </pre>
       *
       * <code>bytes combined_key = 2;</code>
       * @return The combinedKey.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString getCombinedKey() {
        return combinedKey_;
      }
      /**
       * <pre>
       *
       *The combined public key (in the 32-byte x-only format) with all tweaks
       *applied to it. If a taproot tweak is specified, this corresponds to the
       *taproot key that can be put into the on-chain output.
       * </pre>
       *
       * <code>bytes combined_key = 2;</code>
       * @param value The combinedKey to set.
       * @return This builder for chaining.
       */
      public Builder setCombinedKey(com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        combinedKey_ = value;
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       *
       *The combined public key (in the 32-byte x-only format) with all tweaks
       *applied to it. If a taproot tweak is specified, this corresponds to the
       *taproot key that can be put into the on-chain output.
       * </pre>
       *
       * <code>bytes combined_key = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearCombinedKey() {
        bitField0_ = (bitField0_ & ~0x00000002);
        combinedKey_ = getDefaultInstance().getCombinedKey();
        onChanged();
        return this;
      }

      private com.google.protobuf.ByteString taprootInternalKey_ = com.google.protobuf.ByteString.EMPTY;
      /**
       * <pre>
       *
       *The raw combined public key (in the 32-byte x-only format) before any tweaks
       *are applied to it. If a taproot tweak is specified, this corresponds to the
       *internal key that needs to be put into the witness if the script spend path
       *is used.
       * </pre>
       *
       * <code>bytes taproot_internal_key = 3;</code>
       * @return The taprootInternalKey.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString getTaprootInternalKey() {
        return taprootInternalKey_;
      }
      /**
       * <pre>
       *
       *The raw combined public key (in the 32-byte x-only format) before any tweaks
       *are applied to it. If a taproot tweak is specified, this corresponds to the
       *internal key that needs to be put into the witness if the script spend path
       *is used.
       * </pre>
       *
       * <code>bytes taproot_internal_key = 3;</code>
       * @param value The taprootInternalKey to set.
       * @return This builder for chaining.
       */
      public Builder setTaprootInternalKey(com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        taprootInternalKey_ = value;
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }
      /**
       * <pre>
       *
       *The raw combined public key (in the 32-byte x-only format) before any tweaks
       *are applied to it. If a taproot tweak is specified, this corresponds to the
       *internal key that needs to be put into the witness if the script spend path
       *is used.
       * </pre>
       *
       * <code>bytes taproot_internal_key = 3;</code>
       * @return This builder for chaining.
       */
      public Builder clearTaprootInternalKey() {
        bitField0_ = (bitField0_ & ~0x00000004);
        taprootInternalKey_ = getDefaultInstance().getTaprootInternalKey();
        onChanged();
        return this;
      }

      private com.google.protobuf.ByteString localPublicNonces_ = com.google.protobuf.ByteString.EMPTY;
      /**
       * <pre>
       *
       *The two public nonces the local signer uses, combined into a single value
       *of 66 bytes. Can be split into the two 33-byte points to get the individual
       *nonces.
       * </pre>
       *
       * <code>bytes local_public_nonces = 4;</code>
       * @return The localPublicNonces.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString getLocalPublicNonces() {
        return localPublicNonces_;
      }
      /**
       * <pre>
       *
       *The two public nonces the local signer uses, combined into a single value
       *of 66 bytes. Can be split into the two 33-byte points to get the individual
       *nonces.
       * </pre>
       *
       * <code>bytes local_public_nonces = 4;</code>
       * @param value The localPublicNonces to set.
       * @return This builder for chaining.
       */
      public Builder setLocalPublicNonces(com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        localPublicNonces_ = value;
        bitField0_ |= 0x00000008;
        onChanged();
        return this;
      }
      /**
       * <pre>
       *
       *The two public nonces the local signer uses, combined into a single value
       *of 66 bytes. Can be split into the two 33-byte points to get the individual
       *nonces.
       * </pre>
       *
       * <code>bytes local_public_nonces = 4;</code>
       * @return This builder for chaining.
       */
      public Builder clearLocalPublicNonces() {
        bitField0_ = (bitField0_ & ~0x00000008);
        localPublicNonces_ = getDefaultInstance().getLocalPublicNonces();
        onChanged();
        return this;
      }

      private boolean haveAllNonces_ ;
      /**
       * <pre>
       *
       *Indicates whether all nonces required to start the signing process are known
       *now.
       * </pre>
       *
       * <code>bool have_all_nonces = 5;</code>
       * @return The haveAllNonces.
       */
      @java.lang.Override
      public boolean getHaveAllNonces() {
        return haveAllNonces_;
      }
      /**
       * <pre>
       *
       *Indicates whether all nonces required to start the signing process are known
       *now.
       * </pre>
       *
       * <code>bool have_all_nonces = 5;</code>
       * @param value The haveAllNonces to set.
       * @return This builder for chaining.
       */
      public Builder setHaveAllNonces(boolean value) {

        haveAllNonces_ = value;
        bitField0_ |= 0x00000010;
        onChanged();
        return this;
      }
      /**
       * <pre>
       *
       *Indicates whether all nonces required to start the signing process are known
       *now.
       * </pre>
       *
       * <code>bool have_all_nonces = 5;</code>
       * @return This builder for chaining.
       */
      public Builder clearHaveAllNonces() {
        bitField0_ = (bitField0_ & ~0x00000010);
        haveAllNonces_ = false;
        onChanged();
        return this;
      }

      private int version_ = 0;
      /**
       * <pre>
       *
       *The version of the MuSig2 BIP that was used to create the session.
       * </pre>
       *
       * <code>.signrpc.MuSig2Version version = 6;</code>
       * @return The enum numeric value on the wire for version.
       */
      @java.lang.Override public int getVersionValue() {
        return version_;
      }
      /**
       * <pre>
       *
       *The version of the MuSig2 BIP that was used to create the session.
       * </pre>
       *
       * <code>.signrpc.MuSig2Version version = 6;</code>
       * @param value The enum numeric value on the wire for version to set.
       * @return This builder for chaining.
       */
      public Builder setVersionValue(int value) {
        version_ = value;
        bitField0_ |= 0x00000020;
        onChanged();
        return this;
      }
      /**
       * <pre>
       *
       *The version of the MuSig2 BIP that was used to create the session.
       * </pre>
       *
       * <code>.signrpc.MuSig2Version version = 6;</code>
       * @return The version.
       */
      @java.lang.Override
      public signrpc.SignerOuterClass.MuSig2Version getVersion() {
        signrpc.SignerOuterClass.MuSig2Version result = signrpc.SignerOuterClass.MuSig2Version.forNumber(version_);
        return result == null ? signrpc.SignerOuterClass.MuSig2Version.UNRECOGNIZED : result;
      }
      /**
       * <pre>
       *
       *The version of the MuSig2 BIP that was used to create the session.
       * </pre>
       *
       * <code>.signrpc.MuSig2Version version = 6;</code>
       * @param value The version to set.
       * @return This builder for chaining.
       */
      public Builder setVersion(signrpc.SignerOuterClass.MuSig2Version value) {
        if (value == null) {
          throw new NullPointerException();
        }
        bitField0_ |= 0x00000020;
        version_ = value.getNumber();
        onChanged();
        return this;
      }
      /**
       * <pre>
       *
       *The version of the MuSig2 BIP that was used to create the session.
       * </pre>
       *
       * <code>.signrpc.MuSig2Version version = 6;</code>
       * @return This builder for chaining.
       */
      public Builder clearVersion() {
        bitField0_ = (bitField0_ & ~0x00000020);
        version_ = 0;
        onChanged();
        return this;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:signrpc.MuSig2SessionResponse)
    }

    // @@protoc_insertion_point(class_scope:signrpc.MuSig2SessionResponse)
    private static final signrpc.SignerOuterClass.MuSig2SessionResponse DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new signrpc.SignerOuterClass.MuSig2SessionResponse();
    }

    public static signrpc.SignerOuterClass.MuSig2SessionResponse getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<MuSig2SessionResponse>
        PARSER = new com.google.protobuf.AbstractParser<MuSig2SessionResponse>() {
      @java.lang.Override
      public MuSig2SessionResponse parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<MuSig2SessionResponse> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<MuSig2SessionResponse> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public signrpc.SignerOuterClass.MuSig2SessionResponse getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface MuSig2RegisterNoncesRequestOrBuilder extends
      // @@protoc_insertion_point(interface_extends:signrpc.MuSig2RegisterNoncesRequest)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     *
     *The unique ID of the signing session those nonces should be registered with.
     * </pre>
     *
     * <code>bytes session_id = 1;</code>
     * @return The sessionId.
     */
    com.google.protobuf.ByteString getSessionId();

    /**
     * <pre>
     *
     *A list of all public nonces of other signing participants that should be
     *registered.
     * </pre>
     *
     * <code>repeated bytes other_signer_public_nonces = 3;</code>
     * @return A list containing the otherSignerPublicNonces.
     */
    java.util.List<com.google.protobuf.ByteString> getOtherSignerPublicNoncesList();
    /**
     * <pre>
     *
     *A list of all public nonces of other signing participants that should be
     *registered.
     * </pre>
     *
     * <code>repeated bytes other_signer_public_nonces = 3;</code>
     * @return The count of otherSignerPublicNonces.
     */
    int getOtherSignerPublicNoncesCount();
    /**
     * <pre>
     *
     *A list of all public nonces of other signing participants that should be
     *registered.
     * </pre>
     *
     * <code>repeated bytes other_signer_public_nonces = 3;</code>
     * @param index The index of the element to return.
     * @return The otherSignerPublicNonces at the given index.
     */
    com.google.protobuf.ByteString getOtherSignerPublicNonces(int index);
  }
  /**
   * Protobuf type {@code signrpc.MuSig2RegisterNoncesRequest}
   */
  public static final class MuSig2RegisterNoncesRequest extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:signrpc.MuSig2RegisterNoncesRequest)
      MuSig2RegisterNoncesRequestOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use MuSig2RegisterNoncesRequest.newBuilder() to construct.
    private MuSig2RegisterNoncesRequest(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private MuSig2RegisterNoncesRequest() {
      sessionId_ = com.google.protobuf.ByteString.EMPTY;
      otherSignerPublicNonces_ = emptyList(com.google.protobuf.ByteString.class);
    }

    @java.lang.Override
    @SuppressWarnings({"unused"})
    protected java.lang.Object newInstance(
        UnusedPrivateParameter unused) {
      return new MuSig2RegisterNoncesRequest();
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return signrpc.SignerOuterClass.internal_static_signrpc_MuSig2RegisterNoncesRequest_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return signrpc.SignerOuterClass.internal_static_signrpc_MuSig2RegisterNoncesRequest_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              signrpc.SignerOuterClass.MuSig2RegisterNoncesRequest.class, signrpc.SignerOuterClass.MuSig2RegisterNoncesRequest.Builder.class);
    }

    public static final int SESSION_ID_FIELD_NUMBER = 1;
    private com.google.protobuf.ByteString sessionId_ = com.google.protobuf.ByteString.EMPTY;
    /**
     * <pre>
     *
     *The unique ID of the signing session those nonces should be registered with.
     * </pre>
     *
     * <code>bytes session_id = 1;</code>
     * @return The sessionId.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString getSessionId() {
      return sessionId_;
    }

    public static final int OTHER_SIGNER_PUBLIC_NONCES_FIELD_NUMBER = 3;
    @SuppressWarnings("serial")
    private com.google.protobuf.Internal.ProtobufList<com.google.protobuf.ByteString> otherSignerPublicNonces_ =
        emptyList(com.google.protobuf.ByteString.class);
    /**
     * <pre>
     *
     *A list of all public nonces of other signing participants that should be
     *registered.
     * </pre>
     *
     * <code>repeated bytes other_signer_public_nonces = 3;</code>
     * @return A list containing the otherSignerPublicNonces.
     */
    @java.lang.Override
    public java.util.List<com.google.protobuf.ByteString>
        getOtherSignerPublicNoncesList() {
      return otherSignerPublicNonces_;
    }
    /**
     * <pre>
     *
     *A list of all public nonces of other signing participants that should be
     *registered.
     * </pre>
     *
     * <code>repeated bytes other_signer_public_nonces = 3;</code>
     * @return The count of otherSignerPublicNonces.
     */
    public int getOtherSignerPublicNoncesCount() {
      return otherSignerPublicNonces_.size();
    }
    /**
     * <pre>
     *
     *A list of all public nonces of other signing participants that should be
     *registered.
     * </pre>
     *
     * <code>repeated bytes other_signer_public_nonces = 3;</code>
     * @param index The index of the element to return.
     * @return The otherSignerPublicNonces at the given index.
     */
    public com.google.protobuf.ByteString getOtherSignerPublicNonces(int index) {
      return otherSignerPublicNonces_.get(index);
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (!sessionId_.isEmpty()) {
        output.writeBytes(1, sessionId_);
      }
      for (int i = 0; i < otherSignerPublicNonces_.size(); i++) {
        output.writeBytes(3, otherSignerPublicNonces_.get(i));
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (!sessionId_.isEmpty()) {
        size += com.google.protobuf.CodedOutputStream
          .computeBytesSize(1, sessionId_);
      }
      {
        int dataSize = 0;
        for (int i = 0; i < otherSignerPublicNonces_.size(); i++) {
          dataSize += com.google.protobuf.CodedOutputStream
            .computeBytesSizeNoTag(otherSignerPublicNonces_.get(i));
        }
        size += dataSize;
        size += 1 * getOtherSignerPublicNoncesList().size();
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof signrpc.SignerOuterClass.MuSig2RegisterNoncesRequest)) {
        return super.equals(obj);
      }
      signrpc.SignerOuterClass.MuSig2RegisterNoncesRequest other = (signrpc.SignerOuterClass.MuSig2RegisterNoncesRequest) obj;

      if (!getSessionId()
          .equals(other.getSessionId())) return false;
      if (!getOtherSignerPublicNoncesList()
          .equals(other.getOtherSignerPublicNoncesList())) return false;
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      hash = (37 * hash) + SESSION_ID_FIELD_NUMBER;
      hash = (53 * hash) + getSessionId().hashCode();
      if (getOtherSignerPublicNoncesCount() > 0) {
        hash = (37 * hash) + OTHER_SIGNER_PUBLIC_NONCES_FIELD_NUMBER;
        hash = (53 * hash) + getOtherSignerPublicNoncesList().hashCode();
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static signrpc.SignerOuterClass.MuSig2RegisterNoncesRequest parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static signrpc.SignerOuterClass.MuSig2RegisterNoncesRequest parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static signrpc.SignerOuterClass.MuSig2RegisterNoncesRequest parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static signrpc.SignerOuterClass.MuSig2RegisterNoncesRequest parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static signrpc.SignerOuterClass.MuSig2RegisterNoncesRequest parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static signrpc.SignerOuterClass.MuSig2RegisterNoncesRequest parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static signrpc.SignerOuterClass.MuSig2RegisterNoncesRequest parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static signrpc.SignerOuterClass.MuSig2RegisterNoncesRequest parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static signrpc.SignerOuterClass.MuSig2RegisterNoncesRequest parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static signrpc.SignerOuterClass.MuSig2RegisterNoncesRequest parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static signrpc.SignerOuterClass.MuSig2RegisterNoncesRequest parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static signrpc.SignerOuterClass.MuSig2RegisterNoncesRequest parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(signrpc.SignerOuterClass.MuSig2RegisterNoncesRequest prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * Protobuf type {@code signrpc.MuSig2RegisterNoncesRequest}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:signrpc.MuSig2RegisterNoncesRequest)
        signrpc.SignerOuterClass.MuSig2RegisterNoncesRequestOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return signrpc.SignerOuterClass.internal_static_signrpc_MuSig2RegisterNoncesRequest_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return signrpc.SignerOuterClass.internal_static_signrpc_MuSig2RegisterNoncesRequest_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                signrpc.SignerOuterClass.MuSig2RegisterNoncesRequest.class, signrpc.SignerOuterClass.MuSig2RegisterNoncesRequest.Builder.class);
      }

      // Construct using signrpc.SignerOuterClass.MuSig2RegisterNoncesRequest.newBuilder()
      private Builder() {

      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);

      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        sessionId_ = com.google.protobuf.ByteString.EMPTY;
        otherSignerPublicNonces_ = emptyList(com.google.protobuf.ByteString.class);
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return signrpc.SignerOuterClass.internal_static_signrpc_MuSig2RegisterNoncesRequest_descriptor;
      }

      @java.lang.Override
      public signrpc.SignerOuterClass.MuSig2RegisterNoncesRequest getDefaultInstanceForType() {
        return signrpc.SignerOuterClass.MuSig2RegisterNoncesRequest.getDefaultInstance();
      }

      @java.lang.Override
      public signrpc.SignerOuterClass.MuSig2RegisterNoncesRequest build() {
        signrpc.SignerOuterClass.MuSig2RegisterNoncesRequest result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public signrpc.SignerOuterClass.MuSig2RegisterNoncesRequest buildPartial() {
        signrpc.SignerOuterClass.MuSig2RegisterNoncesRequest result = new signrpc.SignerOuterClass.MuSig2RegisterNoncesRequest(this);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartial0(signrpc.SignerOuterClass.MuSig2RegisterNoncesRequest result) {
        int from_bitField0_ = bitField0_;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.sessionId_ = sessionId_;
        }
        if (((from_bitField0_ & 0x00000002) != 0)) {
          otherSignerPublicNonces_.makeImmutable();
          result.otherSignerPublicNonces_ = otherSignerPublicNonces_;
        }
      }

      @java.lang.Override
      public Builder clone() {
        return super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof signrpc.SignerOuterClass.MuSig2RegisterNoncesRequest) {
          return mergeFrom((signrpc.SignerOuterClass.MuSig2RegisterNoncesRequest)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(signrpc.SignerOuterClass.MuSig2RegisterNoncesRequest other) {
        if (other == signrpc.SignerOuterClass.MuSig2RegisterNoncesRequest.getDefaultInstance()) return this;
        if (other.getSessionId() != com.google.protobuf.ByteString.EMPTY) {
          setSessionId(other.getSessionId());
        }
        if (!other.otherSignerPublicNonces_.isEmpty()) {
          if (otherSignerPublicNonces_.isEmpty()) {
            otherSignerPublicNonces_ = other.otherSignerPublicNonces_;
            otherSignerPublicNonces_.makeImmutable();
            bitField0_ |= 0x00000002;
          } else {
            ensureOtherSignerPublicNoncesIsMutable();
            otherSignerPublicNonces_.addAll(other.otherSignerPublicNonces_);
          }
          onChanged();
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10: {
                sessionId_ = input.readBytes();
                bitField0_ |= 0x00000001;
                break;
              } // case 10
              case 26: {
                com.google.protobuf.ByteString v = input.readBytes();
                ensureOtherSignerPublicNoncesIsMutable();
                otherSignerPublicNonces_.add(v);
                break;
              } // case 26
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private com.google.protobuf.ByteString sessionId_ = com.google.protobuf.ByteString.EMPTY;
      /**
       * <pre>
       *
       *The unique ID of the signing session those nonces should be registered with.
       * </pre>
       *
       * <code>bytes session_id = 1;</code>
       * @return The sessionId.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString getSessionId() {
        return sessionId_;
      }
      /**
       * <pre>
       *
       *The unique ID of the signing session those nonces should be registered with.
       * </pre>
       *
       * <code>bytes session_id = 1;</code>
       * @param value The sessionId to set.
       * @return This builder for chaining.
       */
      public Builder setSessionId(com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        sessionId_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       *
       *The unique ID of the signing session those nonces should be registered with.
       * </pre>
       *
       * <code>bytes session_id = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearSessionId() {
        bitField0_ = (bitField0_ & ~0x00000001);
        sessionId_ = getDefaultInstance().getSessionId();
        onChanged();
        return this;
      }

      private com.google.protobuf.Internal.ProtobufList<com.google.protobuf.ByteString> otherSignerPublicNonces_ = emptyList(com.google.protobuf.ByteString.class);
      private void ensureOtherSignerPublicNoncesIsMutable() {
        if (!otherSignerPublicNonces_.isModifiable()) {
          otherSignerPublicNonces_ = makeMutableCopy(otherSignerPublicNonces_);
        }
        bitField0_ |= 0x00000002;
      }
      /**
       * <pre>
       *
       *A list of all public nonces of other signing participants that should be
       *registered.
       * </pre>
       *
       * <code>repeated bytes other_signer_public_nonces = 3;</code>
       * @return A list containing the otherSignerPublicNonces.
       */
      public java.util.List<com.google.protobuf.ByteString>
          getOtherSignerPublicNoncesList() {
        otherSignerPublicNonces_.makeImmutable();
        return otherSignerPublicNonces_;
      }
      /**
       * <pre>
       *
       *A list of all public nonces of other signing participants that should be
       *registered.
       * </pre>
       *
       * <code>repeated bytes other_signer_public_nonces = 3;</code>
       * @return The count of otherSignerPublicNonces.
       */
      public int getOtherSignerPublicNoncesCount() {
        return otherSignerPublicNonces_.size();
      }
      /**
       * <pre>
       *
       *A list of all public nonces of other signing participants that should be
       *registered.
       * </pre>
       *
       * <code>repeated bytes other_signer_public_nonces = 3;</code>
       * @param index The index of the element to return.
       * @return The otherSignerPublicNonces at the given index.
       */
      public com.google.protobuf.ByteString getOtherSignerPublicNonces(int index) {
        return otherSignerPublicNonces_.get(index);
      }
      /**
       * <pre>
       *
       *A list of all public nonces of other signing participants that should be
       *registered.
       * </pre>
       *
       * <code>repeated bytes other_signer_public_nonces = 3;</code>
       * @param index The index to set the value at.
       * @param value The otherSignerPublicNonces to set.
       * @return This builder for chaining.
       */
      public Builder setOtherSignerPublicNonces(
          int index, com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        ensureOtherSignerPublicNoncesIsMutable();
        otherSignerPublicNonces_.set(index, value);
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       *
       *A list of all public nonces of other signing participants that should be
       *registered.
       * </pre>
       *
       * <code>repeated bytes other_signer_public_nonces = 3;</code>
       * @param value The otherSignerPublicNonces to add.
       * @return This builder for chaining.
       */
      public Builder addOtherSignerPublicNonces(com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        ensureOtherSignerPublicNoncesIsMutable();
        otherSignerPublicNonces_.add(value);
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       *
       *A list of all public nonces of other signing participants that should be
       *registered.
       * </pre>
       *
       * <code>repeated bytes other_signer_public_nonces = 3;</code>
       * @param values The otherSignerPublicNonces to add.
       * @return This builder for chaining.
       */
      public Builder addAllOtherSignerPublicNonces(
          java.lang.Iterable<? extends com.google.protobuf.ByteString> values) {
        ensureOtherSignerPublicNoncesIsMutable();
        com.google.protobuf.AbstractMessageLite.Builder.addAll(
            values, otherSignerPublicNonces_);
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       *
       *A list of all public nonces of other signing participants that should be
       *registered.
       * </pre>
       *
       * <code>repeated bytes other_signer_public_nonces = 3;</code>
       * @return This builder for chaining.
       */
      public Builder clearOtherSignerPublicNonces() {
        otherSignerPublicNonces_ = emptyList(com.google.protobuf.ByteString.class);
        bitField0_ = (bitField0_ & ~0x00000002);
        onChanged();
        return this;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:signrpc.MuSig2RegisterNoncesRequest)
    }

    // @@protoc_insertion_point(class_scope:signrpc.MuSig2RegisterNoncesRequest)
    private static final signrpc.SignerOuterClass.MuSig2RegisterNoncesRequest DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new signrpc.SignerOuterClass.MuSig2RegisterNoncesRequest();
    }

    public static signrpc.SignerOuterClass.MuSig2RegisterNoncesRequest getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<MuSig2RegisterNoncesRequest>
        PARSER = new com.google.protobuf.AbstractParser<MuSig2RegisterNoncesRequest>() {
      @java.lang.Override
      public MuSig2RegisterNoncesRequest parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<MuSig2RegisterNoncesRequest> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<MuSig2RegisterNoncesRequest> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public signrpc.SignerOuterClass.MuSig2RegisterNoncesRequest getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface MuSig2RegisterNoncesResponseOrBuilder extends
      // @@protoc_insertion_point(interface_extends:signrpc.MuSig2RegisterNoncesResponse)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     *
     *Indicates whether all nonces required to start the signing process are known
     *now.
     * </pre>
     *
     * <code>bool have_all_nonces = 1;</code>
     * @return The haveAllNonces.
     */
    boolean getHaveAllNonces();
  }
  /**
   * Protobuf type {@code signrpc.MuSig2RegisterNoncesResponse}
   */
  public static final class MuSig2RegisterNoncesResponse extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:signrpc.MuSig2RegisterNoncesResponse)
      MuSig2RegisterNoncesResponseOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use MuSig2RegisterNoncesResponse.newBuilder() to construct.
    private MuSig2RegisterNoncesResponse(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private MuSig2RegisterNoncesResponse() {
    }

    @java.lang.Override
    @SuppressWarnings({"unused"})
    protected java.lang.Object newInstance(
        UnusedPrivateParameter unused) {
      return new MuSig2RegisterNoncesResponse();
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return signrpc.SignerOuterClass.internal_static_signrpc_MuSig2RegisterNoncesResponse_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return signrpc.SignerOuterClass.internal_static_signrpc_MuSig2RegisterNoncesResponse_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              signrpc.SignerOuterClass.MuSig2RegisterNoncesResponse.class, signrpc.SignerOuterClass.MuSig2RegisterNoncesResponse.Builder.class);
    }

    public static final int HAVE_ALL_NONCES_FIELD_NUMBER = 1;
    private boolean haveAllNonces_ = false;
    /**
     * <pre>
     *
     *Indicates whether all nonces required to start the signing process are known
     *now.
     * </pre>
     *
     * <code>bool have_all_nonces = 1;</code>
     * @return The haveAllNonces.
     */
    @java.lang.Override
    public boolean getHaveAllNonces() {
      return haveAllNonces_;
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (haveAllNonces_ != false) {
        output.writeBool(1, haveAllNonces_);
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (haveAllNonces_ != false) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(1, haveAllNonces_);
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof signrpc.SignerOuterClass.MuSig2RegisterNoncesResponse)) {
        return super.equals(obj);
      }
      signrpc.SignerOuterClass.MuSig2RegisterNoncesResponse other = (signrpc.SignerOuterClass.MuSig2RegisterNoncesResponse) obj;

      if (getHaveAllNonces()
          != other.getHaveAllNonces()) return false;
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      hash = (37 * hash) + HAVE_ALL_NONCES_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
          getHaveAllNonces());
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static signrpc.SignerOuterClass.MuSig2RegisterNoncesResponse parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static signrpc.SignerOuterClass.MuSig2RegisterNoncesResponse parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static signrpc.SignerOuterClass.MuSig2RegisterNoncesResponse parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static signrpc.SignerOuterClass.MuSig2RegisterNoncesResponse parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static signrpc.SignerOuterClass.MuSig2RegisterNoncesResponse parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static signrpc.SignerOuterClass.MuSig2RegisterNoncesResponse parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static signrpc.SignerOuterClass.MuSig2RegisterNoncesResponse parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static signrpc.SignerOuterClass.MuSig2RegisterNoncesResponse parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static signrpc.SignerOuterClass.MuSig2RegisterNoncesResponse parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static signrpc.SignerOuterClass.MuSig2RegisterNoncesResponse parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static signrpc.SignerOuterClass.MuSig2RegisterNoncesResponse parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static signrpc.SignerOuterClass.MuSig2RegisterNoncesResponse parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(signrpc.SignerOuterClass.MuSig2RegisterNoncesResponse prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * Protobuf type {@code signrpc.MuSig2RegisterNoncesResponse}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:signrpc.MuSig2RegisterNoncesResponse)
        signrpc.SignerOuterClass.MuSig2RegisterNoncesResponseOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return signrpc.SignerOuterClass.internal_static_signrpc_MuSig2RegisterNoncesResponse_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return signrpc.SignerOuterClass.internal_static_signrpc_MuSig2RegisterNoncesResponse_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                signrpc.SignerOuterClass.MuSig2RegisterNoncesResponse.class, signrpc.SignerOuterClass.MuSig2RegisterNoncesResponse.Builder.class);
      }

      // Construct using signrpc.SignerOuterClass.MuSig2RegisterNoncesResponse.newBuilder()
      private Builder() {

      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);

      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        haveAllNonces_ = false;
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return signrpc.SignerOuterClass.internal_static_signrpc_MuSig2RegisterNoncesResponse_descriptor;
      }

      @java.lang.Override
      public signrpc.SignerOuterClass.MuSig2RegisterNoncesResponse getDefaultInstanceForType() {
        return signrpc.SignerOuterClass.MuSig2RegisterNoncesResponse.getDefaultInstance();
      }

      @java.lang.Override
      public signrpc.SignerOuterClass.MuSig2RegisterNoncesResponse build() {
        signrpc.SignerOuterClass.MuSig2RegisterNoncesResponse result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public signrpc.SignerOuterClass.MuSig2RegisterNoncesResponse buildPartial() {
        signrpc.SignerOuterClass.MuSig2RegisterNoncesResponse result = new signrpc.SignerOuterClass.MuSig2RegisterNoncesResponse(this);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartial0(signrpc.SignerOuterClass.MuSig2RegisterNoncesResponse result) {
        int from_bitField0_ = bitField0_;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.haveAllNonces_ = haveAllNonces_;
        }
      }

      @java.lang.Override
      public Builder clone() {
        return super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof signrpc.SignerOuterClass.MuSig2RegisterNoncesResponse) {
          return mergeFrom((signrpc.SignerOuterClass.MuSig2RegisterNoncesResponse)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(signrpc.SignerOuterClass.MuSig2RegisterNoncesResponse other) {
        if (other == signrpc.SignerOuterClass.MuSig2RegisterNoncesResponse.getDefaultInstance()) return this;
        if (other.getHaveAllNonces() != false) {
          setHaveAllNonces(other.getHaveAllNonces());
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 8: {
                haveAllNonces_ = input.readBool();
                bitField0_ |= 0x00000001;
                break;
              } // case 8
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private boolean haveAllNonces_ ;
      /**
       * <pre>
       *
       *Indicates whether all nonces required to start the signing process are known
       *now.
       * </pre>
       *
       * <code>bool have_all_nonces = 1;</code>
       * @return The haveAllNonces.
       */
      @java.lang.Override
      public boolean getHaveAllNonces() {
        return haveAllNonces_;
      }
      /**
       * <pre>
       *
       *Indicates whether all nonces required to start the signing process are known
       *now.
       * </pre>
       *
       * <code>bool have_all_nonces = 1;</code>
       * @param value The haveAllNonces to set.
       * @return This builder for chaining.
       */
      public Builder setHaveAllNonces(boolean value) {

        haveAllNonces_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       *
       *Indicates whether all nonces required to start the signing process are known
       *now.
       * </pre>
       *
       * <code>bool have_all_nonces = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearHaveAllNonces() {
        bitField0_ = (bitField0_ & ~0x00000001);
        haveAllNonces_ = false;
        onChanged();
        return this;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:signrpc.MuSig2RegisterNoncesResponse)
    }

    // @@protoc_insertion_point(class_scope:signrpc.MuSig2RegisterNoncesResponse)
    private static final signrpc.SignerOuterClass.MuSig2RegisterNoncesResponse DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new signrpc.SignerOuterClass.MuSig2RegisterNoncesResponse();
    }

    public static signrpc.SignerOuterClass.MuSig2RegisterNoncesResponse getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<MuSig2RegisterNoncesResponse>
        PARSER = new com.google.protobuf.AbstractParser<MuSig2RegisterNoncesResponse>() {
      @java.lang.Override
      public MuSig2RegisterNoncesResponse parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<MuSig2RegisterNoncesResponse> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<MuSig2RegisterNoncesResponse> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public signrpc.SignerOuterClass.MuSig2RegisterNoncesResponse getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface MuSig2SignRequestOrBuilder extends
      // @@protoc_insertion_point(interface_extends:signrpc.MuSig2SignRequest)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     *
     *The unique ID of the signing session to use for signing.
     * </pre>
     *
     * <code>bytes session_id = 1;</code>
     * @return The sessionId.
     */
    com.google.protobuf.ByteString getSessionId();

    /**
     * <pre>
     *
     *The 32-byte SHA256 digest of the message to sign.
     * </pre>
     *
     * <code>bytes message_digest = 2;</code>
     * @return The messageDigest.
     */
    com.google.protobuf.ByteString getMessageDigest();

    /**
     * <pre>
     *
     *Cleanup indicates that after signing, the session state can be cleaned up,
     *since another participant is going to be responsible for combining the
     *partial signatures.
     * </pre>
     *
     * <code>bool cleanup = 3;</code>
     * @return The cleanup.
     */
    boolean getCleanup();
  }
  /**
   * Protobuf type {@code signrpc.MuSig2SignRequest}
   */
  public static final class MuSig2SignRequest extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:signrpc.MuSig2SignRequest)
      MuSig2SignRequestOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use MuSig2SignRequest.newBuilder() to construct.
    private MuSig2SignRequest(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private MuSig2SignRequest() {
      sessionId_ = com.google.protobuf.ByteString.EMPTY;
      messageDigest_ = com.google.protobuf.ByteString.EMPTY;
    }

    @java.lang.Override
    @SuppressWarnings({"unused"})
    protected java.lang.Object newInstance(
        UnusedPrivateParameter unused) {
      return new MuSig2SignRequest();
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return signrpc.SignerOuterClass.internal_static_signrpc_MuSig2SignRequest_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return signrpc.SignerOuterClass.internal_static_signrpc_MuSig2SignRequest_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              signrpc.SignerOuterClass.MuSig2SignRequest.class, signrpc.SignerOuterClass.MuSig2SignRequest.Builder.class);
    }

    public static final int SESSION_ID_FIELD_NUMBER = 1;
    private com.google.protobuf.ByteString sessionId_ = com.google.protobuf.ByteString.EMPTY;
    /**
     * <pre>
     *
     *The unique ID of the signing session to use for signing.
     * </pre>
     *
     * <code>bytes session_id = 1;</code>
     * @return The sessionId.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString getSessionId() {
      return sessionId_;
    }

    public static final int MESSAGE_DIGEST_FIELD_NUMBER = 2;
    private com.google.protobuf.ByteString messageDigest_ = com.google.protobuf.ByteString.EMPTY;
    /**
     * <pre>
     *
     *The 32-byte SHA256 digest of the message to sign.
     * </pre>
     *
     * <code>bytes message_digest = 2;</code>
     * @return The messageDigest.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString getMessageDigest() {
      return messageDigest_;
    }

    public static final int CLEANUP_FIELD_NUMBER = 3;
    private boolean cleanup_ = false;
    /**
     * <pre>
     *
     *Cleanup indicates that after signing, the session state can be cleaned up,
     *since another participant is going to be responsible for combining the
     *partial signatures.
     * </pre>
     *
     * <code>bool cleanup = 3;</code>
     * @return The cleanup.
     */
    @java.lang.Override
    public boolean getCleanup() {
      return cleanup_;
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (!sessionId_.isEmpty()) {
        output.writeBytes(1, sessionId_);
      }
      if (!messageDigest_.isEmpty()) {
        output.writeBytes(2, messageDigest_);
      }
      if (cleanup_ != false) {
        output.writeBool(3, cleanup_);
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (!sessionId_.isEmpty()) {
        size += com.google.protobuf.CodedOutputStream
          .computeBytesSize(1, sessionId_);
      }
      if (!messageDigest_.isEmpty()) {
        size += com.google.protobuf.CodedOutputStream
          .computeBytesSize(2, messageDigest_);
      }
      if (cleanup_ != false) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(3, cleanup_);
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof signrpc.SignerOuterClass.MuSig2SignRequest)) {
        return super.equals(obj);
      }
      signrpc.SignerOuterClass.MuSig2SignRequest other = (signrpc.SignerOuterClass.MuSig2SignRequest) obj;

      if (!getSessionId()
          .equals(other.getSessionId())) return false;
      if (!getMessageDigest()
          .equals(other.getMessageDigest())) return false;
      if (getCleanup()
          != other.getCleanup()) return false;
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      hash = (37 * hash) + SESSION_ID_FIELD_NUMBER;
      hash = (53 * hash) + getSessionId().hashCode();
      hash = (37 * hash) + MESSAGE_DIGEST_FIELD_NUMBER;
      hash = (53 * hash) + getMessageDigest().hashCode();
      hash = (37 * hash) + CLEANUP_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
          getCleanup());
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static signrpc.SignerOuterClass.MuSig2SignRequest parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static signrpc.SignerOuterClass.MuSig2SignRequest parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static signrpc.SignerOuterClass.MuSig2SignRequest parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static signrpc.SignerOuterClass.MuSig2SignRequest parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static signrpc.SignerOuterClass.MuSig2SignRequest parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static signrpc.SignerOuterClass.MuSig2SignRequest parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static signrpc.SignerOuterClass.MuSig2SignRequest parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static signrpc.SignerOuterClass.MuSig2SignRequest parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static signrpc.SignerOuterClass.MuSig2SignRequest parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static signrpc.SignerOuterClass.MuSig2SignRequest parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static signrpc.SignerOuterClass.MuSig2SignRequest parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static signrpc.SignerOuterClass.MuSig2SignRequest parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(signrpc.SignerOuterClass.MuSig2SignRequest prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * Protobuf type {@code signrpc.MuSig2SignRequest}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:signrpc.MuSig2SignRequest)
        signrpc.SignerOuterClass.MuSig2SignRequestOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return signrpc.SignerOuterClass.internal_static_signrpc_MuSig2SignRequest_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return signrpc.SignerOuterClass.internal_static_signrpc_MuSig2SignRequest_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                signrpc.SignerOuterClass.MuSig2SignRequest.class, signrpc.SignerOuterClass.MuSig2SignRequest.Builder.class);
      }

      // Construct using signrpc.SignerOuterClass.MuSig2SignRequest.newBuilder()
      private Builder() {

      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);

      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        sessionId_ = com.google.protobuf.ByteString.EMPTY;
        messageDigest_ = com.google.protobuf.ByteString.EMPTY;
        cleanup_ = false;
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return signrpc.SignerOuterClass.internal_static_signrpc_MuSig2SignRequest_descriptor;
      }

      @java.lang.Override
      public signrpc.SignerOuterClass.MuSig2SignRequest getDefaultInstanceForType() {
        return signrpc.SignerOuterClass.MuSig2SignRequest.getDefaultInstance();
      }

      @java.lang.Override
      public signrpc.SignerOuterClass.MuSig2SignRequest build() {
        signrpc.SignerOuterClass.MuSig2SignRequest result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public signrpc.SignerOuterClass.MuSig2SignRequest buildPartial() {
        signrpc.SignerOuterClass.MuSig2SignRequest result = new signrpc.SignerOuterClass.MuSig2SignRequest(this);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartial0(signrpc.SignerOuterClass.MuSig2SignRequest result) {
        int from_bitField0_ = bitField0_;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.sessionId_ = sessionId_;
        }
        if (((from_bitField0_ & 0x00000002) != 0)) {
          result.messageDigest_ = messageDigest_;
        }
        if (((from_bitField0_ & 0x00000004) != 0)) {
          result.cleanup_ = cleanup_;
        }
      }

      @java.lang.Override
      public Builder clone() {
        return super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof signrpc.SignerOuterClass.MuSig2SignRequest) {
          return mergeFrom((signrpc.SignerOuterClass.MuSig2SignRequest)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(signrpc.SignerOuterClass.MuSig2SignRequest other) {
        if (other == signrpc.SignerOuterClass.MuSig2SignRequest.getDefaultInstance()) return this;
        if (other.getSessionId() != com.google.protobuf.ByteString.EMPTY) {
          setSessionId(other.getSessionId());
        }
        if (other.getMessageDigest() != com.google.protobuf.ByteString.EMPTY) {
          setMessageDigest(other.getMessageDigest());
        }
        if (other.getCleanup() != false) {
          setCleanup(other.getCleanup());
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10: {
                sessionId_ = input.readBytes();
                bitField0_ |= 0x00000001;
                break;
              } // case 10
              case 18: {
                messageDigest_ = input.readBytes();
                bitField0_ |= 0x00000002;
                break;
              } // case 18
              case 24: {
                cleanup_ = input.readBool();
                bitField0_ |= 0x00000004;
                break;
              } // case 24
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private com.google.protobuf.ByteString sessionId_ = com.google.protobuf.ByteString.EMPTY;
      /**
       * <pre>
       *
       *The unique ID of the signing session to use for signing.
       * </pre>
       *
       * <code>bytes session_id = 1;</code>
       * @return The sessionId.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString getSessionId() {
        return sessionId_;
      }
      /**
       * <pre>
       *
       *The unique ID of the signing session to use for signing.
       * </pre>
       *
       * <code>bytes session_id = 1;</code>
       * @param value The sessionId to set.
       * @return This builder for chaining.
       */
      public Builder setSessionId(com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        sessionId_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       *
       *The unique ID of the signing session to use for signing.
       * </pre>
       *
       * <code>bytes session_id = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearSessionId() {
        bitField0_ = (bitField0_ & ~0x00000001);
        sessionId_ = getDefaultInstance().getSessionId();
        onChanged();
        return this;
      }

      private com.google.protobuf.ByteString messageDigest_ = com.google.protobuf.ByteString.EMPTY;
      /**
       * <pre>
       *
       *The 32-byte SHA256 digest of the message to sign.
       * </pre>
       *
       * <code>bytes message_digest = 2;</code>
       * @return The messageDigest.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString getMessageDigest() {
        return messageDigest_;
      }
      /**
       * <pre>
       *
       *The 32-byte SHA256 digest of the message to sign.
       * </pre>
       *
       * <code>bytes message_digest = 2;</code>
       * @param value The messageDigest to set.
       * @return This builder for chaining.
       */
      public Builder setMessageDigest(com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        messageDigest_ = value;
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       *
       *The 32-byte SHA256 digest of the message to sign.
       * </pre>
       *
       * <code>bytes message_digest = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearMessageDigest() {
        bitField0_ = (bitField0_ & ~0x00000002);
        messageDigest_ = getDefaultInstance().getMessageDigest();
        onChanged();
        return this;
      }

      private boolean cleanup_ ;
      /**
       * <pre>
       *
       *Cleanup indicates that after signing, the session state can be cleaned up,
       *since another participant is going to be responsible for combining the
       *partial signatures.
       * </pre>
       *
       * <code>bool cleanup = 3;</code>
       * @return The cleanup.
       */
      @java.lang.Override
      public boolean getCleanup() {
        return cleanup_;
      }
      /**
       * <pre>
       *
       *Cleanup indicates that after signing, the session state can be cleaned up,
       *since another participant is going to be responsible for combining the
       *partial signatures.
       * </pre>
       *
       * <code>bool cleanup = 3;</code>
       * @param value The cleanup to set.
       * @return This builder for chaining.
       */
      public Builder setCleanup(boolean value) {

        cleanup_ = value;
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }
      /**
       * <pre>
       *
       *Cleanup indicates that after signing, the session state can be cleaned up,
       *since another participant is going to be responsible for combining the
       *partial signatures.
       * </pre>
       *
       * <code>bool cleanup = 3;</code>
       * @return This builder for chaining.
       */
      public Builder clearCleanup() {
        bitField0_ = (bitField0_ & ~0x00000004);
        cleanup_ = false;
        onChanged();
        return this;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:signrpc.MuSig2SignRequest)
    }

    // @@protoc_insertion_point(class_scope:signrpc.MuSig2SignRequest)
    private static final signrpc.SignerOuterClass.MuSig2SignRequest DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new signrpc.SignerOuterClass.MuSig2SignRequest();
    }

    public static signrpc.SignerOuterClass.MuSig2SignRequest getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<MuSig2SignRequest>
        PARSER = new com.google.protobuf.AbstractParser<MuSig2SignRequest>() {
      @java.lang.Override
      public MuSig2SignRequest parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<MuSig2SignRequest> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<MuSig2SignRequest> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public signrpc.SignerOuterClass.MuSig2SignRequest getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface MuSig2SignResponseOrBuilder extends
      // @@protoc_insertion_point(interface_extends:signrpc.MuSig2SignResponse)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     *
     *The partial signature created by the local signer.
     * </pre>
     *
     * <code>bytes local_partial_signature = 1;</code>
     * @return The localPartialSignature.
     */
    com.google.protobuf.ByteString getLocalPartialSignature();
  }
  /**
   * Protobuf type {@code signrpc.MuSig2SignResponse}
   */
  public static final class MuSig2SignResponse extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:signrpc.MuSig2SignResponse)
      MuSig2SignResponseOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use MuSig2SignResponse.newBuilder() to construct.
    private MuSig2SignResponse(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private MuSig2SignResponse() {
      localPartialSignature_ = com.google.protobuf.ByteString.EMPTY;
    }

    @java.lang.Override
    @SuppressWarnings({"unused"})
    protected java.lang.Object newInstance(
        UnusedPrivateParameter unused) {
      return new MuSig2SignResponse();
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return signrpc.SignerOuterClass.internal_static_signrpc_MuSig2SignResponse_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return signrpc.SignerOuterClass.internal_static_signrpc_MuSig2SignResponse_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              signrpc.SignerOuterClass.MuSig2SignResponse.class, signrpc.SignerOuterClass.MuSig2SignResponse.Builder.class);
    }

    public static final int LOCAL_PARTIAL_SIGNATURE_FIELD_NUMBER = 1;
    private com.google.protobuf.ByteString localPartialSignature_ = com.google.protobuf.ByteString.EMPTY;
    /**
     * <pre>
     *
     *The partial signature created by the local signer.
     * </pre>
     *
     * <code>bytes local_partial_signature = 1;</code>
     * @return The localPartialSignature.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString getLocalPartialSignature() {
      return localPartialSignature_;
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (!localPartialSignature_.isEmpty()) {
        output.writeBytes(1, localPartialSignature_);
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (!localPartialSignature_.isEmpty()) {
        size += com.google.protobuf.CodedOutputStream
          .computeBytesSize(1, localPartialSignature_);
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof signrpc.SignerOuterClass.MuSig2SignResponse)) {
        return super.equals(obj);
      }
      signrpc.SignerOuterClass.MuSig2SignResponse other = (signrpc.SignerOuterClass.MuSig2SignResponse) obj;

      if (!getLocalPartialSignature()
          .equals(other.getLocalPartialSignature())) return false;
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      hash = (37 * hash) + LOCAL_PARTIAL_SIGNATURE_FIELD_NUMBER;
      hash = (53 * hash) + getLocalPartialSignature().hashCode();
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static signrpc.SignerOuterClass.MuSig2SignResponse parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static signrpc.SignerOuterClass.MuSig2SignResponse parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static signrpc.SignerOuterClass.MuSig2SignResponse parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static signrpc.SignerOuterClass.MuSig2SignResponse parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static signrpc.SignerOuterClass.MuSig2SignResponse parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static signrpc.SignerOuterClass.MuSig2SignResponse parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static signrpc.SignerOuterClass.MuSig2SignResponse parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static signrpc.SignerOuterClass.MuSig2SignResponse parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static signrpc.SignerOuterClass.MuSig2SignResponse parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static signrpc.SignerOuterClass.MuSig2SignResponse parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static signrpc.SignerOuterClass.MuSig2SignResponse parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static signrpc.SignerOuterClass.MuSig2SignResponse parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(signrpc.SignerOuterClass.MuSig2SignResponse prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * Protobuf type {@code signrpc.MuSig2SignResponse}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:signrpc.MuSig2SignResponse)
        signrpc.SignerOuterClass.MuSig2SignResponseOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return signrpc.SignerOuterClass.internal_static_signrpc_MuSig2SignResponse_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return signrpc.SignerOuterClass.internal_static_signrpc_MuSig2SignResponse_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                signrpc.SignerOuterClass.MuSig2SignResponse.class, signrpc.SignerOuterClass.MuSig2SignResponse.Builder.class);
      }

      // Construct using signrpc.SignerOuterClass.MuSig2SignResponse.newBuilder()
      private Builder() {

      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);

      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        localPartialSignature_ = com.google.protobuf.ByteString.EMPTY;
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return signrpc.SignerOuterClass.internal_static_signrpc_MuSig2SignResponse_descriptor;
      }

      @java.lang.Override
      public signrpc.SignerOuterClass.MuSig2SignResponse getDefaultInstanceForType() {
        return signrpc.SignerOuterClass.MuSig2SignResponse.getDefaultInstance();
      }

      @java.lang.Override
      public signrpc.SignerOuterClass.MuSig2SignResponse build() {
        signrpc.SignerOuterClass.MuSig2SignResponse result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public signrpc.SignerOuterClass.MuSig2SignResponse buildPartial() {
        signrpc.SignerOuterClass.MuSig2SignResponse result = new signrpc.SignerOuterClass.MuSig2SignResponse(this);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartial0(signrpc.SignerOuterClass.MuSig2SignResponse result) {
        int from_bitField0_ = bitField0_;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.localPartialSignature_ = localPartialSignature_;
        }
      }

      @java.lang.Override
      public Builder clone() {
        return super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof signrpc.SignerOuterClass.MuSig2SignResponse) {
          return mergeFrom((signrpc.SignerOuterClass.MuSig2SignResponse)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(signrpc.SignerOuterClass.MuSig2SignResponse other) {
        if (other == signrpc.SignerOuterClass.MuSig2SignResponse.getDefaultInstance()) return this;
        if (other.getLocalPartialSignature() != com.google.protobuf.ByteString.EMPTY) {
          setLocalPartialSignature(other.getLocalPartialSignature());
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10: {
                localPartialSignature_ = input.readBytes();
                bitField0_ |= 0x00000001;
                break;
              } // case 10
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private com.google.protobuf.ByteString localPartialSignature_ = com.google.protobuf.ByteString.EMPTY;
      /**
       * <pre>
       *
       *The partial signature created by the local signer.
       * </pre>
       *
       * <code>bytes local_partial_signature = 1;</code>
       * @return The localPartialSignature.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString getLocalPartialSignature() {
        return localPartialSignature_;
      }
      /**
       * <pre>
       *
       *The partial signature created by the local signer.
       * </pre>
       *
       * <code>bytes local_partial_signature = 1;</code>
       * @param value The localPartialSignature to set.
       * @return This builder for chaining.
       */
      public Builder setLocalPartialSignature(com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        localPartialSignature_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       *
       *The partial signature created by the local signer.
       * </pre>
       *
       * <code>bytes local_partial_signature = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearLocalPartialSignature() {
        bitField0_ = (bitField0_ & ~0x00000001);
        localPartialSignature_ = getDefaultInstance().getLocalPartialSignature();
        onChanged();
        return this;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:signrpc.MuSig2SignResponse)
    }

    // @@protoc_insertion_point(class_scope:signrpc.MuSig2SignResponse)
    private static final signrpc.SignerOuterClass.MuSig2SignResponse DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new signrpc.SignerOuterClass.MuSig2SignResponse();
    }

    public static signrpc.SignerOuterClass.MuSig2SignResponse getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<MuSig2SignResponse>
        PARSER = new com.google.protobuf.AbstractParser<MuSig2SignResponse>() {
      @java.lang.Override
      public MuSig2SignResponse parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<MuSig2SignResponse> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<MuSig2SignResponse> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public signrpc.SignerOuterClass.MuSig2SignResponse getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface MuSig2CombineSigRequestOrBuilder extends
      // @@protoc_insertion_point(interface_extends:signrpc.MuSig2CombineSigRequest)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     *
     *The unique ID of the signing session to combine the signatures for.
     * </pre>
     *
     * <code>bytes session_id = 1;</code>
     * @return The sessionId.
     */
    com.google.protobuf.ByteString getSessionId();

    /**
     * <pre>
     *
     *The list of all other participants' partial signatures to add to the current
     *session.
     * </pre>
     *
     * <code>repeated bytes other_partial_signatures = 2;</code>
     * @return A list containing the otherPartialSignatures.
     */
    java.util.List<com.google.protobuf.ByteString> getOtherPartialSignaturesList();
    /**
     * <pre>
     *
     *The list of all other participants' partial signatures to add to the current
     *session.
     * </pre>
     *
     * <code>repeated bytes other_partial_signatures = 2;</code>
     * @return The count of otherPartialSignatures.
     */
    int getOtherPartialSignaturesCount();
    /**
     * <pre>
     *
     *The list of all other participants' partial signatures to add to the current
     *session.
     * </pre>
     *
     * <code>repeated bytes other_partial_signatures = 2;</code>
     * @param index The index of the element to return.
     * @return The otherPartialSignatures at the given index.
     */
    com.google.protobuf.ByteString getOtherPartialSignatures(int index);
  }
  /**
   * Protobuf type {@code signrpc.MuSig2CombineSigRequest}
   */
  public static final class MuSig2CombineSigRequest extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:signrpc.MuSig2CombineSigRequest)
      MuSig2CombineSigRequestOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use MuSig2CombineSigRequest.newBuilder() to construct.
    private MuSig2CombineSigRequest(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private MuSig2CombineSigRequest() {
      sessionId_ = com.google.protobuf.ByteString.EMPTY;
      otherPartialSignatures_ = emptyList(com.google.protobuf.ByteString.class);
    }

    @java.lang.Override
    @SuppressWarnings({"unused"})
    protected java.lang.Object newInstance(
        UnusedPrivateParameter unused) {
      return new MuSig2CombineSigRequest();
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return signrpc.SignerOuterClass.internal_static_signrpc_MuSig2CombineSigRequest_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return signrpc.SignerOuterClass.internal_static_signrpc_MuSig2CombineSigRequest_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              signrpc.SignerOuterClass.MuSig2CombineSigRequest.class, signrpc.SignerOuterClass.MuSig2CombineSigRequest.Builder.class);
    }

    public static final int SESSION_ID_FIELD_NUMBER = 1;
    private com.google.protobuf.ByteString sessionId_ = com.google.protobuf.ByteString.EMPTY;
    /**
     * <pre>
     *
     *The unique ID of the signing session to combine the signatures for.
     * </pre>
     *
     * <code>bytes session_id = 1;</code>
     * @return The sessionId.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString getSessionId() {
      return sessionId_;
    }

    public static final int OTHER_PARTIAL_SIGNATURES_FIELD_NUMBER = 2;
    @SuppressWarnings("serial")
    private com.google.protobuf.Internal.ProtobufList<com.google.protobuf.ByteString> otherPartialSignatures_ =
        emptyList(com.google.protobuf.ByteString.class);
    /**
     * <pre>
     *
     *The list of all other participants' partial signatures to add to the current
     *session.
     * </pre>
     *
     * <code>repeated bytes other_partial_signatures = 2;</code>
     * @return A list containing the otherPartialSignatures.
     */
    @java.lang.Override
    public java.util.List<com.google.protobuf.ByteString>
        getOtherPartialSignaturesList() {
      return otherPartialSignatures_;
    }
    /**
     * <pre>
     *
     *The list of all other participants' partial signatures to add to the current
     *session.
     * </pre>
     *
     * <code>repeated bytes other_partial_signatures = 2;</code>
     * @return The count of otherPartialSignatures.
     */
    public int getOtherPartialSignaturesCount() {
      return otherPartialSignatures_.size();
    }
    /**
     * <pre>
     *
     *The list of all other participants' partial signatures to add to the current
     *session.
     * </pre>
     *
     * <code>repeated bytes other_partial_signatures = 2;</code>
     * @param index The index of the element to return.
     * @return The otherPartialSignatures at the given index.
     */
    public com.google.protobuf.ByteString getOtherPartialSignatures(int index) {
      return otherPartialSignatures_.get(index);
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (!sessionId_.isEmpty()) {
        output.writeBytes(1, sessionId_);
      }
      for (int i = 0; i < otherPartialSignatures_.size(); i++) {
        output.writeBytes(2, otherPartialSignatures_.get(i));
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (!sessionId_.isEmpty()) {
        size += com.google.protobuf.CodedOutputStream
          .computeBytesSize(1, sessionId_);
      }
      {
        int dataSize = 0;
        for (int i = 0; i < otherPartialSignatures_.size(); i++) {
          dataSize += com.google.protobuf.CodedOutputStream
            .computeBytesSizeNoTag(otherPartialSignatures_.get(i));
        }
        size += dataSize;
        size += 1 * getOtherPartialSignaturesList().size();
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof signrpc.SignerOuterClass.MuSig2CombineSigRequest)) {
        return super.equals(obj);
      }
      signrpc.SignerOuterClass.MuSig2CombineSigRequest other = (signrpc.SignerOuterClass.MuSig2CombineSigRequest) obj;

      if (!getSessionId()
          .equals(other.getSessionId())) return false;
      if (!getOtherPartialSignaturesList()
          .equals(other.getOtherPartialSignaturesList())) return false;
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      hash = (37 * hash) + SESSION_ID_FIELD_NUMBER;
      hash = (53 * hash) + getSessionId().hashCode();
      if (getOtherPartialSignaturesCount() > 0) {
        hash = (37 * hash) + OTHER_PARTIAL_SIGNATURES_FIELD_NUMBER;
        hash = (53 * hash) + getOtherPartialSignaturesList().hashCode();
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static signrpc.SignerOuterClass.MuSig2CombineSigRequest parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static signrpc.SignerOuterClass.MuSig2CombineSigRequest parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static signrpc.SignerOuterClass.MuSig2CombineSigRequest parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static signrpc.SignerOuterClass.MuSig2CombineSigRequest parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static signrpc.SignerOuterClass.MuSig2CombineSigRequest parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static signrpc.SignerOuterClass.MuSig2CombineSigRequest parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static signrpc.SignerOuterClass.MuSig2CombineSigRequest parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static signrpc.SignerOuterClass.MuSig2CombineSigRequest parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static signrpc.SignerOuterClass.MuSig2CombineSigRequest parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static signrpc.SignerOuterClass.MuSig2CombineSigRequest parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static signrpc.SignerOuterClass.MuSig2CombineSigRequest parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static signrpc.SignerOuterClass.MuSig2CombineSigRequest parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(signrpc.SignerOuterClass.MuSig2CombineSigRequest prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * Protobuf type {@code signrpc.MuSig2CombineSigRequest}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:signrpc.MuSig2CombineSigRequest)
        signrpc.SignerOuterClass.MuSig2CombineSigRequestOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return signrpc.SignerOuterClass.internal_static_signrpc_MuSig2CombineSigRequest_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return signrpc.SignerOuterClass.internal_static_signrpc_MuSig2CombineSigRequest_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                signrpc.SignerOuterClass.MuSig2CombineSigRequest.class, signrpc.SignerOuterClass.MuSig2CombineSigRequest.Builder.class);
      }

      // Construct using signrpc.SignerOuterClass.MuSig2CombineSigRequest.newBuilder()
      private Builder() {

      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);

      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        sessionId_ = com.google.protobuf.ByteString.EMPTY;
        otherPartialSignatures_ = emptyList(com.google.protobuf.ByteString.class);
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return signrpc.SignerOuterClass.internal_static_signrpc_MuSig2CombineSigRequest_descriptor;
      }

      @java.lang.Override
      public signrpc.SignerOuterClass.MuSig2CombineSigRequest getDefaultInstanceForType() {
        return signrpc.SignerOuterClass.MuSig2CombineSigRequest.getDefaultInstance();
      }

      @java.lang.Override
      public signrpc.SignerOuterClass.MuSig2CombineSigRequest build() {
        signrpc.SignerOuterClass.MuSig2CombineSigRequest result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public signrpc.SignerOuterClass.MuSig2CombineSigRequest buildPartial() {
        signrpc.SignerOuterClass.MuSig2CombineSigRequest result = new signrpc.SignerOuterClass.MuSig2CombineSigRequest(this);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartial0(signrpc.SignerOuterClass.MuSig2CombineSigRequest result) {
        int from_bitField0_ = bitField0_;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.sessionId_ = sessionId_;
        }
        if (((from_bitField0_ & 0x00000002) != 0)) {
          otherPartialSignatures_.makeImmutable();
          result.otherPartialSignatures_ = otherPartialSignatures_;
        }
      }

      @java.lang.Override
      public Builder clone() {
        return super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof signrpc.SignerOuterClass.MuSig2CombineSigRequest) {
          return mergeFrom((signrpc.SignerOuterClass.MuSig2CombineSigRequest)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(signrpc.SignerOuterClass.MuSig2CombineSigRequest other) {
        if (other == signrpc.SignerOuterClass.MuSig2CombineSigRequest.getDefaultInstance()) return this;
        if (other.getSessionId() != com.google.protobuf.ByteString.EMPTY) {
          setSessionId(other.getSessionId());
        }
        if (!other.otherPartialSignatures_.isEmpty()) {
          if (otherPartialSignatures_.isEmpty()) {
            otherPartialSignatures_ = other.otherPartialSignatures_;
            otherPartialSignatures_.makeImmutable();
            bitField0_ |= 0x00000002;
          } else {
            ensureOtherPartialSignaturesIsMutable();
            otherPartialSignatures_.addAll(other.otherPartialSignatures_);
          }
          onChanged();
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10: {
                sessionId_ = input.readBytes();
                bitField0_ |= 0x00000001;
                break;
              } // case 10
              case 18: {
                com.google.protobuf.ByteString v = input.readBytes();
                ensureOtherPartialSignaturesIsMutable();
                otherPartialSignatures_.add(v);
                break;
              } // case 18
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private com.google.protobuf.ByteString sessionId_ = com.google.protobuf.ByteString.EMPTY;
      /**
       * <pre>
       *
       *The unique ID of the signing session to combine the signatures for.
       * </pre>
       *
       * <code>bytes session_id = 1;</code>
       * @return The sessionId.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString getSessionId() {
        return sessionId_;
      }
      /**
       * <pre>
       *
       *The unique ID of the signing session to combine the signatures for.
       * </pre>
       *
       * <code>bytes session_id = 1;</code>
       * @param value The sessionId to set.
       * @return This builder for chaining.
       */
      public Builder setSessionId(com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        sessionId_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       *
       *The unique ID of the signing session to combine the signatures for.
       * </pre>
       *
       * <code>bytes session_id = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearSessionId() {
        bitField0_ = (bitField0_ & ~0x00000001);
        sessionId_ = getDefaultInstance().getSessionId();
        onChanged();
        return this;
      }

      private com.google.protobuf.Internal.ProtobufList<com.google.protobuf.ByteString> otherPartialSignatures_ = emptyList(com.google.protobuf.ByteString.class);
      private void ensureOtherPartialSignaturesIsMutable() {
        if (!otherPartialSignatures_.isModifiable()) {
          otherPartialSignatures_ = makeMutableCopy(otherPartialSignatures_);
        }
        bitField0_ |= 0x00000002;
      }
      /**
       * <pre>
       *
       *The list of all other participants' partial signatures to add to the current
       *session.
       * </pre>
       *
       * <code>repeated bytes other_partial_signatures = 2;</code>
       * @return A list containing the otherPartialSignatures.
       */
      public java.util.List<com.google.protobuf.ByteString>
          getOtherPartialSignaturesList() {
        otherPartialSignatures_.makeImmutable();
        return otherPartialSignatures_;
      }
      /**
       * <pre>
       *
       *The list of all other participants' partial signatures to add to the current
       *session.
       * </pre>
       *
       * <code>repeated bytes other_partial_signatures = 2;</code>
       * @return The count of otherPartialSignatures.
       */
      public int getOtherPartialSignaturesCount() {
        return otherPartialSignatures_.size();
      }
      /**
       * <pre>
       *
       *The list of all other participants' partial signatures to add to the current
       *session.
       * </pre>
       *
       * <code>repeated bytes other_partial_signatures = 2;</code>
       * @param index The index of the element to return.
       * @return The otherPartialSignatures at the given index.
       */
      public com.google.protobuf.ByteString getOtherPartialSignatures(int index) {
        return otherPartialSignatures_.get(index);
      }
      /**
       * <pre>
       *
       *The list of all other participants' partial signatures to add to the current
       *session.
       * </pre>
       *
       * <code>repeated bytes other_partial_signatures = 2;</code>
       * @param index The index to set the value at.
       * @param value The otherPartialSignatures to set.
       * @return This builder for chaining.
       */
      public Builder setOtherPartialSignatures(
          int index, com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        ensureOtherPartialSignaturesIsMutable();
        otherPartialSignatures_.set(index, value);
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       *
       *The list of all other participants' partial signatures to add to the current
       *session.
       * </pre>
       *
       * <code>repeated bytes other_partial_signatures = 2;</code>
       * @param value The otherPartialSignatures to add.
       * @return This builder for chaining.
       */
      public Builder addOtherPartialSignatures(com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        ensureOtherPartialSignaturesIsMutable();
        otherPartialSignatures_.add(value);
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       *
       *The list of all other participants' partial signatures to add to the current
       *session.
       * </pre>
       *
       * <code>repeated bytes other_partial_signatures = 2;</code>
       * @param values The otherPartialSignatures to add.
       * @return This builder for chaining.
       */
      public Builder addAllOtherPartialSignatures(
          java.lang.Iterable<? extends com.google.protobuf.ByteString> values) {
        ensureOtherPartialSignaturesIsMutable();
        com.google.protobuf.AbstractMessageLite.Builder.addAll(
            values, otherPartialSignatures_);
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       *
       *The list of all other participants' partial signatures to add to the current
       *session.
       * </pre>
       *
       * <code>repeated bytes other_partial_signatures = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearOtherPartialSignatures() {
        otherPartialSignatures_ = emptyList(com.google.protobuf.ByteString.class);
        bitField0_ = (bitField0_ & ~0x00000002);
        onChanged();
        return this;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:signrpc.MuSig2CombineSigRequest)
    }

    // @@protoc_insertion_point(class_scope:signrpc.MuSig2CombineSigRequest)
    private static final signrpc.SignerOuterClass.MuSig2CombineSigRequest DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new signrpc.SignerOuterClass.MuSig2CombineSigRequest();
    }

    public static signrpc.SignerOuterClass.MuSig2CombineSigRequest getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<MuSig2CombineSigRequest>
        PARSER = new com.google.protobuf.AbstractParser<MuSig2CombineSigRequest>() {
      @java.lang.Override
      public MuSig2CombineSigRequest parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<MuSig2CombineSigRequest> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<MuSig2CombineSigRequest> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public signrpc.SignerOuterClass.MuSig2CombineSigRequest getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface MuSig2CombineSigResponseOrBuilder extends
      // @@protoc_insertion_point(interface_extends:signrpc.MuSig2CombineSigResponse)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     *
     *Indicates whether all partial signatures required to create a final, full
     *signature are known yet. If this is true, then the final_signature field is
     *set, otherwise it is empty.
     * </pre>
     *
     * <code>bool have_all_signatures = 1;</code>
     * @return The haveAllSignatures.
     */
    boolean getHaveAllSignatures();

    /**
     * <pre>
     *
     *The final, full signature that is valid for the combined public key.
     * </pre>
     *
     * <code>bytes final_signature = 2;</code>
     * @return The finalSignature.
     */
    com.google.protobuf.ByteString getFinalSignature();
  }
  /**
   * Protobuf type {@code signrpc.MuSig2CombineSigResponse}
   */
  public static final class MuSig2CombineSigResponse extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:signrpc.MuSig2CombineSigResponse)
      MuSig2CombineSigResponseOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use MuSig2CombineSigResponse.newBuilder() to construct.
    private MuSig2CombineSigResponse(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private MuSig2CombineSigResponse() {
      finalSignature_ = com.google.protobuf.ByteString.EMPTY;
    }

    @java.lang.Override
    @SuppressWarnings({"unused"})
    protected java.lang.Object newInstance(
        UnusedPrivateParameter unused) {
      return new MuSig2CombineSigResponse();
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return signrpc.SignerOuterClass.internal_static_signrpc_MuSig2CombineSigResponse_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return signrpc.SignerOuterClass.internal_static_signrpc_MuSig2CombineSigResponse_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              signrpc.SignerOuterClass.MuSig2CombineSigResponse.class, signrpc.SignerOuterClass.MuSig2CombineSigResponse.Builder.class);
    }

    public static final int HAVE_ALL_SIGNATURES_FIELD_NUMBER = 1;
    private boolean haveAllSignatures_ = false;
    /**
     * <pre>
     *
     *Indicates whether all partial signatures required to create a final, full
     *signature are known yet. If this is true, then the final_signature field is
     *set, otherwise it is empty.
     * </pre>
     *
     * <code>bool have_all_signatures = 1;</code>
     * @return The haveAllSignatures.
     */
    @java.lang.Override
    public boolean getHaveAllSignatures() {
      return haveAllSignatures_;
    }

    public static final int FINAL_SIGNATURE_FIELD_NUMBER = 2;
    private com.google.protobuf.ByteString finalSignature_ = com.google.protobuf.ByteString.EMPTY;
    /**
     * <pre>
     *
     *The final, full signature that is valid for the combined public key.
     * </pre>
     *
     * <code>bytes final_signature = 2;</code>
     * @return The finalSignature.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString getFinalSignature() {
      return finalSignature_;
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (haveAllSignatures_ != false) {
        output.writeBool(1, haveAllSignatures_);
      }
      if (!finalSignature_.isEmpty()) {
        output.writeBytes(2, finalSignature_);
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (haveAllSignatures_ != false) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(1, haveAllSignatures_);
      }
      if (!finalSignature_.isEmpty()) {
        size += com.google.protobuf.CodedOutputStream
          .computeBytesSize(2, finalSignature_);
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof signrpc.SignerOuterClass.MuSig2CombineSigResponse)) {
        return super.equals(obj);
      }
      signrpc.SignerOuterClass.MuSig2CombineSigResponse other = (signrpc.SignerOuterClass.MuSig2CombineSigResponse) obj;

      if (getHaveAllSignatures()
          != other.getHaveAllSignatures()) return false;
      if (!getFinalSignature()
          .equals(other.getFinalSignature())) return false;
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      hash = (37 * hash) + HAVE_ALL_SIGNATURES_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
          getHaveAllSignatures());
      hash = (37 * hash) + FINAL_SIGNATURE_FIELD_NUMBER;
      hash = (53 * hash) + getFinalSignature().hashCode();
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static signrpc.SignerOuterClass.MuSig2CombineSigResponse parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static signrpc.SignerOuterClass.MuSig2CombineSigResponse parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static signrpc.SignerOuterClass.MuSig2CombineSigResponse parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static signrpc.SignerOuterClass.MuSig2CombineSigResponse parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static signrpc.SignerOuterClass.MuSig2CombineSigResponse parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static signrpc.SignerOuterClass.MuSig2CombineSigResponse parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static signrpc.SignerOuterClass.MuSig2CombineSigResponse parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static signrpc.SignerOuterClass.MuSig2CombineSigResponse parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static signrpc.SignerOuterClass.MuSig2CombineSigResponse parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static signrpc.SignerOuterClass.MuSig2CombineSigResponse parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static signrpc.SignerOuterClass.MuSig2CombineSigResponse parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static signrpc.SignerOuterClass.MuSig2CombineSigResponse parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(signrpc.SignerOuterClass.MuSig2CombineSigResponse prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * Protobuf type {@code signrpc.MuSig2CombineSigResponse}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:signrpc.MuSig2CombineSigResponse)
        signrpc.SignerOuterClass.MuSig2CombineSigResponseOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return signrpc.SignerOuterClass.internal_static_signrpc_MuSig2CombineSigResponse_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return signrpc.SignerOuterClass.internal_static_signrpc_MuSig2CombineSigResponse_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                signrpc.SignerOuterClass.MuSig2CombineSigResponse.class, signrpc.SignerOuterClass.MuSig2CombineSigResponse.Builder.class);
      }

      // Construct using signrpc.SignerOuterClass.MuSig2CombineSigResponse.newBuilder()
      private Builder() {

      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);

      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        haveAllSignatures_ = false;
        finalSignature_ = com.google.protobuf.ByteString.EMPTY;
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return signrpc.SignerOuterClass.internal_static_signrpc_MuSig2CombineSigResponse_descriptor;
      }

      @java.lang.Override
      public signrpc.SignerOuterClass.MuSig2CombineSigResponse getDefaultInstanceForType() {
        return signrpc.SignerOuterClass.MuSig2CombineSigResponse.getDefaultInstance();
      }

      @java.lang.Override
      public signrpc.SignerOuterClass.MuSig2CombineSigResponse build() {
        signrpc.SignerOuterClass.MuSig2CombineSigResponse result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public signrpc.SignerOuterClass.MuSig2CombineSigResponse buildPartial() {
        signrpc.SignerOuterClass.MuSig2CombineSigResponse result = new signrpc.SignerOuterClass.MuSig2CombineSigResponse(this);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartial0(signrpc.SignerOuterClass.MuSig2CombineSigResponse result) {
        int from_bitField0_ = bitField0_;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.haveAllSignatures_ = haveAllSignatures_;
        }
        if (((from_bitField0_ & 0x00000002) != 0)) {
          result.finalSignature_ = finalSignature_;
        }
      }

      @java.lang.Override
      public Builder clone() {
        return super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof signrpc.SignerOuterClass.MuSig2CombineSigResponse) {
          return mergeFrom((signrpc.SignerOuterClass.MuSig2CombineSigResponse)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(signrpc.SignerOuterClass.MuSig2CombineSigResponse other) {
        if (other == signrpc.SignerOuterClass.MuSig2CombineSigResponse.getDefaultInstance()) return this;
        if (other.getHaveAllSignatures() != false) {
          setHaveAllSignatures(other.getHaveAllSignatures());
        }
        if (other.getFinalSignature() != com.google.protobuf.ByteString.EMPTY) {
          setFinalSignature(other.getFinalSignature());
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 8: {
                haveAllSignatures_ = input.readBool();
                bitField0_ |= 0x00000001;
                break;
              } // case 8
              case 18: {
                finalSignature_ = input.readBytes();
                bitField0_ |= 0x00000002;
                break;
              } // case 18
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private boolean haveAllSignatures_ ;
      /**
       * <pre>
       *
       *Indicates whether all partial signatures required to create a final, full
       *signature are known yet. If this is true, then the final_signature field is
       *set, otherwise it is empty.
       * </pre>
       *
       * <code>bool have_all_signatures = 1;</code>
       * @return The haveAllSignatures.
       */
      @java.lang.Override
      public boolean getHaveAllSignatures() {
        return haveAllSignatures_;
      }
      /**
       * <pre>
       *
       *Indicates whether all partial signatures required to create a final, full
       *signature are known yet. If this is true, then the final_signature field is
       *set, otherwise it is empty.
       * </pre>
       *
       * <code>bool have_all_signatures = 1;</code>
       * @param value The haveAllSignatures to set.
       * @return This builder for chaining.
       */
      public Builder setHaveAllSignatures(boolean value) {

        haveAllSignatures_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       *
       *Indicates whether all partial signatures required to create a final, full
       *signature are known yet. If this is true, then the final_signature field is
       *set, otherwise it is empty.
       * </pre>
       *
       * <code>bool have_all_signatures = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearHaveAllSignatures() {
        bitField0_ = (bitField0_ & ~0x00000001);
        haveAllSignatures_ = false;
        onChanged();
        return this;
      }

      private com.google.protobuf.ByteString finalSignature_ = com.google.protobuf.ByteString.EMPTY;
      /**
       * <pre>
       *
       *The final, full signature that is valid for the combined public key.
       * </pre>
       *
       * <code>bytes final_signature = 2;</code>
       * @return The finalSignature.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString getFinalSignature() {
        return finalSignature_;
      }
      /**
       * <pre>
       *
       *The final, full signature that is valid for the combined public key.
       * </pre>
       *
       * <code>bytes final_signature = 2;</code>
       * @param value The finalSignature to set.
       * @return This builder for chaining.
       */
      public Builder setFinalSignature(com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        finalSignature_ = value;
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       *
       *The final, full signature that is valid for the combined public key.
       * </pre>
       *
       * <code>bytes final_signature = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearFinalSignature() {
        bitField0_ = (bitField0_ & ~0x00000002);
        finalSignature_ = getDefaultInstance().getFinalSignature();
        onChanged();
        return this;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:signrpc.MuSig2CombineSigResponse)
    }

    // @@protoc_insertion_point(class_scope:signrpc.MuSig2CombineSigResponse)
    private static final signrpc.SignerOuterClass.MuSig2CombineSigResponse DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new signrpc.SignerOuterClass.MuSig2CombineSigResponse();
    }

    public static signrpc.SignerOuterClass.MuSig2CombineSigResponse getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<MuSig2CombineSigResponse>
        PARSER = new com.google.protobuf.AbstractParser<MuSig2CombineSigResponse>() {
      @java.lang.Override
      public MuSig2CombineSigResponse parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<MuSig2CombineSigResponse> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<MuSig2CombineSigResponse> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public signrpc.SignerOuterClass.MuSig2CombineSigResponse getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface MuSig2CleanupRequestOrBuilder extends
      // @@protoc_insertion_point(interface_extends:signrpc.MuSig2CleanupRequest)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     *
     *The unique ID of the signing session that should be removed/cleaned up.
     * </pre>
     *
     * <code>bytes session_id = 1;</code>
     * @return The sessionId.
     */
    com.google.protobuf.ByteString getSessionId();
  }
  /**
   * Protobuf type {@code signrpc.MuSig2CleanupRequest}
   */
  public static final class MuSig2CleanupRequest extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:signrpc.MuSig2CleanupRequest)
      MuSig2CleanupRequestOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use MuSig2CleanupRequest.newBuilder() to construct.
    private MuSig2CleanupRequest(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private MuSig2CleanupRequest() {
      sessionId_ = com.google.protobuf.ByteString.EMPTY;
    }

    @java.lang.Override
    @SuppressWarnings({"unused"})
    protected java.lang.Object newInstance(
        UnusedPrivateParameter unused) {
      return new MuSig2CleanupRequest();
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return signrpc.SignerOuterClass.internal_static_signrpc_MuSig2CleanupRequest_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return signrpc.SignerOuterClass.internal_static_signrpc_MuSig2CleanupRequest_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              signrpc.SignerOuterClass.MuSig2CleanupRequest.class, signrpc.SignerOuterClass.MuSig2CleanupRequest.Builder.class);
    }

    public static final int SESSION_ID_FIELD_NUMBER = 1;
    private com.google.protobuf.ByteString sessionId_ = com.google.protobuf.ByteString.EMPTY;
    /**
     * <pre>
     *
     *The unique ID of the signing session that should be removed/cleaned up.
     * </pre>
     *
     * <code>bytes session_id = 1;</code>
     * @return The sessionId.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString getSessionId() {
      return sessionId_;
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (!sessionId_.isEmpty()) {
        output.writeBytes(1, sessionId_);
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (!sessionId_.isEmpty()) {
        size += com.google.protobuf.CodedOutputStream
          .computeBytesSize(1, sessionId_);
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof signrpc.SignerOuterClass.MuSig2CleanupRequest)) {
        return super.equals(obj);
      }
      signrpc.SignerOuterClass.MuSig2CleanupRequest other = (signrpc.SignerOuterClass.MuSig2CleanupRequest) obj;

      if (!getSessionId()
          .equals(other.getSessionId())) return false;
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      hash = (37 * hash) + SESSION_ID_FIELD_NUMBER;
      hash = (53 * hash) + getSessionId().hashCode();
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static signrpc.SignerOuterClass.MuSig2CleanupRequest parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static signrpc.SignerOuterClass.MuSig2CleanupRequest parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static signrpc.SignerOuterClass.MuSig2CleanupRequest parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static signrpc.SignerOuterClass.MuSig2CleanupRequest parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static signrpc.SignerOuterClass.MuSig2CleanupRequest parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static signrpc.SignerOuterClass.MuSig2CleanupRequest parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static signrpc.SignerOuterClass.MuSig2CleanupRequest parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static signrpc.SignerOuterClass.MuSig2CleanupRequest parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static signrpc.SignerOuterClass.MuSig2CleanupRequest parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static signrpc.SignerOuterClass.MuSig2CleanupRequest parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static signrpc.SignerOuterClass.MuSig2CleanupRequest parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static signrpc.SignerOuterClass.MuSig2CleanupRequest parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(signrpc.SignerOuterClass.MuSig2CleanupRequest prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * Protobuf type {@code signrpc.MuSig2CleanupRequest}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:signrpc.MuSig2CleanupRequest)
        signrpc.SignerOuterClass.MuSig2CleanupRequestOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return signrpc.SignerOuterClass.internal_static_signrpc_MuSig2CleanupRequest_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return signrpc.SignerOuterClass.internal_static_signrpc_MuSig2CleanupRequest_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                signrpc.SignerOuterClass.MuSig2CleanupRequest.class, signrpc.SignerOuterClass.MuSig2CleanupRequest.Builder.class);
      }

      // Construct using signrpc.SignerOuterClass.MuSig2CleanupRequest.newBuilder()
      private Builder() {

      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);

      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        sessionId_ = com.google.protobuf.ByteString.EMPTY;
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return signrpc.SignerOuterClass.internal_static_signrpc_MuSig2CleanupRequest_descriptor;
      }

      @java.lang.Override
      public signrpc.SignerOuterClass.MuSig2CleanupRequest getDefaultInstanceForType() {
        return signrpc.SignerOuterClass.MuSig2CleanupRequest.getDefaultInstance();
      }

      @java.lang.Override
      public signrpc.SignerOuterClass.MuSig2CleanupRequest build() {
        signrpc.SignerOuterClass.MuSig2CleanupRequest result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public signrpc.SignerOuterClass.MuSig2CleanupRequest buildPartial() {
        signrpc.SignerOuterClass.MuSig2CleanupRequest result = new signrpc.SignerOuterClass.MuSig2CleanupRequest(this);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartial0(signrpc.SignerOuterClass.MuSig2CleanupRequest result) {
        int from_bitField0_ = bitField0_;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.sessionId_ = sessionId_;
        }
      }

      @java.lang.Override
      public Builder clone() {
        return super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof signrpc.SignerOuterClass.MuSig2CleanupRequest) {
          return mergeFrom((signrpc.SignerOuterClass.MuSig2CleanupRequest)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(signrpc.SignerOuterClass.MuSig2CleanupRequest other) {
        if (other == signrpc.SignerOuterClass.MuSig2CleanupRequest.getDefaultInstance()) return this;
        if (other.getSessionId() != com.google.protobuf.ByteString.EMPTY) {
          setSessionId(other.getSessionId());
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10: {
                sessionId_ = input.readBytes();
                bitField0_ |= 0x00000001;
                break;
              } // case 10
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private com.google.protobuf.ByteString sessionId_ = com.google.protobuf.ByteString.EMPTY;
      /**
       * <pre>
       *
       *The unique ID of the signing session that should be removed/cleaned up.
       * </pre>
       *
       * <code>bytes session_id = 1;</code>
       * @return The sessionId.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString getSessionId() {
        return sessionId_;
      }
      /**
       * <pre>
       *
       *The unique ID of the signing session that should be removed/cleaned up.
       * </pre>
       *
       * <code>bytes session_id = 1;</code>
       * @param value The sessionId to set.
       * @return This builder for chaining.
       */
      public Builder setSessionId(com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        sessionId_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       *
       *The unique ID of the signing session that should be removed/cleaned up.
       * </pre>
       *
       * <code>bytes session_id = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearSessionId() {
        bitField0_ = (bitField0_ & ~0x00000001);
        sessionId_ = getDefaultInstance().getSessionId();
        onChanged();
        return this;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:signrpc.MuSig2CleanupRequest)
    }

    // @@protoc_insertion_point(class_scope:signrpc.MuSig2CleanupRequest)
    private static final signrpc.SignerOuterClass.MuSig2CleanupRequest DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new signrpc.SignerOuterClass.MuSig2CleanupRequest();
    }

    public static signrpc.SignerOuterClass.MuSig2CleanupRequest getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<MuSig2CleanupRequest>
        PARSER = new com.google.protobuf.AbstractParser<MuSig2CleanupRequest>() {
      @java.lang.Override
      public MuSig2CleanupRequest parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<MuSig2CleanupRequest> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<MuSig2CleanupRequest> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public signrpc.SignerOuterClass.MuSig2CleanupRequest getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface MuSig2CleanupResponseOrBuilder extends
      // @@protoc_insertion_point(interface_extends:signrpc.MuSig2CleanupResponse)
      com.google.protobuf.MessageOrBuilder {
  }
  /**
   * Protobuf type {@code signrpc.MuSig2CleanupResponse}
   */
  public static final class MuSig2CleanupResponse extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:signrpc.MuSig2CleanupResponse)
      MuSig2CleanupResponseOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use MuSig2CleanupResponse.newBuilder() to construct.
    private MuSig2CleanupResponse(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private MuSig2CleanupResponse() {
    }

    @java.lang.Override
    @SuppressWarnings({"unused"})
    protected java.lang.Object newInstance(
        UnusedPrivateParameter unused) {
      return new MuSig2CleanupResponse();
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return signrpc.SignerOuterClass.internal_static_signrpc_MuSig2CleanupResponse_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return signrpc.SignerOuterClass.internal_static_signrpc_MuSig2CleanupResponse_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              signrpc.SignerOuterClass.MuSig2CleanupResponse.class, signrpc.SignerOuterClass.MuSig2CleanupResponse.Builder.class);
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof signrpc.SignerOuterClass.MuSig2CleanupResponse)) {
        return super.equals(obj);
      }
      signrpc.SignerOuterClass.MuSig2CleanupResponse other = (signrpc.SignerOuterClass.MuSig2CleanupResponse) obj;

      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static signrpc.SignerOuterClass.MuSig2CleanupResponse parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static signrpc.SignerOuterClass.MuSig2CleanupResponse parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static signrpc.SignerOuterClass.MuSig2CleanupResponse parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static signrpc.SignerOuterClass.MuSig2CleanupResponse parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static signrpc.SignerOuterClass.MuSig2CleanupResponse parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static signrpc.SignerOuterClass.MuSig2CleanupResponse parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static signrpc.SignerOuterClass.MuSig2CleanupResponse parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static signrpc.SignerOuterClass.MuSig2CleanupResponse parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static signrpc.SignerOuterClass.MuSig2CleanupResponse parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static signrpc.SignerOuterClass.MuSig2CleanupResponse parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static signrpc.SignerOuterClass.MuSig2CleanupResponse parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static signrpc.SignerOuterClass.MuSig2CleanupResponse parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(signrpc.SignerOuterClass.MuSig2CleanupResponse prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * Protobuf type {@code signrpc.MuSig2CleanupResponse}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:signrpc.MuSig2CleanupResponse)
        signrpc.SignerOuterClass.MuSig2CleanupResponseOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return signrpc.SignerOuterClass.internal_static_signrpc_MuSig2CleanupResponse_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return signrpc.SignerOuterClass.internal_static_signrpc_MuSig2CleanupResponse_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                signrpc.SignerOuterClass.MuSig2CleanupResponse.class, signrpc.SignerOuterClass.MuSig2CleanupResponse.Builder.class);
      }

      // Construct using signrpc.SignerOuterClass.MuSig2CleanupResponse.newBuilder()
      private Builder() {

      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);

      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return signrpc.SignerOuterClass.internal_static_signrpc_MuSig2CleanupResponse_descriptor;
      }

      @java.lang.Override
      public signrpc.SignerOuterClass.MuSig2CleanupResponse getDefaultInstanceForType() {
        return signrpc.SignerOuterClass.MuSig2CleanupResponse.getDefaultInstance();
      }

      @java.lang.Override
      public signrpc.SignerOuterClass.MuSig2CleanupResponse build() {
        signrpc.SignerOuterClass.MuSig2CleanupResponse result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public signrpc.SignerOuterClass.MuSig2CleanupResponse buildPartial() {
        signrpc.SignerOuterClass.MuSig2CleanupResponse result = new signrpc.SignerOuterClass.MuSig2CleanupResponse(this);
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof signrpc.SignerOuterClass.MuSig2CleanupResponse) {
          return mergeFrom((signrpc.SignerOuterClass.MuSig2CleanupResponse)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(signrpc.SignerOuterClass.MuSig2CleanupResponse other) {
        if (other == signrpc.SignerOuterClass.MuSig2CleanupResponse.getDefaultInstance()) return this;
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:signrpc.MuSig2CleanupResponse)
    }

    // @@protoc_insertion_point(class_scope:signrpc.MuSig2CleanupResponse)
    private static final signrpc.SignerOuterClass.MuSig2CleanupResponse DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new signrpc.SignerOuterClass.MuSig2CleanupResponse();
    }

    public static signrpc.SignerOuterClass.MuSig2CleanupResponse getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<MuSig2CleanupResponse>
        PARSER = new com.google.protobuf.AbstractParser<MuSig2CleanupResponse>() {
      @java.lang.Override
      public MuSig2CleanupResponse parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<MuSig2CleanupResponse> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<MuSig2CleanupResponse> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public signrpc.SignerOuterClass.MuSig2CleanupResponse getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_signrpc_KeyLocator_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_signrpc_KeyLocator_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_signrpc_KeyDescriptor_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_signrpc_KeyDescriptor_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_signrpc_TxOut_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_signrpc_TxOut_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_signrpc_SignDescriptor_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_signrpc_SignDescriptor_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_signrpc_SignReq_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_signrpc_SignReq_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_signrpc_SignResp_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_signrpc_SignResp_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_signrpc_InputScript_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_signrpc_InputScript_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_signrpc_InputScriptResp_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_signrpc_InputScriptResp_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_signrpc_SignMessageReq_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_signrpc_SignMessageReq_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_signrpc_SignMessageResp_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_signrpc_SignMessageResp_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_signrpc_VerifyMessageReq_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_signrpc_VerifyMessageReq_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_signrpc_VerifyMessageResp_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_signrpc_VerifyMessageResp_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_signrpc_SharedKeyRequest_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_signrpc_SharedKeyRequest_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_signrpc_SharedKeyResponse_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_signrpc_SharedKeyResponse_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_signrpc_TweakDesc_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_signrpc_TweakDesc_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_signrpc_TaprootTweakDesc_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_signrpc_TaprootTweakDesc_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_signrpc_MuSig2CombineKeysRequest_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_signrpc_MuSig2CombineKeysRequest_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_signrpc_MuSig2CombineKeysResponse_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_signrpc_MuSig2CombineKeysResponse_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_signrpc_MuSig2SessionRequest_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_signrpc_MuSig2SessionRequest_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_signrpc_MuSig2SessionResponse_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_signrpc_MuSig2SessionResponse_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_signrpc_MuSig2RegisterNoncesRequest_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_signrpc_MuSig2RegisterNoncesRequest_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_signrpc_MuSig2RegisterNoncesResponse_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_signrpc_MuSig2RegisterNoncesResponse_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_signrpc_MuSig2SignRequest_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_signrpc_MuSig2SignRequest_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_signrpc_MuSig2SignResponse_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_signrpc_MuSig2SignResponse_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_signrpc_MuSig2CombineSigRequest_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_signrpc_MuSig2CombineSigRequest_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_signrpc_MuSig2CombineSigResponse_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_signrpc_MuSig2CombineSigResponse_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_signrpc_MuSig2CleanupRequest_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_signrpc_MuSig2CleanupRequest_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_signrpc_MuSig2CleanupResponse_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_signrpc_MuSig2CleanupResponse_fieldAccessorTable;

  public static com.google.protobuf.Descriptors.FileDescriptor
      getDescriptor() {
    return descriptor;
  }
  private static  com.google.protobuf.Descriptors.FileDescriptor
      descriptor;
  static {
    java.lang.String[] descriptorData = {
      "\n\024signrpc/signer.proto\022\007signrpc\"3\n\nKeyLo" +
      "cator\022\022\n\nkey_family\030\001 \001(\005\022\021\n\tkey_index\030\002" +
      " \001(\005\"L\n\rKeyDescriptor\022\025\n\rraw_key_bytes\030\001" +
      " \001(\014\022$\n\007key_loc\030\002 \001(\0132\023.signrpc.KeyLocat" +
      "or\")\n\005TxOut\022\r\n\005value\030\001 \001(\003\022\021\n\tpk_script\030" +
      "\002 \001(\014\"\201\002\n\016SignDescriptor\022(\n\010key_desc\030\001 \001" +
      "(\0132\026.signrpc.KeyDescriptor\022\024\n\014single_twe" +
      "ak\030\002 \001(\014\022\024\n\014double_tweak\030\003 \001(\014\022\021\n\ttap_tw" +
      "eak\030\n \001(\014\022\026\n\016witness_script\030\004 \001(\014\022\036\n\006out" +
      "put\030\005 \001(\0132\016.signrpc.TxOut\022\017\n\007sighash\030\007 \001" +
      "(\r\022\023\n\013input_index\030\010 \001(\005\022(\n\013sign_method\030\t" +
      " \001(\0162\023.signrpc.SignMethod\"r\n\007SignReq\022\024\n\014" +
      "raw_tx_bytes\030\001 \001(\014\022+\n\nsign_descs\030\002 \003(\0132\027" +
      ".signrpc.SignDescriptor\022$\n\014prev_outputs\030" +
      "\003 \003(\0132\016.signrpc.TxOut\"\034\n\010SignResp\022\020\n\010raw" +
      "_sigs\030\001 \003(\014\"2\n\013InputScript\022\017\n\007witness\030\001 " +
      "\003(\014\022\022\n\nsig_script\030\002 \001(\014\">\n\017InputScriptRe" +
      "sp\022+\n\rinput_scripts\030\001 \003(\0132\024.signrpc.Inpu" +
      "tScript\"\241\001\n\016SignMessageReq\022\013\n\003msg\030\001 \001(\014\022" +
      "$\n\007key_loc\030\002 \001(\0132\023.signrpc.KeyLocator\022\023\n" +
      "\013double_hash\030\003 \001(\010\022\023\n\013compact_sig\030\004 \001(\010\022" +
      "\023\n\013schnorr_sig\030\005 \001(\010\022\035\n\025schnorr_sig_tap_" +
      "tweak\030\006 \001(\014\"$\n\017SignMessageResp\022\021\n\tsignat" +
      "ure\030\001 \001(\014\"Z\n\020VerifyMessageReq\022\013\n\003msg\030\001 \001" +
      "(\014\022\021\n\tsignature\030\002 \001(\014\022\016\n\006pubkey\030\003 \001(\014\022\026\n" +
      "\016is_schnorr_sig\030\004 \001(\010\"\"\n\021VerifyMessageRe" +
      "sp\022\r\n\005valid\030\001 \001(\010\"\200\001\n\020SharedKeyRequest\022\030" +
      "\n\020ephemeral_pubkey\030\001 \001(\014\022(\n\007key_loc\030\002 \001(" +
      "\0132\023.signrpc.KeyLocatorB\002\030\001\022(\n\010key_desc\030\003" +
      " \001(\0132\026.signrpc.KeyDescriptor\"\'\n\021SharedKe" +
      "yResponse\022\022\n\nshared_key\030\001 \001(\014\"-\n\tTweakDe" +
      "sc\022\r\n\005tweak\030\001 \001(\014\022\021\n\tis_x_only\030\002 \001(\010\"?\n\020" +
      "TaprootTweakDesc\022\023\n\013script_root\030\001 \001(\014\022\026\n" +
      "\016key_spend_only\030\002 \001(\010\"\265\001\n\030MuSig2CombineK" +
      "eysRequest\022\032\n\022all_signer_pubkeys\030\001 \003(\014\022\"" +
      "\n\006tweaks\030\002 \003(\0132\022.signrpc.TweakDesc\0220\n\rta" +
      "proot_tweak\030\003 \001(\0132\031.signrpc.TaprootTweak" +
      "Desc\022\'\n\007version\030\004 \001(\0162\026.signrpc.MuSig2Ve" +
      "rsion\"x\n\031MuSig2CombineKeysResponse\022\024\n\014co" +
      "mbined_key\030\001 \001(\014\022\034\n\024taproot_internal_key" +
      "\030\002 \001(\014\022\'\n\007version\030\004 \001(\0162\026.signrpc.MuSig2" +
      "Version\"\373\001\n\024MuSig2SessionRequest\022$\n\007key_" +
      "loc\030\001 \001(\0132\023.signrpc.KeyLocator\022\032\n\022all_si" +
      "gner_pubkeys\030\002 \003(\014\022\"\n\032other_signer_publi" +
      "c_nonces\030\003 \003(\014\022\"\n\006tweaks\030\004 \003(\0132\022.signrpc" +
      ".TweakDesc\0220\n\rtaproot_tweak\030\005 \001(\0132\031.sign" +
      "rpc.TaprootTweakDesc\022\'\n\007version\030\006 \001(\0162\026." +
      "signrpc.MuSig2Version\"\276\001\n\025MuSig2SessionR" +
      "esponse\022\022\n\nsession_id\030\001 \001(\014\022\024\n\014combined_" +
      "key\030\002 \001(\014\022\034\n\024taproot_internal_key\030\003 \001(\014\022" +
      "\033\n\023local_public_nonces\030\004 \001(\014\022\027\n\017have_all" +
      "_nonces\030\005 \001(\010\022\'\n\007version\030\006 \001(\0162\026.signrpc" +
      ".MuSig2Version\"U\n\033MuSig2RegisterNoncesRe" +
      "quest\022\022\n\nsession_id\030\001 \001(\014\022\"\n\032other_signe" +
      "r_public_nonces\030\003 \003(\014\"7\n\034MuSig2RegisterN" +
      "oncesResponse\022\027\n\017have_all_nonces\030\001 \001(\010\"P" +
      "\n\021MuSig2SignRequest\022\022\n\nsession_id\030\001 \001(\014\022" +
      "\026\n\016message_digest\030\002 \001(\014\022\017\n\007cleanup\030\003 \001(\010" +
      "\"5\n\022MuSig2SignResponse\022\037\n\027local_partial_" +
      "signature\030\001 \001(\014\"O\n\027MuSig2CombineSigReque" +
      "st\022\022\n\nsession_id\030\001 \001(\014\022 \n\030other_partial_" +
      "signatures\030\002 \003(\014\"P\n\030MuSig2CombineSigResp" +
      "onse\022\033\n\023have_all_signatures\030\001 \001(\010\022\027\n\017fin" +
      "al_signature\030\002 \001(\014\"*\n\024MuSig2CleanupReque" +
      "st\022\022\n\nsession_id\030\001 \001(\014\"\027\n\025MuSig2CleanupR" +
      "esponse*\234\001\n\nSignMethod\022\032\n\026SIGN_METHOD_WI" +
      "TNESS_V0\020\000\022)\n%SIGN_METHOD_TAPROOT_KEY_SP" +
      "END_BIP0086\020\001\022!\n\035SIGN_METHOD_TAPROOT_KEY" +
      "_SPEND\020\002\022$\n SIGN_METHOD_TAPROOT_SCRIPT_S" +
      "PEND\020\003*b\n\rMuSig2Version\022\034\n\030MUSIG2_VERSIO" +
      "N_UNDEFINED\020\000\022\027\n\023MUSIG2_VERSION_V040\020\001\022\032" +
      "\n\026MUSIG2_VERSION_V100RC2\020\0022\333\006\n\006Signer\0224\n" +
      "\rSignOutputRaw\022\020.signrpc.SignReq\032\021.signr" +
      "pc.SignResp\022@\n\022ComputeInputScript\022\020.sign" +
      "rpc.SignReq\032\030.signrpc.InputScriptResp\022@\n" +
      "\013SignMessage\022\027.signrpc.SignMessageReq\032\030." +
      "signrpc.SignMessageResp\022F\n\rVerifyMessage" +
      "\022\031.signrpc.VerifyMessageReq\032\032.signrpc.Ve" +
      "rifyMessageResp\022H\n\017DeriveSharedKey\022\031.sig" +
      "nrpc.SharedKeyRequest\032\032.signrpc.SharedKe" +
      "yResponse\022Z\n\021MuSig2CombineKeys\022!.signrpc" +
      ".MuSig2CombineKeysRequest\032\".signrpc.MuSi" +
      "g2CombineKeysResponse\022T\n\023MuSig2CreateSes" +
      "sion\022\035.signrpc.MuSig2SessionRequest\032\036.si" +
      "gnrpc.MuSig2SessionResponse\022c\n\024MuSig2Reg" +
      "isterNonces\022$.signrpc.MuSig2RegisterNonc" +
      "esRequest\032%.signrpc.MuSig2RegisterNonces" +
      "Response\022E\n\nMuSig2Sign\022\032.signrpc.MuSig2S" +
      "ignRequest\032\033.signrpc.MuSig2SignResponse\022" +
      "W\n\020MuSig2CombineSig\022 .signrpc.MuSig2Comb" +
      "ineSigRequest\032!.signrpc.MuSig2CombineSig" +
      "Response\022N\n\rMuSig2Cleanup\022\035.signrpc.MuSi" +
      "g2CleanupRequest\032\036.signrpc.MuSig2Cleanup" +
      "ResponseB/Z-github.com/lightningnetwork/" +
      "lnd/lnrpc/signrpcb\006proto3"
    };
    descriptor = com.google.protobuf.Descriptors.FileDescriptor
      .internalBuildGeneratedFileFrom(descriptorData,
        new com.google.protobuf.Descriptors.FileDescriptor[] {
        });
    internal_static_signrpc_KeyLocator_descriptor =
      getDescriptor().getMessageTypes().get(0);
    internal_static_signrpc_KeyLocator_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_signrpc_KeyLocator_descriptor,
        new java.lang.String[] { "KeyFamily", "KeyIndex", });
    internal_static_signrpc_KeyDescriptor_descriptor =
      getDescriptor().getMessageTypes().get(1);
    internal_static_signrpc_KeyDescriptor_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_signrpc_KeyDescriptor_descriptor,
        new java.lang.String[] { "RawKeyBytes", "KeyLoc", });
    internal_static_signrpc_TxOut_descriptor =
      getDescriptor().getMessageTypes().get(2);
    internal_static_signrpc_TxOut_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_signrpc_TxOut_descriptor,
        new java.lang.String[] { "Value", "PkScript", });
    internal_static_signrpc_SignDescriptor_descriptor =
      getDescriptor().getMessageTypes().get(3);
    internal_static_signrpc_SignDescriptor_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_signrpc_SignDescriptor_descriptor,
        new java.lang.String[] { "KeyDesc", "SingleTweak", "DoubleTweak", "TapTweak", "WitnessScript", "Output", "Sighash", "InputIndex", "SignMethod", });
    internal_static_signrpc_SignReq_descriptor =
      getDescriptor().getMessageTypes().get(4);
    internal_static_signrpc_SignReq_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_signrpc_SignReq_descriptor,
        new java.lang.String[] { "RawTxBytes", "SignDescs", "PrevOutputs", });
    internal_static_signrpc_SignResp_descriptor =
      getDescriptor().getMessageTypes().get(5);
    internal_static_signrpc_SignResp_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_signrpc_SignResp_descriptor,
        new java.lang.String[] { "RawSigs", });
    internal_static_signrpc_InputScript_descriptor =
      getDescriptor().getMessageTypes().get(6);
    internal_static_signrpc_InputScript_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_signrpc_InputScript_descriptor,
        new java.lang.String[] { "Witness", "SigScript", });
    internal_static_signrpc_InputScriptResp_descriptor =
      getDescriptor().getMessageTypes().get(7);
    internal_static_signrpc_InputScriptResp_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_signrpc_InputScriptResp_descriptor,
        new java.lang.String[] { "InputScripts", });
    internal_static_signrpc_SignMessageReq_descriptor =
      getDescriptor().getMessageTypes().get(8);
    internal_static_signrpc_SignMessageReq_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_signrpc_SignMessageReq_descriptor,
        new java.lang.String[] { "Msg", "KeyLoc", "DoubleHash", "CompactSig", "SchnorrSig", "SchnorrSigTapTweak", });
    internal_static_signrpc_SignMessageResp_descriptor =
      getDescriptor().getMessageTypes().get(9);
    internal_static_signrpc_SignMessageResp_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_signrpc_SignMessageResp_descriptor,
        new java.lang.String[] { "Signature", });
    internal_static_signrpc_VerifyMessageReq_descriptor =
      getDescriptor().getMessageTypes().get(10);
    internal_static_signrpc_VerifyMessageReq_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_signrpc_VerifyMessageReq_descriptor,
        new java.lang.String[] { "Msg", "Signature", "Pubkey", "IsSchnorrSig", });
    internal_static_signrpc_VerifyMessageResp_descriptor =
      getDescriptor().getMessageTypes().get(11);
    internal_static_signrpc_VerifyMessageResp_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_signrpc_VerifyMessageResp_descriptor,
        new java.lang.String[] { "Valid", });
    internal_static_signrpc_SharedKeyRequest_descriptor =
      getDescriptor().getMessageTypes().get(12);
    internal_static_signrpc_SharedKeyRequest_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_signrpc_SharedKeyRequest_descriptor,
        new java.lang.String[] { "EphemeralPubkey", "KeyLoc", "KeyDesc", });
    internal_static_signrpc_SharedKeyResponse_descriptor =
      getDescriptor().getMessageTypes().get(13);
    internal_static_signrpc_SharedKeyResponse_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_signrpc_SharedKeyResponse_descriptor,
        new java.lang.String[] { "SharedKey", });
    internal_static_signrpc_TweakDesc_descriptor =
      getDescriptor().getMessageTypes().get(14);
    internal_static_signrpc_TweakDesc_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_signrpc_TweakDesc_descriptor,
        new java.lang.String[] { "Tweak", "IsXOnly", });
    internal_static_signrpc_TaprootTweakDesc_descriptor =
      getDescriptor().getMessageTypes().get(15);
    internal_static_signrpc_TaprootTweakDesc_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_signrpc_TaprootTweakDesc_descriptor,
        new java.lang.String[] { "ScriptRoot", "KeySpendOnly", });
    internal_static_signrpc_MuSig2CombineKeysRequest_descriptor =
      getDescriptor().getMessageTypes().get(16);
    internal_static_signrpc_MuSig2CombineKeysRequest_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_signrpc_MuSig2CombineKeysRequest_descriptor,
        new java.lang.String[] { "AllSignerPubkeys", "Tweaks", "TaprootTweak", "Version", });
    internal_static_signrpc_MuSig2CombineKeysResponse_descriptor =
      getDescriptor().getMessageTypes().get(17);
    internal_static_signrpc_MuSig2CombineKeysResponse_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_signrpc_MuSig2CombineKeysResponse_descriptor,
        new java.lang.String[] { "CombinedKey", "TaprootInternalKey", "Version", });
    internal_static_signrpc_MuSig2SessionRequest_descriptor =
      getDescriptor().getMessageTypes().get(18);
    internal_static_signrpc_MuSig2SessionRequest_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_signrpc_MuSig2SessionRequest_descriptor,
        new java.lang.String[] { "KeyLoc", "AllSignerPubkeys", "OtherSignerPublicNonces", "Tweaks", "TaprootTweak", "Version", });
    internal_static_signrpc_MuSig2SessionResponse_descriptor =
      getDescriptor().getMessageTypes().get(19);
    internal_static_signrpc_MuSig2SessionResponse_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_signrpc_MuSig2SessionResponse_descriptor,
        new java.lang.String[] { "SessionId", "CombinedKey", "TaprootInternalKey", "LocalPublicNonces", "HaveAllNonces", "Version", });
    internal_static_signrpc_MuSig2RegisterNoncesRequest_descriptor =
      getDescriptor().getMessageTypes().get(20);
    internal_static_signrpc_MuSig2RegisterNoncesRequest_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_signrpc_MuSig2RegisterNoncesRequest_descriptor,
        new java.lang.String[] { "SessionId", "OtherSignerPublicNonces", });
    internal_static_signrpc_MuSig2RegisterNoncesResponse_descriptor =
      getDescriptor().getMessageTypes().get(21);
    internal_static_signrpc_MuSig2RegisterNoncesResponse_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_signrpc_MuSig2RegisterNoncesResponse_descriptor,
        new java.lang.String[] { "HaveAllNonces", });
    internal_static_signrpc_MuSig2SignRequest_descriptor =
      getDescriptor().getMessageTypes().get(22);
    internal_static_signrpc_MuSig2SignRequest_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_signrpc_MuSig2SignRequest_descriptor,
        new java.lang.String[] { "SessionId", "MessageDigest", "Cleanup", });
    internal_static_signrpc_MuSig2SignResponse_descriptor =
      getDescriptor().getMessageTypes().get(23);
    internal_static_signrpc_MuSig2SignResponse_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_signrpc_MuSig2SignResponse_descriptor,
        new java.lang.String[] { "LocalPartialSignature", });
    internal_static_signrpc_MuSig2CombineSigRequest_descriptor =
      getDescriptor().getMessageTypes().get(24);
    internal_static_signrpc_MuSig2CombineSigRequest_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_signrpc_MuSig2CombineSigRequest_descriptor,
        new java.lang.String[] { "SessionId", "OtherPartialSignatures", });
    internal_static_signrpc_MuSig2CombineSigResponse_descriptor =
      getDescriptor().getMessageTypes().get(25);
    internal_static_signrpc_MuSig2CombineSigResponse_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_signrpc_MuSig2CombineSigResponse_descriptor,
        new java.lang.String[] { "HaveAllSignatures", "FinalSignature", });
    internal_static_signrpc_MuSig2CleanupRequest_descriptor =
      getDescriptor().getMessageTypes().get(26);
    internal_static_signrpc_MuSig2CleanupRequest_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_signrpc_MuSig2CleanupRequest_descriptor,
        new java.lang.String[] { "SessionId", });
    internal_static_signrpc_MuSig2CleanupResponse_descriptor =
      getDescriptor().getMessageTypes().get(27);
    internal_static_signrpc_MuSig2CleanupResponse_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_signrpc_MuSig2CleanupResponse_descriptor,
        new java.lang.String[] { });
  }

  // @@protoc_insertion_point(outer_class_scope)
}
